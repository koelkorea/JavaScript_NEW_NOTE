<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>리터럴 클래스를 매개변수의 값으로 사용하기-2</title>
    <style>
        
    </style>
    <script src="../libs/jquery-3.5.1.min.js"></script>
    <script>

        //  [오브젝트 리터털 방식]
        // : 클래스를 프로퍼티를 가진 객체의 값을 넣듯 {}안에 '요소: 요소값', '요소:멤버함수(메서드)'를 채워넣어 객체를 생성하는 방법

        // (특징)
        //  오브젝트 리터럴 방식은 오로지 하나의 인스턴스(객체)만 가짐
        //  (= 정확히는 {} 안에 프로퍼티(멤버변수), 메서드(객체 안 멤버함수)가 존재하고, 이들을 정의하고 값을 주는 동시에 그 인스턴스는 생성됨)
        //       -> (장점) 1. new 연산자 사용하지 않아도 인스턴스가 만들어짐
        //                 2. 가독성 + 프로그램 효율성 증가
        //          (단점) 리터럴 방식으로는 여러개의 객체를 찍어내지 못하고, 1개만 만들수 있다.

        // (용도)
        //  1. 여러개의 데이터를 일시적으로 포장할 용도의 그릇으로 쓰거나
        //  2. 함수에 줄 매개변수를 입력할 경우...


        // new 연산자 ? 해당 클래스 생성자를 기반, 사용자 정의 객체 타입 또는 내장 객체 타입의 인스턴스를 생성하라는 연산자(멤버들의 크기만큼 메모리에 할당)
        //              ex) var 변수 = new 클래스(); 의 의미 : 변수안에 해당 클래스를 기반으로 객체타입을 만들고 생성자에 따른 값을 넣거나 초기화하라


        // 특정 객체의 css 속성값 접근 및 수정과정을 통해, 리터널 방식의 장점을 알아보자 
        $(document).ready(function(){

            var $bar1 = $("#bar1");

            // ($bar1에 css값을 적용하는 기존 방법)
            //  :  리터럴을 사용하지 않고, $bar1 객체에 css속성 하나마다 일일이 css()함수 호출을 통해 수정 작업,
            //     -> css()를 3번이나 호출하는 효율에 문제를 보임
            // $bar1.css("position", "absolute");
            // $bar1.css("left", 100);
            // $bar1.css("top", 100);

            // ($bar1 내 css 속성들을 css속성의 멤버변수(프로퍼티)로서, 리터럴 방식으로 수정하는 방법)
            //  : 리터럴 방식을 통해, $bar1객체의 css를 프로퍼티로서 1번만 호출하고,
            //    그 내부의 css속성들을 css프로퍼티 내의 프로퍼티로서 한 번에 수정
            //      -> 가독성 + 프록그램 효율 2마리의 토끼를 다 잡는 방법
            $bar1.css({
                "position" : "absolute",
                "left" : 100,
                "top" : 100
            });

        });

    </script>
</head>
<body>
    <img src="../images/newbtn.bar.1.png" id="bar1">
</body>
</html>
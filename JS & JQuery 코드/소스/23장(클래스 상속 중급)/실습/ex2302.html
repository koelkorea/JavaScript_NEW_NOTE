<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>부모 클래스의 생성자 호출(타 oop기준 super 예약어) - 2</title>
    <script>

        // (객체지향구조의 상속관련 기능에 대한 이론적 기초 정리)
        // 1. 부모 - 자식 클래스간 상속 + 확장 구조 : 
        //  -> 부모 클래스(메인 플랫폼) : 모든 자식들의 공통적인 멤버를 갖춘 클래스로 모든 자식들의 모체이자 기반으로서 기획됨
        //  -> 자식 클래스(추가 에드온) : 기반이 되는 부모클래스의 멤버(private, 부모 생성자 제외)를 이어받고, 거기에 자신만의 멤버를 통해 자신만의 객체개념 완성 

        // 2. (중요!) 1의 관계(플랫폼, 에드온)에 따른  상속관계에 있는 자식 인스턴스의 구조 및 생성 개념
        //  : 부모클래스의 인스턴스가 먼저 생성, 그 후에 자식 클래스의 생성자가 호출되어 자식클래스의 인스턴스 생성
        //  (= 자식클래스의 인스턴스(에드온)는 부모클래스의 인스턴스(플랫폼)를 기반으로 생성 의미함)
        //      -> 에드온은 플랫폼이 있어야 성립가능한 관계를 떠올리면 됨

        // [call함수 = JS버전의 타 OOP super 예약어 기능]
        // 부모클래스명.call(this, 필요한 매개변수1 ~ n) : 부모클래스의 매개변수가 있는 생성자 호출 코드
        //  -> call 함수의 매개변수 의미 : 1번째 매개변수 this = 자식클래스의 인스턴스, 2번째 이후 매개변수 = 부모클래스 생성자 호출에 필요한 매개변수들
        //     (주의점) : 이 역시 일종의 꼼수로 완벽하게 타 oop의 super같은 역할을 하진 못함
        //       ->  부모클래스명.call함수의 용도 : 해당 클래스 or 함수를 실행하는것이 아니라, 코드 자체를 this 안에 불러와 줘서 연장해 쓰게하는것

        // 클래스명1.prototype.메서드명.call(클래스명2, parameter1,..., n)
        //  : 클래스명2 내부에 클래스명1의 메서드명의 코드 내용 자체를 해당 파라미터 값들을 넣은 상태로 불러와서 내용 연결이나 연장 가능하게 함 

        // [JS버전의 타 oop의 extends 부모클래스명 기능]
        // 자식클래스명.prototype = new 부모클래스명() : 부모-자식 상속관계 정의 코드

        // (중요!) call함수, 상속관계 코드의 관계
        //  -> call함수(자신의 부모를 호출하는 타 oop의 'super'의 쓰임새와 유사)
        //      : js에서는 자식클래스 성립에 기반이 되는 부모클래스 생성자를 멤버변수와 함께 호출하여, 자식클래스에 부모의 매개변수를 채워줌(초기화함)
        //  -> 상속관계(타 oop의 'extends 부모클래스명' 의 쓰임새와 유사)
        //      : 이를 통해 클래스 간 부모-자식 관계를 공식적으로 정의하며, 없으면 부모-자식이 아니므로 상속 관련 코드가 실행이 문제됨

        // 부모클래스 정의 (멤버 5개 = 프로퍼티2 + 메서드3)
        function Tv(power, channel) {

            // 프로퍼티 생성
            this.power = power;
            this.channel = channel;
        }

        // 부모클래스의 메서드 정의
        Tv.prototype.power = function() {

            this.power = !power;
        }

        Tv.prototype.channelUp = function() {

            ++this.chnnel;
        }

        Tv.prototype.channelDown = function() {

            --this.chnnel;
        }

        // 자식클래스 정의
        function CaptionTv(caption) {

            // 부모클래스명.call(this, 필요한 매개변수1 ~ n) : 부모클래스의 매개변수가 2개 있는 생성자 호출 코드
            //  -> call 함수의 매개변수 의미 : 1번째 매개변수 this = 자식클래스의 인스턴스, 2번째 이후 매개변수 = 부모클래스 생성자 호출에 필요한 매개변수들
            Tv.call(this, true, 10);

            // 자식클래스 고유의 프로퍼티 생성(초기화 포함)
            this.caption = caption;
        }

        // 부모-자식 상속 코드 (타 oop의 extends 부모클래스명)
        CaptionTv.prototype = new Tv();

        // 자식클래스 메서드 정의
        CaptionTv.prototype.displayCaption = function(text) {

            // 자식 클래스의 프로퍼티 caption = true일때만, 콘솔에 text를 출력
            if(this.caption) {
                console.log(text);
            }
        }

        // 자식클래스의 인스턴스 생성
        var captionTv = new CaptionTv(true);
        captionTv.displayCaption("캡션기능 출력 메세지 hello!");

        console.log("부모클래스 프로퍼티 power : " + captionTv.power);
        console.log("부모클래스 프로퍼티 channel : " + captionTv.channel);
    </script>
</head>
<body>
    
</body>
</html>
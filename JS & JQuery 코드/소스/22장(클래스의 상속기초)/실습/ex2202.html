<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>클래스의 상속 예제-2</title>
    <script src="../libs/jquery-3.5.1.min.js"></script>
    <script>

        // 자식클래스명.prototype = new 부모클래명() : js에서의 상속문법(매우 중요!)
        //  -> 상속문법의 코딩위치 : 자식클래스의 멤버 메서드의 위, 부모클래스 멤버메서드가 끝난 뒤 바로 다음줄 

        //  - 객체지향적 프로그래밍의 필수 요소 (= 이 4가지가 다 충족되지 않으면 객체지향 X)
        //      1. 추상화(Abstraction)   : 해당 클래스나 혹은 그 클래스에서 상속되는 클래스 계열의 객체들이 공통적으로 가지고 있어야 하는 속성과 메서드를 개념적으로 선언
        //                                (= 이게 중요한 이유는 이러한 공통 개념을 시작으로 인터페이스나, 추상클래스를 완성시, 추후 상속을 통해 이를 쉽게 관리하고 완성이 가능하기 때문) 
        //                                  -> 클래스, 추상클래스, 인터페이스들이 추상화와 연관 (단, js에서는 추상클래스, 인터페이스가 정식으로는 지원되지 않음)
        //      2. 캡슐화(Encapsulation) : 클래스의 변수와 함수의 접근을 '객체 외부(인스턴스를 통한 접근 포함)', '객체 내부', '자식 객체(클래스)' 중 어디까지 가능하게 할 건지 통제기능
        //                                  -> 이를 접근지정자(타OOP언어 기준 private(본 클래스 자체만 접근가능), protected(상속된 클래스 자체까지 접근가능), public) 라고 함
        //                                      -> 그 중 private, protected로 구분된 멤버들은 인스턴스를 통해서 직접 접근이 불가능!!
        //                                          ex) Human 클래스의 private gender 라는 멤버변수가 있다면? -> human.gender = 'men' 이런 식으로 자신의 객체를 통해서도 접근이나 변조를 시도시 에러 발생        
        //      3. 상속(Inheritance)     : 특정 클래스(부모클래스, 조상클래스)의 변수와 메서드를 하위(자식,자손)클래스가 물려받는 것
        //                                  -> 후손 클래스는 조상의 변수와 메서드를 다 동일하게 이어받으니, 자신만의 고유 변수와 메서드만 신경쓰면 됨
        //      4. 다형성(Polymorphism)  : 인스턴스 생성시, 부모 클래스로 생성된 객체를 자식 클래스의 생성자를 써도 채울수 있는 특성
        //                                (= 타이어 교체시, 타이어의 규격이나 크기에서 전혀 문제가 없다면!
        //                                    -> 험지주행용, 경량형 등의 세부 특성이 있다쳐도 차가 주행하는데는 전혀 문제없는 것과 이치가 같다)

        //  - JS가 유사 OOP 언어인 이유 : 상속기능 완전 구현X -> 상속을 기반으로 한 다른 객체지향 특성인, 추상화(있는 척), 캡슐화(표기만 있는 척), 다형성 또한 구현X
        //   3. 상속(Inheritance) : 
        //      - 메서드와 속성만 개념적으로 선언이 불가능 
        //      - 추상화를 통한 클래스 계보의 컨셉만 잡기도 불가능
        //      - 해당 클래스 계보의 함수가 NOT NULL 개념으로 반드시 채워지게 강요하기도 불가능

        // 부모클레스 정의 (멤버는 4개 = 1 + 3)
        function Car(speed) {
            this.speed = speed;
        }

        // 멤버메서드 정의
        Car.prototype.speedUp = function(){
            this.speed += 10;
            document.write("일반차가 " + this.speed + "속도로 달린다. </br>");
        }
        
        Car.prototype.speedDown = function(){
            this.speed -= 10;
            document.write("일반차가 " + this.speed + "속도로 달린다. </br>");
        }

        Car.prototype.stop = function() {
            document.write("일반차가 멈춥니다!!! </br>")
        }

        //자식클래스 정의
        function SportCar(speed){
            this.speed = speed;
        }

        // 자식클래스명.prototype = new 부모클래명() : js에서의 상속문법(매우 중요!)

        // SportCar 클래스를 Car 클래스와 부모-자식 관계(상속)을 맺어주기
        //  -> (주의) 상속문법의 코딩위치 : 자식클래스의 멤버 메서드의 위, 부모클래스 멤버메서드가 끝난 뒤 바로 다음
        SportCar.prototype = new Car();

        // 자식의 멤버메서드 정의
        SportCar.prototype.run = function(){
            document.write("스포츠카가 " + this.speed + "속도로 달린다. </br>");
        }

        // 부모클래스를 기반으로 한 인스턴스 생성
        var car = new Car(50);
        car.speedUp();
        car.speedDown();
        car.stop();

        // 자식클래스를 기반으로 한 인스턴스 생성
        //   => 상속관계 정립ㅇ하기에, Car와 SportCar 클래스는 이 시점(js는 위 -> 아래로 코드 읽음)부터는 부모-자식 관계
        var sportCar1 = new SportCar(100);
        sportCar1.speedUp();     // if 상속 문법 X = 두 클래스는 관계 x -> 해당 메서드는 스포츠카 클래스에 없는 멤버메서드임을 명심하자
        sportCar1.run();

        var sportCar2 = new SportCar(150);
        sportCar2.speedUp();        // 상속 관계 ㅇ = 자식클래스도 사용 가능
        sportCar2.speedDown();      // 상속 관계 ㅇ = 자식클래스도 사용 가능
        sportCar2.stop();           // 상속 관계 ㅇ = 자식클래스도 사용 가능
        sportCar2.run();

    </script>
</head>
<body>

</body>
</html>
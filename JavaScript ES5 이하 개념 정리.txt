[JavaScript 기초 정리 (= ES5 이하 정리)]

 - JavaScript
    : 정적인 마크업 언어인 HTML을 웹 브라우저에서 동적으로 조작 및 변경을 목적으로 제작된 '약(weak)타입' + '동적타입'을 사용하는 '인터프리터 프로그래밍' 언어
       -> But 요즘에는 node.js라고 브라우저 이외의 JS를 실행가능하게 하는 런타임 환경이 등장하고, 이걸로 웹서버로 백엔드를 실행가능하게 하는 상황까지 왔음

          @ (중요) JS의 특징
             1. 인터프리터 언어(Interpreter Language)
             2. 자료형이 프로그램이 실행되는 '런타임' 시 결정되는 동적 타입(dynamic type) 언어
             3. 함수(fuction)는 '1급 객체((first-class object)'로서 또한 언어 내부에서 '값'으로 표현되고 전달될 수 있는 자료형 중 하나로 취급
                 -> 이같은 특성을 기반으로 다른 함수의 paramter로 사용하거나 return문에서 반환할 수 있는 '고차 함수(first-class object)'를 JS에서 사용 가능
             4. 기본적으로 싱글 쓰레드(single thread)만 사용
             5. {객체}간 상속 관계는 프로토타입(prototype) 기반 구조

          @ (참고) 프로그래밍 언어 분류 기준들
             1. '실행방식'에 따른 프로그래밍 언어 분류
                 1) 인터프리트 언어(Interpreter Language)
                     : 실시간으로 컴퓨터가 소스를 1줄씩 읽고 해석해서 실행하는 방식
                        -> (장점) : 실행을 시키는 과정 자체는 간단함
                           (단점) : 컴퓨터가 소스를 읽고 해석하니까 느리다
              
                 2) 컴파일 언어(Compiled Language)
                     : 사전에 소스를 파싱(parsing)하여 컴퓨터 잘 아는 저수준 언어로 변환한 뒤 한번에 실행
                        -> (장점) : 사람이 적은 코드를 분석/검사하여 컴파일하는 시간이 있으니, 용량이 클수록 실행까지 꽤 시간이 소요되며 메모리도 좀 필요함 
                           (단점) : 성능은 매우 빠르며, 코드에 문제가 있으면 컴파일이 이뤄지지 않아서 신뢰성 측면에서 도움이 됨 
            
             2. '데이터 타입'에 따른 프로그래밍 언어 분류
                 1) 정적 타입 언어(static type)
                     : 어떤 변수의 자료형이 '컴파일' 시에 결정되기에 확실하게 자료형을 지정해야 하는 언어 (= 일단 해당되는 언어는 컴파일 언어)
                        -> (장점)
                             a. 자료형이 확실하게 정해져있기에, 실행 이후 자료형으로 인한 돌발상황 대처와 추론이 쉬움
                             b. 컴파일 과정에서 미리 자료형이 정해져 있어, 성능 측면에서 유리함
                             c. 문제가 있으면, 컴파일 과정에서 고치기도 쉬움
         
                           (단점)
                             : 변수가 받을 자료형이 고정되는 셈이라, 유연성은 매우 떨어짐
              
                 2) 동적 타입 언어(dynamic type)
                     : 어떤 변수의 자료형이 프로그램이 실행되는 '런타임' 시 결정되는 언어
                        -> (장점) : 변수의 자료형이 동적으로 변화가 가능하기에, 유연하게 프로그램이 실행 가능
                           (단점) : 자료형이 런타임 시 유연하게 결정되기 때문에, 문제가 생기면 그 떄 가봐야 알 수 밖에 없음
         
             3. '암묵적인 데이터 타입 변환(Type Casting 또는 Type Conversion) 가능 여부'에 따른 프로그래밍 언어 분류
                 1) 강타입 언어(strong type)
                     : 다른 데이터 타입끼리의 변환이 엄격하게 금지되어 있는 프로그래밍 언어
                       (= 정말 극단적이면 연산자 및 함수의 parameter로서 사용되는 변수의 데이터 타입이 선언된것과 다르면 바로 에러를 발생시킴)
         
                 2) 약타입 언어(weak type)
                     : 다른 데이터 타입끼리의 변환이 가능하며, 심지어 암묵적으로 변환을 해주기도 하는 프로그래밍 언어
                       (= 정말 극단적이면 데이터 타입이 의미가 없다 느껴질 정도로 암묵적으로 변환을 해주는 범위가 넓을수도 있음)


자바스크립트는 html 조작하는 언어라고 했습니다.

근데 조작할 html이 위쪽에 있어야 조작이 잘 됩니다.

자바스크립트를 조작할 html 위에 작성하면 안됩니다.

왜냐면 컴퓨터가 html 파일을 읽을 때 위에서 부터 한줄한줄 읽는데

미리 html을 읽어놔야 조작이 가능하기 때문입니다.



 - JavaScript 문법들

  0. {window 객체} & {global 객체}
      : JS를 해석하는 프로그램의 런타임 환경 최상위 단계인 전역 스코프 영역 {}에 해당하는 {객체} = 전역변수, 전역함수, 전역객체가 멤버로서 소속 
          -> (중요!) index.html <script> 태그나 index.js와 같은 지정된 실행파일에 적힌 변수, 함수, {객체}는 전역 스코프{}에 실행된 것으로 보면 됨

              ex) 여기서 변수 x는 {window 객체}의 전역변수, 간지나는함수()라는 함수는 {window 객체}의 전역함수(메서드)
              
                  <script>
                    var x = 300;

                    function 간지나는함수(){
                      console.log()
                    }
                  </script>

              ex) 'window.변수명'은 전역변수, 'window.메서드명 = 무명함수'는 전역함수로 선언된 함수표현식(expression)으로 생각하면 편함

                  <script>
                    window.x = 300;

                    window.간지나는함수() = () => console.log();
                  </script>


       @ JS런타임 환경의 {전역 객체}들의 종류

          1) {window 객체}
               : JS를 실행 해석하는 주체가 '브라우저'인 경우의 최상위 단계에 존재하는 {전역 객체} 
                 (= 브라우저의 공통 기능 및 상태 정보에 대한 내용을 프로퍼티(= 전역변수), 메서드(= 전역함수)로 가지게 됨)
                      -> (중요) {JS객체}화 된 HTML 요소에 접근하고 조작하는 {DOM 객체} 또한 {window 객체}의 프로퍼티(= 전역 객체)며, alert('문자열'), comfirm('문자열'), prompt('문자열', 초기값) 또한  {window 객체}의 메서드(= 전역 함수)로 보면 됨

          2) {global 객체}
               : JS를 실행 해석하는 주체가 'Node JS'인 경우의 최상위 단계에 존재하는 {전역 객체}
                 (= 'Node JS'의 공통 기능 및 상태 정보에 대한 내용을 프로퍼티(= 전역변수), 메서드(= 전역함수)로 가지게 됨)


  1. 변수(variable) & 상수(constant)

     @ JS변수(variable) & 상수(constant)의 특성
        1) 동적 타입 언어(dynamic type)이기에 변수의 자료형에 해당하는 부분은 딱히 존재하지 않고 1~2개(var, let)로 통일 
            -> BUT'값'의 자료형은 존재함... 단지 2)로 인해 casting이 ㅈㄴ 유연해서 그렇지

        2) 엄청난 약타입 언어(very weak type)로서, 자동 형변환(casting)이 매우 유연하게 암묵적으로 이뤄지기까지함

     @ 스코프(scope) {} 개념
        : 변수의 영역(범위)을 설정해주는 일종의 경계이자 결계로 생각하면 되며, function, {객체}, 조건문, 반복문 등등을 사용할 때도 활용됨
           -> 이 결계는 '일종의 특수거울'과 같이 '안에서는 밖을 볼 수 있고, 밖에서는 안을 볼수 없음
               -> 이 결계를 기준으로 밖에서 선언된 변수는 최상위 global scope에 존재한다면 전역변수(global객체 or window객체의 프로퍼티에 해당), 안에서 선언된 변수는 지역변수의 논리가 통용
                         
     @ JS의 변수(variable)
        : 어떤 값을 할당 가능하며, 읽고/쓰기(= rw(read/write)) 가능한 녀석을 의미
           -> (정리된 내용)
                | var   | 변수  재선언O  재할당O  함수{}
                | let   | 변수  재선언X  재할당O  블록{}
                | const | 상수  재선언X  재할당X  블록{}

          1) (ES6 이전) var
              : ES6 이전에 쓰이던 '함수 스코프' 를 기반으로 하는 변수
                (= 함수 스코프{} 만을 기준으로 변수의 영역을 구분하고, 각 영역마다 존재하는 모든 var는 각 함수{}를 기준으로 최상단에 '호이스팅' 됨)

                # var 변수 만의 특징
                   1. 함수 스코프 {}가 영역의 기준
                   2. 동일 var변수 재선언 가능
                       -> 어차피 var 나이; 하나 호이스팅 하고, 나머지는 var를 때서 코드 실행 하여 최종값을 사용함

                          ex) 어차피 최상단 호이스팅 된 var나이;를 제외하면, 나머지는 호출의 형태가 됨
                          
                              var 나이 = 'xx';
                              var 나이 = null;

                   3. 함수 스코프 {}를 기준으로 var변수의 영역들을 판별하면, hoisting(호이스팅) 처리를 해줌
                      (= 오직 함수 스코프 {}만 기준으로 삼음)

                # hoisting(호이스팅)
                   : var나 function의 경우 아래에서 선언한 것들이 실행단계에서 최상단에 올라와서 일괄적으로 선언되는 현상
                      -> (중요) let도 호이스팅이 발생...
                           -> BUT! {블록스코프} 개념을 TDZ설정으로 선언 위치와 사용 위치 관계 정립하여 해결

                # function scope (함수 스코프)
                   : 변수의 영역을 정하는 스코프{}의 영역 개념이 function의 경우에만 통용되는 개념
                       -> 함수 스코프 기준으로 지역변수 개념? function의 {}내에서만 통용됨
                          (= var의 호이스팅이 의도치 않게 문제를 만드는 이유)

                          ex) '이름'이라는 var변수는 함수 스코프 {}안에 있어, 호이스팅이 되어도 함수 {}안에 존재

                              function 함수(){
                                var 이름 = 'Kim';
                                console.log(이름); // kim
                              }
                              
                              console.log(이름);   // 에러
                             
                          ex) '이름'이라는 var변수는 조건문 스코프 {}안에 있어, 이를 무시하고 상위 {}로 호이스팅 됨

                               if ( 1 == 1 ){
                                 let 이름 = 'Kim';
                                 console.log(이름); // kim
                               }
                               
                               console.log(이름);   // kim

                # (중요) var의 hoisting(호이스팅)의 특이성
                    : var의 경우 함수의 스코프{} 만을 변수 영역 구분의 기준으로 삼음
                      (= var의 호이스팅은 '조건문'이나 '반복문'의 스코프{}는 깡그리 무시해 버림 )
                          -> (중요) function 여부에 제한받지 않고, 어떤 스코프{}라도 영역 기준으로 인정해주는 변수 let이 등장한 이유

                             ex) var hoisting의 황당함 예시1
                                  -> age변수의 선언보다 사용 시점이 빠름에도 인식이 문제없음
                                     (사실 var age; 부분은 실행 시점에서 맨 위로 올라감)
                             
                                      age = 4;          // 변수 사용이
                                      var age;          // 선언 시점보다 빠르다... (이 녀석이 호이스팅 됨)
                                      console.log(age); // 4  <- 근데 문제없이 인식했다?! 

                             ex) var hoisting의 황당함 예시2
                                  -> age변수를 감싸는 {}이 존재함에도, 이를 무시하고 상위스코프로 호이스팅 해버림
                                     (여전히 var age; 부분은 실행 시점에서 {}를 무시하고 더 위로 올라감)

                                      {
                                        age = 4;          // 변수 사용이
                                        var age;          // 선언 시점보다 빠르다... (이 녀석이 호이스팅 됨)
                                      }

                                      console.log(age); // 4  <- 근데 문제없이 인식했다?! 

                             ex) var hoisting의 황당함 예시3
                                  -> 반복문의 index에 해당하는 변수 i는 모든 반복에 대해 반복문 스코프{}가 아닌 상위 스코프{}에 var i라는 동일한 변수를 참조함
                                     (사실 var i; 부분은 실행 시점에서 맨 위로 올라가고, setTimeout을 통해 1초 후 반복문들을 코드를 실행하는 시점에서는 이미 반복이 끝나 i = 5가 들어가 있음)

                                     for (var i = 0; i < 5; i++) {
                                         setTimeout(function() {
                                             console.log(i);          // 5 5 5 5 5 출력
                                         }, 1000);
                                     }

          2) (ES6 이후) let
               : ES6에 추가된 '블록 스코프'를 기반으로 하는 변수 
                 (= 함수 스코프 {}만을 영역의 기준으로 삼고 hoisting을 일삼던 상식을 벗아나는 var변수의 약점을 일반적 언어의 변수들의 원칙이 적용되는 방향으로 보완)

                # let 변수 만의 특징
                   1. var의 문제점을 보완하기 위해 탄생
                      (= var는 '함수 스코프'를 기반으로 하며, 이 부분으로 인해 hoisting 이슈가 발생)

                   2. 동일 var변수 재선언 불가능
                      (= 코드 크기가 늘어나는 상황에서, 변수만든거 또 만들고 그런 실수를 방지해줌)

                      ex) 이러면 닥치고 에러 발생함
                      
                          let 나이 = 'xx';
                          let 나이 = null;

                   3. for, if, function에 제한되지 않고, 어디에서라도 {}를 기준으로 한 블록 스코프 {}를 기준으로 변수들의 영역을 판별함
                      (= 모든 {}가 let의 범위를 따지는 영역의 기준)

                   4. TDZ개념을 도입하여, 변수를 선언하기 이전에 사용을 할수 없다는 원칙을 구현
                      (TDZ : Temperary Dead Zone의 약자로, 해당 스코프에서 변수 선언 위치 이전 영역을 의미함)
                        -> let의 경우 변수 선언 이전에 사용을 하게 되면, error를 호출

                # block scope (블록 스코프)
                   : {}로 직접 변수들이 통용되는 영역 구분을 위한 '결계'와 같은 영역을 설정


     @ JS의 상수(constant) const
        : 어떤 값을 일단 한번 할당히면, 오직 읽기(= r(read))만 가능한 녀석을 의미 
          (= const로 선언된 상수에는 '값'의 재할당이 불가능함)

         # 상수(constant)를 쓰는 이유(장점)
            : '값'의 재할당이 불가능하다는 부분에서 장점이 존재
               (= 혹시라도 절대로 수정되면 안 되서, 나중에 값을 변경하는 실수를 방지하고 싶을 때 상수를 사용하면 방지 가능)

               1) 보안적으로 유리
               2) 복수의 쓰레드를 사용하는 경우, 동시다발적 접근으로 인해 프로그램이 개판되는 상황을 방지 가능
               3) 사람의 실수 가능성을 원천적으로 줄일 수 있음

         # const의 약점
            : const에 할당된 게 {객체}인 경우, 그 {객체}의 프로퍼티의 값들은 모두 재할당을 통한 변경 가능 
              (= 상수 써봐야 {객체} 내부의 값까지 방어가 불가능하다 이 말임)
                  -> WHY? {객체}는 엄밀하게는 heap영역의 메모리 영역을 참조값(reference)로 가지고 있을 뿐이고, const가 재할당 못하게하는 대상은 그 참조값이지 그 참조값이 가르키는 위치의 데이터들이 아님
                      -> {Object 객체}의 freeze()라는 메서드를 통해, ()안에 프로퍼티와 값들을 담으면 {frozen 객체}라고 내부 프로퍼티 값들의 재할당이 불가능하게 만들수는 있음
                          -> BUT! {frozen 객체}라도 또 그 내부의 프로퍼티의 값이 {객체}에 해당된다면, 그 {객체} 내부의 프로퍼티까지 freeze해주진 않음...
                             (= 추후 TypeScript에서 이 부분 자료형 정의에 힘쓰는 이유) 

  2. 자료형(types)
     : JS에서 인식하는 어떤 '값'을 해석하는 방식의 종류를 의미

        @ primitive (원시형)
           : number, string, boolean, null, undefined, symbol 과 같은 단일 변수로 값이 직접 변수에 저장되고 복사되는 불변의 자료형
              -> (참고) 0, '', null, undefined, NaN, false는 JS에서는 자동 형변환(casting)을 통해 같은 값으로 인식

                 1) number
                     : integer(정수), decimal number(소수)던 상관없이 하나로 통일
                       (= 기본적으로 JS의 숫자 자료형은 int와 같이 정수에 해당하는 자료형이 없고, 64비트 부동소수점에 해당하는 JAVA에서는 double에 해당하는 자료형으로 통일됨)
                
                       # number 자료형의 범위/정밀도
                          - 범위   : ±(2^-1074) ~ ±(2^1023)
                          - 정밀도 : 최대 소수점 이하 17자리
 
                       # 정수 자료형이 없는 JS의 문제점
                          1) (중요) 정확도 문제
                              : 부동소수점 연산시 정확도 문제
                                (= 2진법으로 부동소수점을 표현시 그 특성상 오차가 발생 = 숫자 비교를 수행할 때의 부정확성이 존재)
                                    -> 해결하고 싶다면?
                                        :  반올림(.toFixed() 같은 메서드 or 수동으로 '대상 / 10 * 10')하거나 외부 라이브러리 사용
 
                                ex) console.log(0.1 + 0.2);
                                     -> 0.3이 아닌 0.30000000000000004 출력...
 
                                ex) itemsInCart가 30000000000000004이라 조건문의 코드가 실행되지 않음
                                
                                    let itemsInCart = 0.0;
                                    itemsInCart += 0.1;
                                    itemsInCart += 0.2;
                                    
                                    if (itemsInCart === 0.3) {
                                        console.log('Cart has 0.3 items'); 
                                    }
 
                          2) 데이터 일관성 문제
                              : 정수로 다뤄야 할 데이터에 소수를 끼얹어도 타언어들처럼 정수가 아니라고 에러를 뱉는 것을 할 수 없음
                                (= 정수를 다뤄야 할 때, 정수의 일관성을 유지할 수 없음)
 
                          3) 정수 연산시 성능 문제  
                              : 정수 자료형으로 정수를 계산하는 것에 비해, 정수연산도 쓸데없이 부동소수점으로 하니 연산의 성능 저하
 
                          4) 정수 표현 범위 제한 문제
                              :  부동소수점으로 읽는 방식의 특성상 안전하게 표현될 수 있는 정수의 최대 범위가 제한적
                                 (Number.MAX_SAFE_INTEGER ~ Number.MIN_SAFE_INTEGER 범위 밖의 정수는 정확하지 않을 수 있음)
 
                       # number의 메서드
                          : '숫자.메서드명(...parameter)' 형식으로 호출하며

                            ex) (1.4).toFixed(1)
 
                        # (중요) 'string'과 '+' 연산자
                          : JS는 동적 자료형과 극한의 약타입에 해당하는 언어의 특성 상, '산술 연산자'나 '논리 연산자' 관련 연산을 수행시 꼴리는데로 형변환(casting)을 시도해서 사람을 복창터지게 하는 특성이 있음
                             -> '+' 연산자의 경우 대상자 중 하나라도 '문자'가 들어가면, 나머지 대상도 자동으로 문자로 형변환해서 문자열 붙이기 연산을 수행해버림

                                ex) '+' 연산자를 쓸 때, JS런타임 환경은 엄격하게 지정한게 아니면 '문자열'로 형변환을 시도하려는 경향이 있다는거 참고

                                     1  +  1  =  2 
                                     1  + '1' = '11'
                                    '1' + '1' = '11'
                                    
                       # 특수한 number값 유형
                          : infinity (양의 무한), -infinity (음의 무한), NaN (Not A Number : 숫자가 아닌데, 숫자로 출력해야 하는경우 나오는 값)
                 
                       # (ES6 이후) bigInt 타입
                          : Java의 bigInt와 같이 기존 소수값 변수(자바의 경우 double)보다 더 큰 값을 표현가능한 변수타입

                 2) 'string'
                      : '문자'에 대한 자료형으로 '문자열'의 경우는 [배열]개념으로 조합되어 있기에, 원하는 위치의 문자를 찾는것이 가능

                       # 'string' 메서드
                          : string 자료형으로 입력된 '문자열'을 조사/탐색/변경 등을 수행할 때 유용한 기능을 제공

                       # (중요) 'string'과 '+' 연산자
                          : JS는 동적 자료형과 극한의 약타입에 해당하는 언어의 특성 상, '산술 연산자'나 '논리 연산자' 관련 연산을 수행시 꼴리는데로 형변환(casting)을 시도해서 사람을 복창터지게 하는 특성이 있음
                             -> '+' 연산자의 경우 대상자 중 하나라도 '문자'가 들어가면, 나머지 대상도 자동으로 문자로 형변환해서 문자열 붙이기(String concatenation) 연산을 수행해버림

                                ex) '+' 연산자를 쓸 때, JS런타임 환경은 엄격하게 지정한게 아니면 '문자열'로 형변환을 시도하려는 경향이 있다는거 참고

                                     1  +  1  =  2 
                                     1  + '1' = '11'
                                    '1' + '1' = '11'

                       # (참고) ''로 선언한 문자열에 특수기호를 넣고 싶다면?
                           : \n (줄바꾸기), \' (쉼표) 등 \를 사용해서 알아보면 됨                      

                       # parseFloat('123'), parseInt('123') 
                           : '문자'로 된 숫자 -> '숫자' 변경해주는 함수 (각각 부동소수점, 정수로 변환)

                       # (ES6 이후) `template literals`
                           : `(백틱) 부호를 이용하여, 문자열을 입력 가능하게 하는 또 다른 방법으로 ''와 다른 이점이 존재

                              a. ${JS변수명}과 같은 방식으로 JS변수를 문자열에 쉽게 가져올 수도 있도록 템플릿(template)적 요소와 기능을 추가함
                 
                                 ex) helloBob를 출력해보면, 'hi brendan'으로 출력됨
                                 
                                     const brendan = 'brendan';
                                     const helloBob = `hi ${brendan}!`;

                              b. ''와 다르게 줄바꿈이 정말 쉬움
                                  -> \n (줄바꾸기) 를 쓰지 않고, `` 안에서 그냥 enter키 눌러서 코드상의 줄바꿈을 해도 줄바꿈으로 인식함
                 
                                     ex) 문자라는 변수의 문자열은 줄바꿈을 이미 인지 중
                                     
                                         var 문자 = `안녕
                                         하세요`;

                              c. ${변수명}과 줄바꿈 편의성을 이용하여, <HTML> 내용을 작성하고 인지시키는 것도 참 쉬워짐
                                  -> ''를 사용하면... '+'와 '\n'과 "'"와 같은 끔직한 특수기호와 함께 속성값까지 입력하는 참극이 시작됨...
                 
                                     ex) 이런식으로 특수문자와 +연산자 뻘짓 없이 <HTML> 내용을 입력가능
                                     
                                         var 문자 = `<div>
                                                       <div class='${속성명}'>
                                                         ${변수명}
                                                       </div>
                                                     </div>`;

                        # (ES6 이후) Tagged Literals
                            : 함수를 실행시키는 또 다른 문법에 해당하는 방법으로 `(백틱)으로 감싸진 문자열(string)인 `template literals`를 해체하여, 문자 중간 중간에 있는 단어 순서를 바꾸거나 변수를 제거하거나 하는 기능
                               -> (참고) 정확히는 함수를 호출하는 방식이 Tagged Literals 방식에 해당하면, Tagged Literals 방식으로 실행해주는듯함

                                   a. Tagged Literals 함수 선언법
                                       : TL함수명(1번째 parameter명, ... parameters){
                                            TL함수 내용부
                                         }

                                   b. Tagged Literals 함수 선언시 parameter들이 의미하는 것
                                       : parameter들이 각각 `원본 문자열`을 분리한 결과를 가지고 있음을 가정하기에 `문자열`을 재조합하거나 분석가능

                                         - 1번째 parameter
                                             : `(백틱)으로 감싸진 문자열(string)인 `template literals`에서 순수 문자열들만 선별해 [배열]로 저장한 변수에 해당
                                                 -> Tagged Literals 함수가 호출시 `원본 문자열`을 분해를 해줄 것을 전제로 함 
  
                                                    ex) 다음을 Tagged Literals 함수가 해체해서 1번째 paramter로 담는 [배열] = [`안녕하세요`, `나는` , `입니다`];

                                                        var 직업 = `축구선수`;
                                                        var 이름 = `손흥민`;

                                                        function 해체분석기(문자배열, 변수1, 변수2) { ~~ }; 

                                                        해체분석기 `안녕하세요 나는 ${직업} ${이름} 입니다` 
  
                                         - 그 이후 모든 parameter들
                                             : `template literals`에서 ${변수명} 방식으로 들어간 (n-1)번째 변수에 해당하는 값들을 각각 저장한 변수에 해당
                                                 -> `template literals` 내부의 변수가 n개다 그러면, 그만큼 파라미터를 뒤에 더 추가하면 됨

                                                    ex) 다음을 Tagged Literals 함수가 해체해서 2번째 paramter로 담는 내용 = `손흥민`

                                                        var 직업 = `축구선수`;
                                                        var 이름 = `손흥민`;

                                                        function 해체분석기(문자배열, 변수1, 변수2) { ~~ }; 

                                                        해체분석기 `안녕하세요 나는 ${직업} ${이름} 입니다` 
                                                   
                                   c. Tagged Literals 함수 호출법
                                       : TL함수명 `template literals 방식의 문자열(${변수명}까지 사용 포함)`
                                           -> 이렇게 호출하면, a에서 선언한데로 Tagged Literals 함수가 실행됨

                                              ex) 해체분석기 호출의 결과는 `나는축구선수손흥민`

                                                   var 직업 = `축구선수`;
                                                   var 이름 = `손흥민`;

                                                   function 해체분석기(문자배열, ...변수들) { 
                                                     console.log(문자들[1] + 변수들); 
                                                   }; 

                                                   해체분석기 `안녕하세요 나는 ${직업} ${이름} 입니다` 

                 3) boolean
                     : 참/거짓... 
                 
                 4) null
                     : null이라고 사용자가 선언한 경우에 할당되는 자료형 
                       (= null은 사용자가 null이라고 의도적으로 값이 없음을 명시)
                 
                 5) undefined
                     : 값이 그냥 비었을경우 
                       (= undefined는 사용자는 개입한거 없이, 의도하지 않았는데 값이 없을 때 등장)
                 
                 6) (ES6 이후) Symbol
                     : 어떤 { Object } 자료형의 값에 공개되지 않은 비밀스런 key값(= 프로퍼티)를 부여할 필요가 있을 때 사용하는 자료형
                       (= 정확히는 Symbol 타입의 값 자체가 어떤 {객체}의 비밀스런 key값(= 프로퍼티)에만 해당하는 값에 포함됨)
                           -> for문이나 for in 같은 방법으로 해당 {객체}의 프로퍼티 순회시 이를 보여주지 않는 개념에 가까움
                              (= 캡슐화와 접근제어자 private를 썼을 때, 해당 프로퍼티에 외부 {객체}에서 접근이 불가능 한 것과는 전혀 다름)
             
                       # 어떤 {객체}에 Symbol에 해당하는 for문에 걸리지 않는 비밀스런 key값을 만들고 사용하는 방법

                         A. var, let 변수명 = Symbol('주석내용')
                             : 생성된 Symbol값을 변수에 할당받아서, 이를 어떤 {객체}의 비밀스런 key값(= 프로퍼티)으로서도 바로 할당될 수 있게 준비함

                         B. Symbol값이 할당된 '변수명'을 특정 {객체}의 '프러퍼티'에 접근하듯 사용한 뒤, value에 해당하는 값을 할당

                            a. 생선된 {객체}의 프로퍼티로서, '객체명[변수명]'으로 접근


                            b. {객체}를 생성할 때, Symbol값의 value값도 같이 입력
                                 -> {객체} 정의할 때, Symbol값을 프로퍼티로서 같이 입력하고 싶다면, { ... , [변수명] : value값} 이렇게 입력하자

                                    ex) var height = Symbol('내 키임');
                                        var person = { name : 'Kim', [height] : 160 };

                       # Symbol 타입값 관련 함수
                          : 새로운 Symbol값을 생성하면, 해당 Symbol값은 어떤 {객체}의 비밀스런 key값(= 프로퍼티)으로서도 바로 할당될 수 있음

                            a. Symbol('주석내용')
                                : Symbol 타입에 해당하는 값을 생성하는 생성자에 해당.. 
                                   -> BUT! '주석내용'과 관계없이, 각 Symbol() 생성자를 사용해서 생성된 Symbol값은 별개임
                                      (= class생성자를 사용해서 만든 {객체}와 유사함)
                          
                            b. Symbol.for('주석내용')
                                : 전역 Symbol 타입에 해당하는 값을 생성하는 생성자에 해당.. 
                                   -> BUT! '주석내용'이 같은 Symbol값은 같은 값으로 인정
                 
                       # Symbol 자료형의 주요 특징
                          a. 고유성
                              : 같은 '주석내용'이라도, 각각 Symbol() 생성자를 통해 생성한 Symbol 타입은 다른 Symbol로 인정
                                  -> obj[Symbol('mySymbol')] 식으로 Symbol() 생성자를 index처럼 직접 쓰지 못하고, 변수에 할당해서 쓰는 이유가 여기에 있음
                 
                                     ex) Symbol('주석내용')을 각각 사용해서 생성된 경우, '주석내용'이랑 상관없이 다른 Symbol값(= 다른 프로퍼티명)으로 인정됨
                                         (= class생성자를 사용해서 만든 {객체}와 유사함)
                 
                                         const symbol1 = Symbol('id');
                                         const symbol2 = Symbol('id');
                                         console.log(symbol1 === symbol2);    // false에 해당
                 
                          b. (중요) 전역 Symbol값의 존재
                              : Symbol.for('주석내용') 메서드를 통해 전역 Symbol을 만들 경우, '주석 내용'이 같을 경우 같은 Symbol값으로 인정됨
                 
                                ex) Symbol.for()를 통해 만들어진, 2개의 Symbol 타입 값은 같은 주석인 '설명1'을 가졌기에, 같은 Symbol값으로 인정됨
                 
                                    var a = Symbol.for('설명1');
                                    var b = Symbol.for('설명1');
                                    console.log(a === b);                    // true에 해당
                 
                          c. 공개되지 않는 프로퍼티(= 접근자체는 가능)
                              : for문으로 순회시 안 보일 뿐이지, '객체명[심볼명]'으로 접근이 가능하며, '객체명'으로도 볼수 있음
                                 -> 공개되지 않은 비밀스런 key값(= 프로퍼티)이기 때문
                 
                          d. 기본적으로 내장된 Symbol인 'Symbol.내장Symbol명'
                             (= {Object 객체}의 프로퍼티와 유사한 용도이나... 이미 존재하는 {Object 객체}를 손댈수는 없으니.. ES6부터 추가된 기능에 대해 Symbol로 이를 구현한 걸로 추측)
                              : JS에는 기본적으로 정의된 기본적인 Symbol 타입이 존재하며, 'Symbol.내장Symbol명' 형식으로 호출
                 
                                ex) Symbol.iterator
                                     : ES6에서 {객체}, [배열] 등의 iterable한 특성이 있는 {객체}의 기본 iterator를 정의하어, for of 반복문을 사용할 수 있도록 함
                                     
                                       ex) arr[Symbol.iterator]()로 arr라는 변수에 할당된 이터러블 객체에 해당하는 [배열]의 내장 Symbol로 정의된 iterator에 관련된 기능을 쓸 수 있게 함
                                       
                                           let arr = [1, 2, 3];
                                           let iterator = arr[Symbol.iterator]();
                                           console.log(iterator.next());          // { value: 1, done: false }

        @ 참조 자료형(reference type)
            : [배열], {객체}와 같이 여러 종류의 복수의 값들이 저장된 힙(heap)영역의 메모리 주소를 참조값(reference)으로 저장하여, 이를 통해 자신과 연관된 데이터에 접근하는 형태의 자료형
              (= 참조 자료형 자체를 직접 조사해봐야 '힙(heap)영역의 메모리 주소'에 해당하는 값 밖에는 존재하지 않음... 포인터가 열려있는 보다 저수준의 C계열 언어는 이를 조작 가능)
                  -> 메모리 주소를 참조값(reference)으로 저장하기에 원시형 같은 값이 대입으로 복사해봐야 주소값만 복사되는 '얕은 복사(shallow copy)'가 일어나 제대로 된 복사가 이뤄지지 않음
                     (= 제대로 된 복사를 위해서는.. 참조하는 주소에 위치한 heap영역의 값들을 하나하나까서 목표하는 heap영역에 위치한 컨테이너 요소들에 대입해주는 '깊은 복사(deep copy)')

             # 참조(reference)값에 대한 이해

               1) 참조 자료형(reference type) 그 자체의 값 = 복수의 값들이 저장된 힙(heap)영역의 메모리 주소에 해당
                  (= 단순 =연산자를 통한 대입으로는 그저 해당 변수에 저장된 참조값인 힙(heap)영역의 메모리 주소만 복사하고, 같은 위치의 heap영역의 값들을 볼 수 있을 뿐임)

               2) (중요!) 두 변수가 둘 다 참조 자료형(reference type) 형태의 내용을 저장한다 쳤을 때, 그 저장된 내용이 같아보인다고 '=='로 표현되는 같음은 성립하지 않음
                   -> 참조 자료형(reference type)의 값이 같다는 건 참조하는 힙(heap)영역의 메모리 주소가 같음을 의미함

                      ex) 이름2는 이름1의 참조값인 {객체}가 저장된 메모리주소값을 복사해 온 것이기에... 
                           -> 이름1이 참조하는 주소의 {객체}의 프로퍼티값이 바뀌면, 이름2도 마찬가지로 같은것을 봄
                      
                              var 이름1 = { name : '김' };
                              var 이름2 = 이름1;
                              이름1.name = '박';
                              console.log(이름1);    <- { name : '박' };
                              console.log(이름2);    <- { name : '박' };

                      ex) 이름1이 참조하는 위치의 {객체}의 내용이나 이름2가 참조하는 위치의 {객체}의 내용이나 같기에 둘은 같은 {객체}를 참조하는 것처럼 보이나..
                           -> 그 둘은 각각 다른 메모리 위치에 존재하는 {객체}를 참조함
                              (= 이름1 != 이름2) 
                      
                              var 이름1 = { name : '김' };
                              var 이름2 = { name : '김' };
                              console.log(이름1 == 이름2);     <- false가 출력... { name : '김' }이라는 {객체}들의 내용은 유사하나, 결국 도플갱어와 같다고 봐야 함

                      ex) 이름1이 저장한 {객체}의 heap영역 메모리 주소값이 obj라는 변수에 대입되지만, 결국 { name : 'park' }이라는 새롭게 생성된 객체의 heap영역 메모리 주소값을 저장함
                          (= 변경이라는 함수의 호출로 인해 이름1이라는 변수가 저장한 {객체}의 참조값은 오염되지 않음)

                          var 이름1 = { name : '김' };
                          
                          function 변경(obj){
                            obj = { name : 'park' };
                          }

                          console.log(이름1);     <- { name : '김' }; 그대로 출력
                          
                          변경(이름1);
                            -> 해당 함수는 parameter변수 obj에 arguments인 이름1이라는 {객체}의 참조값을 가진 변수가 대입된다는 로직으로 동작한다고 판단하면 이해가 빠를 것..
                               (= 함수 호출시 parameter변수와 argument가 되입되는 과정까지 이해를 해야 함)
                            
                               function 변경(obj = 이름1){
                                 obj = 이름1;
                                 obj = { name : 'park' };
                               }

                      ex) 이름1이 저장한 {객체}의 heap영역 메모리 주소값이 obj라는 변수에 대입되고, 결국 그 참조값의 heap영역에 저장된 프로퍼티의 값을 직접 변경하니, 이름1의 프로퍼티의 값이 변함

                          var 이름1 = { name : '김' };
                          
                          function 변경(obj){
                            obj.name  = 'park';
                          }

                          console.log(이름1);     <- { name : 'park' }; 그대로 출력
                          
                          변경(이름1);
                            -> 해당 함수는 parameter변수 obj에 arguments인 이름1이라는 {객체}의 참조값을 가진 변수가 대입된다는 로직으로 동작한다고 판단하면 이해가 빠를 것..
                            
                               function 변경(obj = 이름1){
                                 obj = 이름1;
                                 obj.name  = 'park';
                               }
                         
             # 참조 자료형(reference type) 종류

               1) {object(객체)}
                    : 연관된 변수(= 프로퍼티)나 그 변수들을 조작하는 함수(= 메서드)들을 모아놓은 타입을 구현한 key와 value의 집합체인 데이터 구조에 해당하는 JS의 자료형 (!= Json) 
                       -> (참고) 
                            a. JS에서는 함수도 '1급 객체(first-Class Citizen)'에 속하는 {객체}로서, 함수를 변수, return문, 함수의 인자로 할당 가능
                            b. {Map 객체}와 마찬가지로 {object 객체}의 key값(key명) 또한 메모리주소값으로 사용되는 hash값으로 변환되는 seed값임 
 
                     - {객체}를 기반으로 만들어진 JS의 참조 자료형
                         : 까놓고 말해서, 그냥 {객체}는 JS라는 언어 성립에 있어 가장 근간을 이루는 참조 자료형이라고 보면 됨
 
                           a. 배열(Array)
                               : 숫자 인덱스를 사용하여 데이터의 순서화된 집합
 
                           b. 셋(Set)
                               : 값의 집합으로, 중복된 값이 허용 X       
                                 (= 중복X인 유사 [배열])
 
                           c. 맵(Map)
                               : 키-값 쌍의 집합으로, 키의 순서가 유지되고 중복 허용X
                                 (= key영역 중복X인 유사 마이너 {객체})
                           
                           f. 함수(Function)
                               : 코드의 재사용을 가능하게 하기 위한 블록을 가진 모듈 
                                  -> JS에서는 함수도 {객체}이므로 자신만의 프로퍼티(자신이 선언된 {}정보 등등) 있음 + '1급 객체(first class citizen)'로서 '값'으로서 취급될 수 있음
                           
                           d. 날짜(Date)
                               : 날짜와 시간을 나타냄
                           
                           e. 정규 표현식(RegExp)
                               : 문자열 패턴을 나타내며, 정규식을 사용할 수 있게 됨
 
               2) [Array(배열)]
                    : 숫자 index를 사용하여 메모리 공간을 할당하여, 여러개의 데이터들을 순서화 된 집합으로 나타낸 자료형
 
                     - JS에서 [배열]과 연관된 특수사항  
 
                        a. [배열]도 JS에서는 {객체} 기반
                           (= '배열명[index]'로 요소에 접근하는거 자체가 '객체명[프로퍼티명]'에서 나옴)
                        
                        b. a에서 말하듯 {객체}라서 자신의 프로퍼티와 메서드가 존재

                        c. [배열]은 iterable함
 
                        d. 동적 약타입 언어인 JS이기에 타언어와 달리 JS의 [배열]은 특정 자료형에 종속되는 값만 가지지 않음
 
                        e. heap영역에 [배열]의 요소들이 저장되는 구조는 ArrayList와 같은 주소가 물리적으로 연속되지 않고, LinkedList처럼 메모리주소값으로 연결된 구조
                           (= 알고리즘 짜면 많이 불리해짐)
                    
                     - [배열]의 메서드
                        a. from(참조 자료형)

                        b. foreach(무명콜백함수(set요소, index))

               3) {Set(셋)}
                    : 값이 집합된 {객체}로, 내부 요소로서 중복된 값이 허용 X  
                        -> (용도) 보통 [배열]의 중복 제거를 위해 사용됨     

                     - JS에서 {set 객체}과 연관된 특수사항  
 
                        a. 셋(Set)은 내부요소 '값'의 중복을 허용X 하는 {객체}에 해당
                            -> '값'으로는 자료형을 막론하고 뭐든 들어올 수 있음

                                ex) var 출석부2 = new Set([ 'john' , 'tom', 'andy', 'tom' ]);

                                    console.log(출석부2);  
                                      -> [ 'john' , 'tom', 'andy', 'tom' ] -> {'john' , 'tom', 'andy'}로 중복제거한 {객체} 형식으로 출력

                        b. ES6 이후 등장한 class 기반 {객체}
                           (= 생성자(constructor)가 존재하며, 메서드(method)가 존재) 

                        c. iterable 함 (= 반복문 순회 가능)

                        d. 생성자를 통해 {set객체}를 생성할 때, parameter변수에 argument로 [배열]을 넣으면, 그 배열을 {set 객체} 형식으로 바꿔줌

                        e. {set객체} -> [배열]하는 것은 스프레드 연산자(spread operator) '...'를 쓰면 쉬움

                           ex) var 출석부 = [ 'john' , 'tom', 'andy', 'tom' ];

                               var 출석부2 = new Set(출석부);   // Array를 Set으로 바꾸기
                               출석부 = [...출석부2]            // Set을 Array로 바꾸기1
                               출석부 = Array.from(출석부2);    // Set을 Array로 바꾸기2
                    
                     - {set 객체}의 생성자 함수와 메서드

                        A. {set객체} 생성자 함수 
                            : 생성자를 통해 {set객체}를 생성할 때, new Set([배열]) 형태의 parameter변수에 argument로 [배열]을 넣으면, 그 배열을 {set 객체} 형식으로 바꿔줌
                              (= argument인 [배열]을 먼저 들어온 순서대로 적용하고, 뒤에 중복으로 들어온 요소는 다 쳐냄)

                               ex) var 출석부2 = new Set([ 'john' , 'tom', 'andy', 'tom' ]);

                                   console.log(출석부2);  
                                     -> {'john' , 'tom', 'andy'}로 중복제거한 {객체} 형식으로 출력

                        B. {set객체}의 멤버

                            - 프로퍼티
                               a. size
                                   : 해당 {set객체}의 요소가 몇 개인지 저장
                            
                            - 메서드
                               a. add('요소값')
                                   : 해당 '요소값'에 해당하는 값을 해당 {set 객체}에 추가할 수 있는지 검토하고, 중복이 아니라면 내부 요소로 추가한 뒤 {set 객체} 반환
                                     (= 메서드 체이닝이 쌉가능)

                                     ex) set.add(1).add("A").add(true);    // {1, 'A', true}

                               b. clear()
                                   : 해당 {set 객체}의 요소들을 전부 지움
                               
                               c. delete('요소값')
                                   : 해당 '요소값'에 해당하는 값을 해당 {set 객체}에 삭제할 수 있는지 검토하고, 삭제했는지 여부를 boolean으로 반환

                                     ex) set.delete(1); // true
                                         set.delete(2); // false
                              
                               d. has('요소값')
                                   : 해당 '요소값'에 해당하는 값이 현재 해당 {set 객체}에 존재하는지 검토

                                     ex) var 출석부 = [ 'john' , 'tom', 'andy', 'tom' ];
                                         var 출석부2 = new Set(출석부);   //Array를 Set으로 바꾸기
 
                                         출석부2.add('sally');     // { 'john' , 'tom', 'andy', 'sally'}
                                         출석부2.add('tom');       // { 'john' , 'andy', 'sally'}                                        
                                         출석부2.has('tom');       // false
                                         출석부2.size;             // 3
 
                                         출석부 = [...출석부2]      //Set을 Array로 바꾸기

                               e. forEach(무명콜백함수(개별요소parameter, 인덱스parameter){ 내용부 });
                                   : 해당 {set 객체}의 모든 내부 요소를 무명콜백함수 내용부에 해당하는 내용으로 순회반복
                                      -> parameter 변수는 전부 필수는 아니나... 목적을 생각하면 1번째는 적어도 넣어야겠지?

                                         ex) 0, 4, 4를 차례대로 순회
                                         
                                             const numSet = new Set([4, 4, 2]);
                                             numSet.forEach((num, index) => console.log(num * index));

               4) {Map(맵)}
                    : 순서가 유지되고 중복 허용X인 key - value 쌍의 집합 형태의 {객체}
                       -> JS의 {Map 객체}는 key값을 hash table로 구성해 사용하는 식의 Hash Map으로 구현

                      - {Map 객체} 개별 key값이 의미하는 것
                          : 개별 key값(= seed값) -> hash변환 알고리즘 -> hash값 = 메모리주소값 그 자체!
                            (= key값이 중복을 허용하지 않는 이유 = value값이 실제로 저장될 고유한 메모리주소값이기 떄문)
                                -> (중요) key값을 통해 hash값인 메모리주소 그 자체를 얻을 수 있는지라 '값'에 해당하는 value에 대한 빠른 조회, 추가, 삭제 등이 가능

                      - JS에서 {Map 객체}과 연관된 특수사항  
  
                         a. {Map 객체}의 key는 '참조(reference)값'이고 value는 'heap영역의 참조주소값에 실제로 저장된 값'으로서 연결하여, 관계를 짓고 구분할 수 있도록, 설계된 자료형을 구현한 {객체}에 해당
                              -> {맵(Map) 객체}를 출력하면 { key =>  value, ... , } 형식의 객체로 출력
                                   : '=>' 가 보이는 이유는 key - value의 관계가 '참조 자료형(reference type)'의 '참조값 - 저장내용'과 같은 관계에 있기 때문
 
                                      ex) var person = new Map();
                                          person.set('name', 'Kim');
                                          person.set('age', 20);
      
                                          console.log(person);  
                                            -> {"name" => "kim" , "age" => 20} 형식의 {객체}로 출력

                         b. key, value 둘 다 자료형을 막론하고 뭐든 들어올 수 있음
                             -> key의 경우는 메모리주소값으로 변환되는 고유성이 있기에 {set 객체}처럼 중복되지 않기만 하면 됨
                                 -> (주의!) {객체}나 함수도 key값으로 넣기가 가능하지만, get()이나 has()의 parameter값에 {객체} 자체를 넣거나, 무명함수를 key값으로 찾는다치면 참조값 문제로 false가 뜲

                                ex) 모든 자료형이 key값으로 들어올 수 있지만, 참조 자료형 자체는 변수나 함수명으로 저장하지 않는 이상 여기서도 ==의 개념을 조심스럽게 접근해야함
                                
                                    var person = new Map();

                                    person.set([1,2,3], 'Kim');
                                    person.set('age', 20);
                                    person.set({}, 'value associated with an object');
                                    person.set(function() {}, 'value associated with a function');

                                    console.log(myMap.get('age'));            // 20 출력
                                    console.log(myMap.get({}));               // undefined (key값의 {}와는 다른 객체이기 때문에)
                                    console.log(myMap.get(function() {}));    // undefined (key값의 무명함수와는 다른 함수이기 때문에)
 
                         c. ES6 이후 등장한 class 기반 {객체}
                            (= 생성자(constructor)가 존재하며, 메서드(method)가 존재) 
 
                         d. iterable 함 (= 반복문 순회 가능)
 
                         f. 생성자를 통해 {Map 객체}를 생성할 때, parameter변수에 argument로 원하는 key - value 쌍을 [key, value] 형식으로 반복해서 넣으면, 그 배열을 {Map 객체}의 내부 요소로 넣어줌
 
                            ex) var person = new Map([
                                   ['age', 20],
                                   ['name', 'Kim']
                                ]); 
                     
                      - {Map 객체}의 생성자 함수와 메서드
 
                         A. {Map 객체} 생성자 함수 
                             : 생성자를 통해 {Map 객체}를 생성할 때, new Map() 형태나 new Map() parameter변수에 argument로 원하는 key - value 쌍을 [key, value] 형식으로 반복해서 넣으면, 그 배열을 {Map 객체}의 내부 요소로 넣어줌
 
                               ex) 빈 {Map 객체} 생성
                                   var person = new Map();

                               ex) 내용이 찬 {Map 객체} 생성
                               
                                   var person = new Map([
                                      ['age', 20],
                                      ['name', 'Kim']
                                   ]); 

                         B. {Map 객체}의 멤버
 
                             - 프로퍼티
                                a. size
                                    : 해당 {Map 객체}의 요소가 몇 개인지 저장
                             
                             - 메서드
                                a. set('key값', 'value값')
                                    : 'key값'의 hash값인 메모리주소에 'value값'을 저장하고, 해당 {Map 객체}의 key-value 형식으로 저장
 
                                      ex) var person = new Map();
                                          person.set('age', 20);

                                          console.log(person);  
                                            -> {"age" => 20} 형식의 {객체}로 출력
 
                                b. get('key값')
                                    : 해당 {Map 객체}에서 'key값'에 해당하는 위치에 저장된 'value값'을 꺼내서 반환

                                      ex) var person = new Map();
                                          person.set('age', 20);

                                          console.log(person.get('age'));  
                                            -> 20 반환     

                                c. delete('key값')
                                    : 해당 'key값'에 해당하는 값을 해당 {Map 객체}에 삭제할 수 있는지 검토하고, 삭제했는지 여부를 boolean으로 반환
 
                                      ex) map.delete(1); // true
                                          map.delete(2); // false
                               
                                d. has('key값')
                                    : 해당 'key값'에 해당하는 값이 현재 해당 {Map 객체}에 존재하는지 검토
 
                                      ex) var person = new Map();
                                          person.set('age', 20);

                                          console.log(person.has('age'));  
                                            -> true 반환     

                                e. clear()
                                   : 해당 {Map 객체}의 내부 요소들을 전부 지움

                      - {Map 객체} vs {object 객체}
                          : {object 객체}에서 'key값'을 입력 할 떄 제약이 많음 = {Map 객체}를 쓰는게 더 부담이 없음
                             -> {객체}의 크기가 {object 객체}가 더 큼 = 자유도와 유연성, 단순함 측면에서 {Map 객체}가 더 유리함
                             
                                a. {object 객체}는 개발자가 'key값'을 입력 시, 기본 내장 프로퍼티명과 같으면 충돌 가능성이 존재함
                                     <-> {Map 객체}는 이런 내장 프로퍼티가 없기에 key값 쓰는데 부담이 없음
                                 
                                         ex) hasOwnProperty, toString같은 key값은 {object 객체}의 key값으로 쓸 수 없음
                                
                                b. {object 객체}는 개발자가 'key값'을 입력 시, '문자열' 또는 심볼(Symbol)이외 다른 자료형은 전부 '문자열'로 변환
                                     <-> {Map 객체}는 그냥 JS의 모든 자료형을 'key값'으로 입력 가능

             # (중요) 해시(Hash)
                : 임의 크기의 입력 데이터를 seed값으로 하여 어떤 고정된 크기의 출력 데이터(= 해시값(Hash Value))로 변경하는 과정(= 이 과정을 해시함수(Hash function)가 함)에 대한 개념
                  (= 해시함수(seed){ return 해시값 }과 같은 느낌)
                  
                  - 해시와 관련된 개념들
                     a. 해시함수(Hash function)
                         : seed값을 고정된 크기를 가지는 해시값(hash value)으로 변환해 주는 역할을 하는 함수
                            -> parmeter값에 들어가는 argument에 해당하는 원본인 seed값은 어떤 형태의 자료형도 상관없음

                     b. 해시값(Hash value)
                        : 해시함수(seed값)이 호출된 고정된 크기를 가지는 return값으로 보통 숫자나 '문자열'로 변환
                           -> 해시값은 주로 [배열] 형태의 해시 테이블(hash table)의 인덱스(index)로서 사용
                              (= 해시테이블[해시값] = value값에 해당)

                     d. 충돌(colution) = 해시값 중복
                         : 같은 해시값(hash value)을 가지는 서로 다른 키가 존재하는 경우를 지칭
                            -> 이렇게 되면, index의 의미가 조금씩 사라지기에 이를 해결할 필요가 존재
                                -> (방안1) 체이닝
                                     : 같은 해쉬값(index)를 가지는 여러 개의 데이터를 연결 리스트(linked list)로 연결

                                       ex) hashTable[fruit의 해쉬값] = [["fruit", "apple"], ["fruit", "apricot"]];
                                            -> 문제가 되는 "fruit"를 ket값으로 가지는 key-value 쌍들을 연결 리스트(linked list)로 연결해서 따로 관리

                                -> (방안2) 오픈 어드레싱
                                     : 충돌이 발생하면, 문제되는 데이터를 다른 빈 인덱스를 찾아서 저장

                     d. 해시 테이블(Hash table)
                        : 'key값'을 seed로 해시함수 돌린 해시값(hash value)를 index 삼아 그 안에 key-value 쌍을 내부요소로 저장하는 [배열] 형식의 자료구조 
                           -> 쉽게 말해, key값 -> hash값 -> index로 변환하여 key-value 쌍에 해당하는 데이터들의 순서를 정렬하여 배치한 [배열]로 보면 됨

                  - 해시 테이블(hash table)의 성능
                     : 해쉬값의 중복D이 많을 수록 O(1) ~ O(n)으로 수렴

                        a. 해쉬값의 중복X(= 충돌X)의 경우 
                            : key값이 중복되지 않아 index를 곧장 찾으면 됨 = 데이터 검색, 삽입, 삭제 작업의 평균적 시간 복잡도 = O(1)
                              (= 데이터의 크기에 상관없이 거의 일정한 시간만 소요)
                                  -> (중요!) {Map 객체}와 {object 객체}의 key값이 중복을 허용하지 않는 이유

                        b. 모든 해쉬값의 중복되는 경우 
                            : 모든 key값이 같아 index를 찾아봐야 의미X, 데이터의 크기만큼 순회해야 함 = 데이터 검색, 삽입, 삭제 작업의 평균적 시간 복잡도 = O(N)
                              (= 데이터의 크기와 검색 속도가 비례함 = 사실상 list 자료구조처럼 작동함)
                                  -> {Map 객체}와 {object 객체}의 key값이 중복을 허용하지 않는 이유

                  - 해시 테이블(casg table) 사용 예시
                  
                    a. 데이터베이스: 
                      : 키-값 쌍으로 이루어진 데이터를 빠르게 검색하고 저장하기 위해 해시 테이블이 사용
                    
                    b. 캐싱
                        : 자주 조회되는 데이터를 캐싱하기 위해 사용
                          (= 해시 테이블을 사용하면, 키를 통해 매우 빠르게 데이터를 검색 가능)
                    
                    c. {Set 객체], {Map 객체}, {object 객체} 구현
                         : 값의 중복을 허용하지 않는 집합(Set)을 구현하는 데 사용
                            -> 해시 테이블을 사용하면, 요소의 존재 여부를 매우 빠르게 확인 가능

             # 얕은 복사(shallow copy) VS 깊은 복사(shallow copy)

                - 얕은 복사(shallow copy)
                   : 참조 자료형(reference type)에 해당하는 값을 저장하는 변수의 참조값만 복사하는 것을 '얕은 복사(shallow copy)'라고 함

                     ex) 이름1이 저장한 heap영역 참조값 = 이름2이 저장한 heap영역 참조값 = {name : '김'}이 존재하는 heap영역 주소
                         (= 이름1이나 이름2나 특정 heap영역의 메모리주소에 어떤 값이 있는지는 모르겠고 {객체}가 있다고만 앵무새처럼 말하는 중)
                     
                         var 이름1 = { name : '김' };
                         var 이름2 = 이름1;
                         console.log(이름1 == 이름2);     <- ture

                - 깊은 복사(shallow copy)
                   : 참조 자료형(reference type)에 해당하는 값을 저장하는 변수의 참조값이 가르키는 참조 자료형(reference type)의 내용을 다른 heap영역에 똑같은 내용으로 복사하는 것을 '깊은 복사(shallow copy)'라고 함

                     ex) 이름2는 이름1과 1도 관계없는 heap영역에 {객체}를 생성하고 그 메모리주소를 참조값으로 저장하며, 단지 프로퍼티인 name의 값만 이름1의 주소값을 참조해서 프로퍼티를 뒤져서 가져옴
                         (= 이름2는 이름1에서 프로퍼티 값만 뽑아온거 뿐, 1도 참조값과 관계가 없음)
                     
                         var 이름1 = { name : '김' };
                         var 이름2 = { name : 이름1.name };
                         console.log(이름1 == 이름2);     <- false

             # (ES6 이후) 스프레드(펼침) 연산자 '...' (spread operator)
                 : '원시형'에 해당하는 값만 가지는 참조 자료형에 해당하는 변수에 '...변수명' 붙여서 해당 참조 자료형에 해당하는 다른 {}나 [] 내부에 사용하면, '깊은 복사(deep copy)'하게 됨
                     -> (쉽게 말해) '원시형'값만 가지는 참조 자료형으로 저장된 변수를 {}나 []를 떼서 다른 해당 참조 자료형의 변수 요소로 붙일 때 사용한다고 생각하면 됨

                         A. 스프레드 연산자(spread operator) '...' 사용법 및 예시

                            a. 기본 사용법 ('병합')
                                : '원시형'에 해당하는 값만 가지는 [배열], {객체}가 참조하는 내부의 모든 요소값들을 어떤 [배열], {객체}의 일부로 '병합'하는 경우    
                                    -> 병합 과정에서 []와 {}를 까서 넣는다고 생각하면 편함                           
 
                                       ex) '원시형'에 해당하는 값만 가지는 [배열]을 '...' 연산자를 써서 다른 [배열]의 일부로서 '깊은 복사(deep copy)'하는 경우
                                       
                                           var a = [1,2,3];
                                           var b = [4,5];
                                           var c = [...a, ...b]  
                                           a = [a, c]             <-  c라는 변수가 참조하는 [배열]과 무관
                                           console.log(c);        <-  a, b랑 무관하게 [1, 2, 3, 4, 5]가 출력
 
                                       ex) '원시형'에 해당하는 값만 가지는 {객체}를 '...' 연산자를 써서 다른 {객체}의 일부로서 '깊은 복사(deep copy)'하는 경우
                                       
                                           var o1 = { a : 1, b : 2 };
                                           var o2 = { c : 3, ...o1 };
                                           console.log(o2);            <-  { c : 3, a : 1, b : 2 }를 출력

                            b. [배열]의 내부값을 함수 호출시 () 내부에 parameter들로 대입할 떄 사용
                                : '원시형'에 해당하는 값만 가지는 [배열]이 참조하는 내부의 모든 요소값들을 []를 떼고 보고 싶을 경우 사용
 
                                  ex) '원시형'에 해당하는 값만 가지는 [배열]을 '...배열명'을 써서 참조하여 값을 보는 경우
                                        -> 정확히는 함수 선언시 rest parameter 처리가 되어 있기에, 다음과 같은 사용이 가능
 
                                           var 어레이 = ['hello', 'world'];
                                           console.log(어레이);     <- ['hello', 'world']라는 [배열] 그 자체를 보여줌
                                           console.log(...어레이);  <- hello world 라는 내부 요소들을 그 자체로 보여주게 됨
 
                                  ex) (주의) {객체}을 '...객체명'을 써서 참조하여 값을 보면 에러 뜸
 
                                      var 오브젝트 = { a : 1, b : 2 };
                                      console.log(오브젝트);     <- { a : 1, b : 2 }라는 {객체} 그 자체를 보여줌
                                      console.log(...오브젝트);  <- error 발생!

                         B. (주의) 스프레드 연산자(spread operator) '...' 사용시 주의사항

                            1) '원시형'에 해당하는 값만 가지는 {객체}를 '...'로 '깊은 복사(deep copy)'시 프로퍼티에 중복이 일어난다면?
                                 -> '병합'되던 '대입'되던 프로퍼티의 값은 나중에 들어온 값으로 대입됨

                                     ex) '...'를 사용해 복사한 {객체} 프로퍼티가 중첩되는건 걱정하지 않아도 순리대로 돌아감

                                         var o1 = { a : 1, b : 2};
                                         var o2 = { a : 3, ...o1 };
                                         console.log(o2);             <-  { a : 1, b : 2 }를 출력 (= 기존 a : 3 -> 1로 변경)
                         
                            2) 스프레드 연산자(spread operator) '...' 는 함수 호출시 (), {객체}의 {}, [배열]의 []안에서만 사용해라
                                -> 함수 호출시 내부()에서 사용하는 경우는 함수 선언시 'rest parameter'처리가 되어있기 때문

                            3) (중요!) 함수 호출시 ()에 스프레드 연산자(spread operator) '...'를 사용하여 parameter들로 [배열] 요소들을 대입할 수 있는 이유
                                 : 함수 선언시 ()안의 parameter들 선언 또한 'rest parameter'들을 받을 수 있게 설계했기 때문에 가능함

                            4) (중요!) 내부 요소값으로 1차적인 '원시값'이 아닌 중첩된 다른 참조 자료형을 가지는 요소는 그 참조값의 heap영역 주소를 참조한 '얕은 복사(shallow copy)'하게 됨
                               (= '얕은 복사(shallow copy)'이기 때문에 내부에 중첩된 객체나 배열까지 깊이 복사되진 않음)
                                    -> 중첩된 참조 자료형들을 가지는 [배열], {객체}를 완벽하게 '...'를 사용하여 '깊은 복사(deep copy)'하고 싶다? 
                                        -> 'lodash'라는 아주 좋은 라이브러리가 존재!

                                            ex) 중첩된 {객체}를 내부 요소값으로 가지는 [배열]에 '...' 연산자를 사용하는 경우, 중첩된 {객체}에 해당하는 값들은 '얕은 복사(shallow copy)'하게 됨
                                                 -> 원본 [객체]인 originalArray 내부의 중첩된 {객체}의 값이 변하면, 그걸 '...'로 '얕은 복사(shallow copy)'한 copiedArray의 내부 요소 {객체}값도 똑같이 변경됨
            
                                                let originalArray = [{ a: 1 }, { b: 2 }];
                                                let copiedArray = [...originalArray];
                                                
                                                copiedArray[0].a = 99;           <- 여기서 원본 [배열] 중첩된 내부요소의 {객체}로 들어간 프로퍼티 값이 변경되면?
                                                
                                                console.log(originalArray[0].a); // 99
                                                console.log(copiedArray[0].a);   // 99    <- 복사된 [배열]도 똑같이 적용
                                                
                                            ex) 중첩된 [배열]이 들어가도 똑같음
                                                
                                                let originalArray = [1, [2, 3], 4];
                                                let copiedArray = [...originalArray];
                                                
                                                copiedArray[1][0] = 99;           <- 여기서 원본 [배열] 중첩된 내부요소의 [배열]로 들어간 프로퍼티 값이 변경되면?
                                                
                                                console.log(originalArray[1][0]); // 99
                                                console.log(copiedArray[1][0]);   // 99   <- 복사된 [배열]도 똑같이 적용

                                            ex) lodash 라이브러리를 사용하면 완전히 중첩된 요소들도 '깊은 복사(deep copy)'가 됨
                                            
                                                const _ = require('lodash');

                                                let originalArray = [{ a: 1 }, { b: 2 }];
                                                let copiedArray = _.cloneDeep(originalArray);
                                                
                                                copiedArray[0].a = 99;           <- 원본의 중첩 {객체}의 내용이 변해도
                                                
                                                console.log(originalArray[0].a); // 1     <- 1도 관계없이 각자 갈 길을 갑니다
                                                console.log(copiedArray[0].a);   // 99

             # (중요) this
                 : 기본적으로 this의 의미는 OOP에서 현재 {} 영역의 주제가 되는 {객체}를 의미
                   (= 함수, 이벤트리스너 등 다른 개념에서의 this 또한 해당 함수가 속한 {}영역의 주인이 되는 {객체}를 참조한다고 보면 쉬움)

                  A. 전역스코프{}의 this라는 값 그 자체
                      : 전역 스코프 영역 {}의 주체인 {window 객체}를 참조
                          -> BUT! 엄격 모드(strict mode)에서는 undefined

                             ex) 'use strict' 상태의 this가 undefined로 출력되는 예시
                             
                                 <script>
                                   'use strict';
                                 
                                   function 간지나는함수(){
                                     console.log(this)
                                   }
                                   
                                   간지나는함수();
                                   
                                 </script>

                  B. {객체}에서의 this들
                      : 해당 {객체} 스코프 {} 영역의 주인이 되는 {객체}를 참조한다고 보면 쉬움
                          -> (중요) {객체} 내부의 프로퍼티나 메서드를 정의할 시, this가 생략되었다 봐도 무방

                              a. 사용자가 작성한 {객체} 내부의 this
                                  : 생성자가 생성한 {instance 객체}를 참조
                  
                                    ex) 오브젝트2.data.간지함수()의 호출 결과는 {data 객체}라는 {오브젝트2 객체} 내부의 중첩 {객체}
                                          -> {오브젝트2 객체} 내부의 data라는 프로퍼티는 this.data라고 써도 같은 이야기가 됨 
            
                                        var 오브젝트2 = {
                                          data : {
                                            간지함수 : function(){ console.log(this) }
                                          }
                                        }
                                        
                                        오브젝트2.data.간지함수();
      
                              b. new 키워드를 사용한 어떤 class {객체}의 생성자(constructor)로서의 함수의 this
                                  : 생성자(constructor) 함수가 생성한 {instance 객체}를 참조
                 
                                    ex) new Person('Bob')의 this = 오브젝트 변수에 할당된 자신이 생성한 {객체 그 자신}
                                    
                                        function Person(name) {
                                            this.name = name;
                                        }
                                        
                                        const 오브젝트  = new Person('Bob');
                                        console.log(오브젝트.name);
                                          -> 'Bob'

                  C. 함수(function)에서의 this들
                      : 함수에서의 this 또한 해당 함수가 속한 {}영역의 주인이 되는 {객체}를 참조한다고 보면 쉬움
           
                        a. (중요) 어떤 {객체}의 메서드로서의 함수의 this
                            : 해당 메서드를 소유한 {객체}를 참조
                              (= 이 녀석의 function에서의 this의 중심이 된다고 봐도 무방)                               
           
                        b. 독립된 전역 함수의 this
                            : JS에서 전역이라는 자체가 {window 객체} & {global} 객체를 참조함
                              (= 전역 함수라는거 자체가 {window 객체} & {global} 객체에 속한 메서드라고 봐도 무방함)
                                  -> BUT! 엄격 모드(strict mode)에서는 undefined
           
                              ex) 전역함수의 this는 전역 객체(window)를 참조
                              
                                  function sayHello() {
                                      console.log(this);
                                  }
                                  
                                  sayHello(); 
                                   -> window 객체가 출력됨

                        c. function 무명함수 내부의 this
                            : 무명함수가 선언된 위치에 따라 case by case로 달라짐
                              (= 호출 방식에 따라 this가 동적으로 결정될 수 있음)

                              1) (중요) 콜백함수(callback function)로 사용되는 무명함수 내부의 this
                                  : 콜백함수로 사용되는 무명함수 내부의 this는 {window 객체}를 의미
                                    (= 콜백함수로 사용되는 무명함수 그 자체는 그냥 {window 객체}에 속해있는 전역함수와 다른게 없음)

                                   - (참고) 콜백함수로 사용되는 함수 내부의 this의 의미
                                      : 어떤 함수의 호출과정의 parameter로 사용되는 함수도 따지고 보면 원칙적으로는 미리 선언이 되어야 정상이며, 그런 함수도 선언된 위치 {}영역의 주체를 출력함
                                        (= 변수가 받아줘서 함수 표현식(function expression) 형태가 되는 무명함수라면 그 변수가 소속된 {}영역을 this의 기준으로 삼음)

                                         ex) 이벤트리스너의 콜백함수도 무명함수고, 그 내부 어레이.forEach()의 콜백함수도 무명함수로 제법 구조가 복잡하나.. 
                                              -> 본질은 어차피 {window 객체}외에는 콜백함수로 들어간 무명함수들을 포함하는 {객체}는 존재하지 않음 
 
                                                 document.getElementById('버튼').addEventListener('click', function(e){

                                                   var 어레이 = [1,2,3];

                                                   어레이.forEach(function(){
                                                     console.log(this)
                                                   });
                                                 });

                                         ex) 함수라는 함수표현식 형식의 {오브젝트 객체}의 메서드의 실행부에는 {오브젝트 객체}의 프로퍼티인 [배열]의 메서드인 forEach()의 콜백함수도 무명함수로 제법 구조가 복잡하나.. 
                                              -> 본질은 어차피 {window 객체}외에는 콜백함수로 들어간 무명함수들을 포함하는 {객체}는 존재하지 않음 
                                                 (= {오브젝트 객체}의 함수표현식 형식의 메서드를 정의하여 작성 중이나, 콜백함수로 호출되는 함수는 그거랑 1도 관계없다는 것)

                                                 var 오브젝트 = {

                                                   이름들 : ['김', '이', '박'];

                                                   함수 : function(){
                                                       오브젝트.이름들.forEach(function(){
                                                         console.log(this)
                                                       });
                                                   }
                                                 }

                              2) 함수 표현식 형식으로 작성된 무명함수 내부의 this
                                  : 무명함수를 대입해서 받아준 변수가 소속된 {}의 소속을 따름
                                     -> 전역 스코프{} 안의 변수가 받는 경우 : {window 객체}
                                     -> 메서드 내부의 지역변수가 받는 경우  : {메서드 소속 객체}
 
                              3) 어떤 {객체}의 메서드가 함수 표현식 형식으로 작성된 무명함수 내부의 this
                                  : {메서드 소속 객체}를 의미
 
                              4) 어떤 함수의 내부 함수가 함수 표현식 형식으로 작성된 무명함수 내부의 this
                                  : 상위 함수가 {객체}에 소속된 메서드인지, 전역 스코프{}에 작성된 함수인지에 따라 다름
                                     -> {객체}에 소속된 메서드  : {메서드 소속 객체}
                                     -> 전역 스코프{} 작성 함수 : {window 객체}
 
                                        ex) 상위함수()를 호출하면, 상위함수()가 소속된 {window 객체}가 나옴

                                            function 상위함수(){
                                              
                                              var 하위함수() = function (){
                                                console.log(this);
                                              }
                                              
                                              return 하위함수();
                                            }


                        d. arrow function(화살 함수)의 this
                            : arrow function(화살 함수) 자신이 선언된 위치의 직속 상위 {}에 해당하는 {객체}가 의미하는 this를 정적으로 참조하여 절대 변경X
                              (= arrow function(화살 함수) 자신이 정의된 스코프 {}에서 사용 중인 this를 상속)

                             - this = 렉시컬 바인딩(lexcial binding)의 결과물
                                : arrow function(화살 함수)은 자신이 선언된 위치 {}에서 사용 중인 this를 절대 바꿀 수 없는 정적인 값으로 상속받음
                                   -> (중요) 그래서 call, apply, bind 함수로 arrow function(화살 함수)의 this의 값을 변경시킬 수 없음 
                                             (= 일반 함수는 그게 가능!)

                                       1) arrow function(화살 함수)가 전역 스코프{}의 함수표현식으로 선언되었시의 this
                                           : this = {window 객체}

                                       2) arrow function(화살 함수)가 일반 함수 내부의 함수표현식으로 선언되었시의 this
                                           : this = {해당 함수 소속 객체}

                                       3) arrow function(화살 함수)가 객체 스코프{}의 메서드로 선언되었시의 this
                                           : this = {해당 메서드 소속 객체}

                                             ex) {obj 객체}의 함수 표현식 메서드 regularFunc의 내부 함수표현식 arrowFunc의 this는 절대적으로 상위 {}의 regularFunc가 가르키는 해당 {}의 주인인 {obj 객체}를 의미
                                                   -> 화살표 함수 내부의 this는 regularFunc의 this를 의미
                
                                                      const obj = {
                                                        name: 'Alice',
                                                        regularFunc: function() {
                    
                                                          console.log('Regular Function:', this.name);    <- "Alice"
           
                                                          const arrowFunc = () => {
                                                            console.log('Arrow Function:', this.name);    <- "Alice"
                                                          };
                                                      
                                                          arrowFunc();
                                                        }
                                                      };
                                                      
                                                      obj.regularFunc();
               
                                             ex) {obj 객체}의 getValue 함수 표현식 메서드의 return값이 arrow function(화살 함수)며, this는 절대적으로 상위 {}의 getValue가 가르키는 해당 {}의 주인인 {obj 객체}를 의미
               
                                                 const obj = {
                                                   value: 42,
                                                   getValue: function() {
                                                     return () => this.value;
                                                   }
                                                 };
                                                 
                                                 const arrowFunc = obj.getValue();
                                                 console.log(obj.getValue());
                                                   -> 42
                                                   
                                       4) arrow function(화살 함수)가 어떤 함수의 콜백함수로 사용되었을 시 그 내부의 this
                                           : this = {window 객체}

                                             ex) 함수라는 함수표현식 형식의 {오브젝트 객체}의 메서드의 실행부에는 {오브젝트 객체}의 프로퍼티인 [배열]의 메서드인 forEach()의 콜백함수는 arrow function(화살 함수)
                                                   -> 본질은 어차피 {window 객체}외에는 콜백함수로 들어간 무명함수들을 포함하는 {객체}는 존재하지 않음 
                                                      (= {오브젝트 객체}의 함수표현식 형식의 메서드를 정의하여 작성 중이나, 콜백함수로 호출되는 함수는 그거랑 1도 관계없다는 것)
               
                                                       var 오브젝트 = {
                     
                                                         이름들 : ['김', '이', '박'];
                     
                                                         함수 : function(){
                                                             오브젝트.이름들.forEach(() => {
                                                               console.log(this)
                                                             });
                                                         }
                                                       }

                  D. 이벤트리스너 메서드에서의 콜백함수 내부의 this
                      : 현재 이벤트가 발생하는 대상인 {DOM 객체} 내부의 요소인 <HTML>를 의미하는 e.currentTarget
                         -> e.currentTarget은 이벤트리스너 함수의 콜백함수 1번째 parameter변수에 할당된 {arguments 객체}에 해당하는 {이벤트 객체}의 프로퍼티 중 하나
                             -> (참고) {이벤트 객체}
                                  : DOM API의 메서드인 이벤트리스너 실행시 그에 필요한 모든 정보들이나 조작함수를 멤버들로 가지고 있는 {객체} 

                                    ex) '버튼'이란 id를 가진 <HTML> 태그를 클릭하면, 그 이벤트의 내용을 실행하는 무명콜백함수의 this는 '버튼'이란 id를 가진 <HTML> 태그를 의미

                                        document.getElementById('버튼').addEventListener('click', function(e){
                                          console.log(this)
                                        });

                                    ex) 이벤트리스너의 콜백함수도 무명함수고, 그 내부 어레이.forEach()의 콜백함수도 무명함수로 제법 구조가 복잡하나.. 
                                         -> 본질은 어차피 {window 객체}외에는 콜백함수로 들어간 무명함수들을 포함하는 {객체}는 존재하지 않음 

                                            document.getElementById('버튼').addEventListener('click', function(e){
            
                                              var 어레이 = [1,2,3];
            
                                              어레이.forEach(function(){
                                                console.log(this)
                                              });
                                            });

                  F. apply, call, bind 메서드
                      : parameter위치에 argument로 원하는 {객체}를 this로 설정 가능
                 
                        ex) introduce라는 함수의 this를 obj라는 변수에 할당된 {객체}로 임의설정
                 
                            function introduce() {
                                console.log(this.name);
                            }
                            
                            const obj = { name: 'Charlie' };
                            introduce.call(obj); 
                              -> Charlie


  3. 함수(function)
      : 특정 기능에 해당하는 입력(input), 출력(output) 코드 묶음을 쉽게 불러와서 재사용하기 위해 스코프{}를 지정해놓고 모아서 모듈화해놓은 코드
         -> 엄밀하게 JS에서 함수는 {객체}에 해당하며, 심지어 '1급 객체'임

       @ (중요) 1급 시민 객체(First-Class Citizen)
          : JS에서 함수(fuction)는 '1급 객체(first-class object)'이기에 그에 따른 특성과 이점이 존재

             1) JS 언어 내부에서 '값'으로 표현되고 전달될 수 있는 자료형 중 하나로 취급되기에, 변수의 '값'으로서도 받을 수 있음
                  -> 이같은 특성을 기반으로 '다른 함수의 paramter(= 콜백함수)'로 사용하거나 return문에서 반환할 수 있는 '고차 함수(first-class object)'를 JS에서 사용 가능
            
             2) 엄연히 {객체}라는 점에서, 프로퍼티와 메서드를 가질 수 있음
                  -> 함수 {객체}의 프로퍼티에는 '지역변수', {}, 'closer 변수' 등등에 대한 정보가 모두 포함됨
                     (= 함수 {객체}를 변수에 할당하면 '함수 표현식' 형태가 되며, 그 변수는 해당 함수{객체}의 모든 정보를 가지고 있음)


       @ 전통적인 함수(function) 문법 사용법 
         (= 1급 시민 객체(First-Class Citizen) 개념이 없는 함수 선언식과 호출만 사용하는 패턴)
          : 프로시저 프로그래밍 패러다임에 따른 고전적인 함수 사용 방식
            (= JS에 1급 객체 함수적 특성은 1도 반영하지 않았을 경우의 함수 사용 패턴이라고 봐도 무방함)

             1) 함수 선언문(function declaration)
                 : 재사용 하길 원하는 코드들을 모으고 {}안에 묶은 뒤, 이를 어떤 이름으로 호출할 것인지에 대한 '함수명'을 명명하고, 그 앞에 해당 {}는 함수임을 알리는 function이란 예약어를 작성
                    -> 해당 함수(function)를 입력값에 동적으로 내용이 변화하고 출력값을 반환하도록 하고 싶다면, 함수 선언 시 '입력값'에 해당하는 인자(augument) 부분을 매개변수(parameter)가 받을 수 수 있도록 ()안에 parameter 변수를 정의하고, 내용부에서 사용 
                 
                       ex) '함수명'이란 함수 선언 예시
                       
                           function 함수명(... parmeter들){
                           
                             재사용을 하길 원하는 코드..
                             parameter에 해당하는 변수도 사용해도 됨
                           
                             return 영역  <- (생략해도 됨)
                           }
   
                  # 함수 선언(function declaration)과 호출만 존재하는 경우의 단점
                    a. 무조건 '함수명'이 필요함
                    b. 함수를 선언한 코드가 위치에 상관없이 무조건 최상단으로 호이스팅이 일어남
                        -> 작성 의도와는 다른 결과가 나올 수 있음
                        -> 그렇게 호이스팅 된 함수는 무조건 먼저 읽기 때문에, 함수 종류가 많아지면 성능에 문제 생김


                  # (중요) (ES6 이후) 함수 정의 시 사용 가능한 기능 정리
       
                    A. 기본 매개변수(defalut parameter)
                        : 함수를 선언할 떄 parameter의 기본값을 지정 가능
                          (= 함수를 호출 시, parameter 위치에 argument를 넣지 않으면, 그 기본값이 자동으로 해당 parameter 변수에 argument로 대입)
                              -> (참고) 기본 매개변수(defalut parameter)의 값으로는 '원시값' 말고, [배열], {객체] 같은 '참조형'도 들어갈 수 있고, 심지어 함수를 넣어도 논리만 맞으면 그만임

                                  ex) 기본적인 기본 매개변수(defalut parameter) 사용방식 

                                      function 더하기 (a, b = 10){
                                        console.log(a + b)
                                      }
                                      
                                      더하기(3);         <- 13 출력

                                  ex) 다른 parameter와 연산자를 통해 기본 매개변수(defalut parameter)의 기본값을 지정해도 전혀 문제 없음

                                      function 더하기 (a, b = 2 * a){
                                        console.log(a + b)
                                      }
                                      
                                      더하기(3);        <- 9 출력

                                  ex) 함수를 호출해서 채워도 기본 매개변수(defalut parameter)의 함수는 문제없이 작동함

                                      function 임시함수(){
                                        return 10 
                                      }
                                      
                                      function 더하기 (a, b = 임시함수() ){
                                        console.log(a + b)
                                      }
                                      
                                      더하기(3);        <- 13 출력

                    B. [인자](arguments array)
                        : 함수 선언시 내용부에 해당하는 함수의 {}안에 arguments라는 키워드(미리 함수라는 {객체}에 정의된 프로퍼티에 해당)에 해당 함수의 모든 parameter변수가 전부 [배열]의 요소로 들어가 있음
                            -> [arguments]를 통해, parameter변수에 들어간 각 argument들을 배열의 요소처럼 index로 접근이 가능함... 
                               (= 불특정한 개수의 나머지 매개변수(rest parameter)가 상정된 함수와 시너지가 유익함)

                               ex) arguments[index]값으로 a,b,c라는 parameter변수를 언급하지 않아도 접근에 문제없음

                                   function 함수(a,b,c){
                                     console.log(arguments[0])
                                     console.log(arguments[1])
                                     console.log(arguments[2])
                                   }
                                  
                                  함수(2,3,4);

                               ex) 나머지 매개변수(rest parameter)와 병행해서 사용도 가능은 함... 사실 굳이 이렇게 안해도 그냥 [나머지 매개변수명]도 똑같이 [배열] 형식이니 굳이 이렇게 안 써도 됨
                                     -> (중요!) [arguments]가 함수의 전체 parameter변수들의 [배열]이면, [나머지 매개변수(rest parameter)]는 따로 정의된 parmeter변수들을 제외한 parameter변수들의 [배열]에 해당함

                                   function 함수2(a, b, ...파라미터들){
                                     for (var i = 0; i < arguments.length; i++){
                                       console.log(arguments[i]);                <- [3,4,5,6,7,11,22,33,44] 출력
                                     }
                                   }

                                   var 스프레드연산자 = [11, 22, 33, 44]; 
                                   
                                   함수2(1,2,3,4,5,6,7, ...스프레드연산자);  <- 스프레드연산자 '...'를 사용하여 나머지 매개변수를 사용한 함수호출에 유용하게 사용
       
                    C. 나머지 매개변수(rest parameter)
                        : 함수 선언시 parameter를 입력하는 () 영역의 '가장 뒷쪽'에 '...parameter명' 형식으로 '...' 연산자를 붙여서 작성가능
                           -> (중요) 그렇게 하면.. 
                                - 함수 호출시 앞선에 미리 정의된 parameter들 이외의 다른 불특정한 갯수의 parameter들이 더 들어온다고 가정하고 함수의 내용부를 {} 작성이 가능함
                                - 앞선에 미리 정의된 parameter들 순서 이후에 들어올 모든 parameter들에 해당하는 변수들을 parameter명이란 변수를 통해 [배열] 형식으로 통제가 가능함
                                  (= 미리 정의된 parameter들 순서 이후에 들어오는 모든 나머지 parameter들 자리의 argument들을 [] 중괄호로 감싸줘 [배열]화 시킨 변수가 rest parameter)

                                  ex) 미리 정의된 a, b라는 parameter의 순서 자리를 제외한, 3번째 이후의 모든 argument에 해당하는 값은 [파라미터들]이라는 나머지 파라미터(rest parameter) 변수가 저장하여 함수의 내용부 {}에서 통제함

                                      function 함수2(a, b, ...파라미터들){
                                        console.log(파라미터들)               <- [3,4,5,6,7] 출력
                                      }
                                      
                                      함수2(1,2,3,4,5,6,7);

                                  ex) (참고) 나머지 파라미터(rest parameter)를 사용하여 선언한 함수를 호출할 떄 ()안에 인자(argument) 입력시 '스프레드 연산자'인 '...'의 연계가 아주 좋음

                                      function 함수2(a, b, ...파라미터들){
                                        console.log(파라미터들)                <- [3,4,5,6,7,11,22,33,44] 출력
                                      }

                                      var 스프레드연산자 = [11, 22, 33, 44]; 
                                      
                                      함수2(1,2,3,4,5,6,7, ...스프레드연산자);  <- 스프레드연산자 '...'를 사용하여 나머지 매개변수를 사용한 함수호출에 유용하게 사용

                                  ex) (주의1) 함수는 선언시 나머지 파라미터(rest parameter)를 가장 나중에 사용해야 에러가 안 남
                                        ->  나머지 파라미터(rest parameter)는 불특정 다수의 parameter를 포괄하는 [배열]에 해당하기에.. 이걸 앞쪽에 써버리면, 미리 선언한 parameter가 호출시 몇 번째에 해당하는 녀석인지 알 방법이 없음

                                            function 함수2(a, ...파라미터들, b){          <- 이렇게 쓰지 말라는거...
                                              console.log(파라미터들)
                                            }

                                  ex) (주의2) 나머지 파라미터(rest parameter)는 가장 끝에 1개만 사용해야 에러가 안 남

                                       function 함수2(a, ...파라미터들, ...파라미터들2){   <- 이렇게 쓰지 말라는거...
                                         console.log(파라미터들)
                                       }

             2) 함수(function) 호출
                 : 선언했던 함수의 '함수명'의 선언부에 해당하는 형식대로 '함수명(...argument들)'을 작성하면, 런타임 상황에서 해당 함수명의 내용부를 실행
                   (= 사용을 원하는 위치에 '함수명(...argument들)'을 작성하면 간단하게 원하는 코드를 재사용이 가능함)
                 
                   ex) '함수명'이란 함수 or 표현식 호출하기 + 결과값을 변수에 할당
                   
                        const result = 함수명(... argument들);
   
                  # (중요) 함수 선언(function declaration)과 호출만 존재하는 경우의 단점 (= 함수 표현식(fuction expression)의 이점)
                     : 함수가 호출(function call)되는 타이밍이 단순하면 상관없지만, 다른 함수들과 연계되어 타 함수들을 로직의 일부로서 사용하려고 들 때 상황에 맞게 동적으로 쓰기 힘들어짐
                       (= 함수 자체를 값으로 취급해서, 변수에 저장하거나 parameter의 argument로 사용하거나 return 할 수 있다면? 좀 더 유연하고 다양한 코딩 패턴의 가능성을 열어줄 수 있음)
                           -> 함수 표현식(function expression)의 사용 이유

                               ex) 함수를 동적으로 순차적 호출이 가능, 콜백함수를 동적으로 구성이 가능, 클로저 패턴을 사용 가능


       @ (중요) 함수 표현식(function expression) 
          : JS에서 함수(function)가 변수에 할당 가능한 값을 가진 {객체} 자료형에 해당하는 '1급 객체'라는 특성을 이용, 함수(function)을 변수에 할당하여 표현하는 광범위한 방식을 통칭
            (= 변수에 할당되는 함수는 기존에 선언된 함수일 수도 있고, 실행 타이밍이 되서야 알게되는 무명함수일 수도 있음!)

            a. 기존 선언된 함수를 변수에 할당하는 방식의 함수 표현식(function expression) 
               
               ex) 상단의 '함수명'이란 함수가 선언되고, 이를 변수명이 표현식으로 할당한 경우, 변수명(...parameters);는 그 함수를 호출하는 구문이 됨
               
                   var 변수명 = 함수명;

                   변수명(...argument);
            
            b. 무명함수를 변수에 할당하는 방식의 함수 표현식(function expression) 
                : 재사용 하길 원하는 코드들을 모으고 {}안에 묶고 그 앞에 해당 {}는 함수임을 알리는 function이란 예약어를 작성하는 것까지는 같지만, '함수명'을 명명하지 않는 무명함수 방식으로 변수에 할당하여 작성     
                   -> 마찬가지로 parameter를 넣을 수 있도록 ()안에 parameter 변수를 정의하고, 내용부에서 사용하면 해당 함수를 상황에 따라 유연하게 적용 가능            
            
                      ex) greet라는 변수에 무명함수가 할당된 '함수 표현식' 형식 예시
           
                          const 함수명 = function(... parmeter들){
           
                            재사용을 하길 원하는 코드..
                            parameter에 해당하는 변수도 사용해도 됨
                          
                            return 영역  <- (생략해도 됨)
                          };

            # 함수 표현식(function expression)을 사용하는 이유 및 이점?
               : 단순히 선언된 함수만 변수에 대입하는 것으로는 별 쓸모 없지만... 
                  -> {객체} 값으로서 활용가능한 '1급 객체'로서, '고차함수'로서 사용이 가능한 JS 함수의 특성에 따른 유연성 및 확장성에 대한 포텐셜을 극강으로 끌어올릴 수가 있음
                      (= 그 자체로도 '1급 객체'로서의 함수의 특성이 있기에 존속이 가능하나, = 함수를 argument값이나 return값으로 사용하는 '고차함수' 개념까지 연계되면 활용도와 유연성이 정말 높아짐)
    
                      ex) 함수를 동적으로 순차적 호출이 가능, 콜백함수를 동적으로 구성이 가능, 클로저 패턴을 사용 가능

       @ 함수 선언(function declare) VS  함수 표현식(function expression)
          : 함수 표현식(function expression) 개념은 함수 선언(function declare)과 양립 불가능하지 않음!
            (= 오히려 '1급 객체'로서 함수의 특성을 극한으로 이용하여, 선언된 함수를 더 유연하게 쓰이게 하거나, 더 고차원적인 패턴으로 활용할 수 있음을 의미함)
          
             1. 호이스팅(Hoisting) 여부
                 : 함수의 선언 및 작성 위치와 상관없이, 프로그램이 코드 실행전 무조건 코드의 가장 최상위로 올려두는지 여부
                   (= 대충 var와 let의 관계와 유사)
                    -> 원본 코드의 실행 순서대로의 전개가 전혀 달라질 수 있는 사안이 될 수 있음
   
                  a. 함수 선언 (Function Declaration)
                      : 코드 실행 전에 최상단에 호이스팅 됨
                        (= 무조건 함수 호출부에서 함수를 발견하지 못하는 문제가 생기지 않도록 만듦)
   
                  b. 함수 표현식 (Function expression)
                      : 호이스팅과 전혀 관계가 X
                        (= 어떤 변수에 함수를 할당하는 함수 표현식의 형태의 경우 코드가 실행되는 시점에 함수가 정의되기에, 함수의 호출은 함수의 변수 할당 이후에만 호출이 가능)
   
                    # (중요) 만약 'var 변수'로 '함수 표현식'에 해당하는 할당을 받는다면?
                        : var변수의 호이스팅 원칙이 먼저 적용되어서, var 변수명; 상태로 호이스팅 되고, 함수가 할당되기 전까지는 undefine 값으로 출력되게 됨
   
                          ex) var변수의 호이스팅 결과로 var sayHello = ''; 코드가 최상단에 위치하는 효과를 낳게 됨
   
                              console.log(sayHello);  // Output: undefined
                              sayHello();             // TypeError: sayHello is not a function
                              
                              var sayHello = function() {
                                  console.log("Hello!");
                              };
                              
                              sayHello();             // Output: "Hello!"
   
             2. 무명 함수(anomyous function) 사용 가능 여부
   
                  a. 함수 선언 (Function Declaration)
                      : '함수명'은 무조건 설정되어야 함
                         (= 같은 {} 단계에서는 무명함수와 양립이 불가능)
   
                  b. 함수 표현식 (Function expression)
                      : '기존 선언 함수' 말고도 '무명 함수' 또한 변수에 할당이 가능함
                        (= 변수를 통해 단순히 선언된 함수를 받아주는 수준이 아니라, 그 변수 자체가 할당된 무명함수를 통해 선언된 함수처럼 기능하면서 더 유연한 사용이 가능)

       @ (중요) 함수 호출(function call) VS {객체}값으로서의 함수
           : 작성에 있어.. 아주 약간의 차이가 있지만 그 의미는 어마무시하게 차이가 남
             (= 별 차이 없어 보이기에 작성하는 입장에서도 햇갈리고, 경우에 따라서는 코드를 읽는 입장에서도 해석을 잘못할 위험이 존재함)

             1) 함수 호출(function call)
                 : 어떤 함수를 정의된대로 argument를 넣고 실행하라는 명령어.. 반드시 '함수명(...argument)'와 같이 ()가 들어가며, 결과값은 호출된 함수의 {}의 return값을 가져옴
                    -> (중요) {}내에 window객체에 선언된 전역 변수를 변경하는 내용이 있다면, 이는 함수의 스택 프레임(stack frame)이 끝나도 반영되어 있음

                       ex) const result = 함수명(... argument들);
                            -> result는 함수명(... argument들)을 실행한 return값을 가짐
                                -> (중요) JS에서는 함수의 return값은 또 다른 함수도 가능하니.. '함수 호출 != return 함수' 라고 생각하면 안됨!
           
             2) '{객체}값'으로서의 함수 (!= 함수 포인터)
                  : 말 그대로 어떤 변수에 대입가능하고, 함수의 return값으로 반환도 가능한 선언된 스코프와 클로저와 같은 모든 맥락(context)를 가지고 있는 값으로서의 함수... '함수명'과 같이 ()를 쓰지 않고 사용함
                     -> (주의) '함수 포인터'와 유사한 개념이나 메모리 주소만을 저장하는 함수 포인터와는 다르게, {객체}값으로서의 함수는 맥락(context)에 해당하는 정보를 프로퍼티로 가지고 메서드 또한 가질 수 있음

                  # '{객체}값'으로서의 함수를 사용하는 경우의 이점?
                      a. 함수(function)을 변수에 할당하여 표현하는 '함수 표현식(function expression)'에 사용시 이점
                          : 단순히 선언된 함수만 변수에 대입하는 것으로는 별 쓸모 없음
                              -> if 대입되는 함수가 무명함수라던지... 
                              -> if 대입되는 함수의 return값이 또 다른 함수인 '고차 함수'라던지 하는 경우가 있다면?
                                  -> 변수에 대입되는 함수를 동적으로 변환이 가능하기에, 같은 변수명으로도 동적으로 함수를 호출하는 것이 가능
                                     (= 함수를 argument값이나 return값으로 사용하는 경우와 시너지를 이룸)

                                     ex) const itself = 함수명;
                                          -> itself는 '함수명'이란 선언된 맥락(context)에 대한 모든 정보와 프로퍼티 메서드를 가지는 함수 {객체}를 저장

                                     ex) 무명함수를 변수에 대입하면, 사실상 함수 선언을 대체 가능
                                     
                                         const itself =  function(x) {
                                           return x*x
                                         }

                      b. 다른 함수 호출시 parameter자리에 argument값으로 함수를 넣어 '고차 함수'인 '콜백함수(callback fucntion)'으로 사용시 이점
                          : 호출한 함수의 {}에서 argument값으로 보낸 함수를 parameter 변수에 넣어 동적으로 호출할 수 있도록 해줌
                             -> 함수{} 안에서 호출을 하던, 다른 함수를 호출시 parameter자리에 argument값으로 또 보내던, return값으로 보내던 다양하게 응용이 가능하게 함

                            ex) executeFunction의 parameter는 함수에 해당하고, 그 함수를 콜백함수로서 사용... 
                                 -> executeFunction(createFunction)의 경우 parameter에 해당하는 createFunction값 자체는 함수{} 안으로 해당 함수를 사용할 수 있게 함수 {객체}를 전달하며, 함수{} 안에서 createFunction()의 형태로 호출시킴 
                            
                                    function createFunction() {
                                       return function() {
                                           console.log("Hello, World!");
                                       };
                                    }
            
                                    function executeFunction(func) {
                                      func();
                                    }
            
                                    executeFunction(createFunction);

                      c. return값에 '고차 함수'로서 사용
                          : 함수의 결과로 어떤 함수를 반환하며, 이를 변수에 할당하면 함수 표현식(function expression)이 됨
                             -> 어떤 함수의 return값이 함수이고, 그 함수의 내용부가 해당 함수 {객체}가 저장하는 맥락(context)에서 자신을 호출한 함수{}의 프로퍼티와 연관이 되어 있다면?
                                 -> return된 함수를 받아주는 변수를 통해 함수 표현식이 완성되고, 그 표현식을 통해 함수가 호출되어 프로퍼티가 변동한다면, 상위 함수 호출이 끝나도 그 내부 프로퍼티는 계속 메모리에 할당된 일종의 {객체}의 캡슐화된 프로퍼티로서 메모리에 남아있게 하는 패턴을 사용 가능함
                                    (= 클로저(closer) 패턴)


                  # 클로저(closer) 패턴
                     : {객체}개념은 존재해도 이를 통제하는데 있어 캡슐화나 접근 제어자 개념이 없던 JS의 문제점을 극복하기 위하여.. 함수의 '1급 객체'로서의 특성을 활용하여 이를 구현함
                        -> 함수{} 내부의 변수를 프로퍼티로 return되는 함수를 메서드로서 활용할 수 있도록 설계하여, 캡슐화된 {객체}의 프로퍼티와 일종의 setter기능을 유사하게 구현한 패턴 
                           (= 본격 접근제어자가 ES6 이후 등장하기 전까지, 개발자들은 접근제어자 개념이 JS에서 필요할 시 이를 사용함)
                     

                           ex) 클로저(closer) 패턴 예시
                                -> createCounter라는 변수는 무명함수를 할당받는 표현식에 해당하는 함수를 할당받으면, return값은 그 내부 프러퍼티 count의 값을 증가시키는 함수 {객체}를 반환함
                                   (= createCounter 변수는 해당 무명함수의 {객체}가 가진 {}나 프로퍼티 정보를 모두 저장하게 됨)

                                -> 그 createCounter라는 함수 표현식을 호출하여 그 반환되는 함수를 counter라는 변수가 받으면, createCounter에 할당된 무명함수의 프로퍼티 count는 호출이 끝나도 계속 남아있음
                                   (= counter라는 변수는 createCounter에 할당된 해당 무명함수가 return한 다른 무명함수의 {객체}가 가진 {}나 프로퍼티 정보를 모두 저장하게 되기 떄문)

                                -> createCounter라는 함수 표현식이 호출될 때마다 count의 값은 1씩 증가함
                                   (= 애초에 createCounter, counter라는 변수들에 각자 할당된 함수 {객체}의 정보들을 기억하고 있어서 가능한 일)
                           
                                   const createCounter = function() {
                                       let count = 0;
                                   
                                       return function() {
                                           count++;
                                           return count;
                                       };
                                   };
                                   
                                   const counter = createCounter();
                                   
                                   // counter()는 createCounter에 할당된 무명함수의 return되는 무명함수를 호출하여 실행함 
                                   console.log(counter());  // Output: 1
                                   console.log(counter());  // Output: 2
                                   console.log(counter());  // Output: 3


       @ (중요) parameter(매개변수)와 argument(인자) 개념의 차이
          : 둘 다 함수의 내용부에 전달되는 '입력 데이터'와 연관된 해당되는 개념들이지만, 함수를 '정의' 혹은 '호출' 하는지 여부에 따라 개념이 나뉨

           # parameter와 argument 공통점/차이점 
              1) 공통점
                  : 함수의 내용부에 전달되는 '인자'에 해당되는 개념 

              2) 차이점
                  a. parameter
                      : 함수를 '선언(declare)'할 때 내용부에 입력받을 값을 '전달하는 역할의 변수'에 해당
                         -> (참고) ES6 이후 함수 선언시 ()안의 parameter 변수에 호출시 값이 들어오지 않으면, 자동으로 값을 넣어주는 'defalut parameter' 개념이 존재

                  b. argument
                      : 함수를 '호출(call)'할 때 parameter자리에 입력되어, 함수의 내용부에 parameter 변수를 통해 전달될 '값' 그 자체를 의미
                         -> (참고) 그래서 ES6 이후 함수 선언시 {}안의 내용부에 'arguments'라는 함수 {객체}의 프로퍼티를 통해 parameter에 전달된 값들을 [배열] 형식으로 볼수 있음

                            ex) greet란 함수 정의시 ()의 name이라는 parameter 변수가 존재하고, greet를 호출시 Alice와 Bob이 name이라는 parameter 변수에 전달되는 argument
    
                                function greet(name) {
                                    console.log("Hello, " + name);
                                }
    
                                greet("Alice"); 
                                greet("Bob");   

           # parameter를 통해 argument가 함수에 전달되는 과점
              : 함수를 호출 시, parameter 변수에 argument가 할당되고, 그렇게 값을 할당받은 parameter는 이를 함수의 내용부에 전달하는 구조라고 보면 됨

                ex) 다음의 showDetails(x, y)라는 함수가 showDetails(10, 20)로 호출되면, 내용부에 'parameter = argument값' 이런식으로 정의되고 사용된다 생각하면 편함

                    function showDetails(x = 10, y = 20) {

                        let x = 10;
                        let y = 20;

                        console.log("x before assignment: ", x); // 10
                        console.log("y before assignment: ", y); // 20
                    }                

       @ (중요) 콜백 함수(callback function)
          : 어떤 함수의 parameter자리에 '1급 객체'인 {함수 객체}가 '고차 함수'로서 argument로서 할당되는 함수로, 함수의 내용부에서 특정 작업이 완료된 후 호출되는 용도
            (= 어떤 함수가 호출 시 내용부에서 정적(static)으로 정해진 특정 함수가 아니라 parameter의 argument로서 동적(dynamic)하게 입력된 함수를 모듈로서 포용이 가능함)
                -> why 사용할 함수들을 단순히 나열하여 호출 않고, 콜백함수를 쓰는가? 
                    : 비동기 코드가 껴버리면, 나열한 순서대로 실행을 보장할 수 없기 때문...

           # 콜백 함수(callback function)를 사용하는 JS의 주요 기능
              : 해당 기능들에 해당하는 함수는 선언할 때 parameter 중 콜백함수(callback function)으로 함수가 들어갈 것이 상정됨

               1) DOM API 중 이벤트리스너

                  ex) document.getElementById('myButton').addEventListener('click', function() {
                          alert('버튼이 클릭되었습니다!');
                      });

               2) 비동기 작업 처리 함수

                  ex) promise, async/await, setTimeout 등이 여기 포함
                  
                      setTimeout(() => {
                          console.log('1초 후에 실행됩니다.');
                      }, 1000);

               3) [배열] 메서드

                  ex) let numbers = [1, 2, 3, 4, 5];
                      
                      numbers.forEach(function(number) {
                          console.log(number * 2);
                      });

           # 콜백 함수(callback function)의 장/단점
              : (결론) 이 녀석의 장점은 살리고, 단점은 최소화하기 위해 고안된 결과물이.. ES6의 'Promise'를 이용한 디자인 패턴인 'then, catch, finally', ES8의 'async/await'
           
              (장점)
                1) 비동기 처리(async)
                    : 비동기 작업의 실행 순서를 효과적으로 통제하고, 처리할 수 있음
                      (= 일반적인 순서대로 함수호출을 나열할 시, 거기에 비동기 코드가 끼어있으면 의도가 계산이 힘듦)
                    
                      ex) AJAX 요청이 완료된 것이 감지되면, 데이터를 어떤 함수를 통해 처리하라는 식의 코드를 작성할 수 있음
           
                2) 코드 구조화
                    : 해당 코드가 더 구조화되고 모듈화되어 유연해짐 재사용성이 증가
                    
                      ex) 특정 작업을 별도의 함수로 정의 후, 필요한 곳에서 재사용 가능
           
                3) 유연성
                    : 상황에 따라 함수 호출시 다른 콜백 함수를 전달하면, 함수의 동작을 유연하게 조정가능
                      (= 2)의 코드 구조화의 부산물이라고 보면 됨) 
           
              (단점)   
                1) 콜백 지옥(callback hell)
                    : 중첩(nested)된 콜백 함수가 많아져서, 함수{}들이 2중 3중으로 중첩되어 있으면 코드가 복잡해지고 가독성이 떨어질 수 있음
                       -> 이를 개선하기 위한 시작점으로 ES6의 promise를 이용한, 

                          ex) 전형적인 콜백지옥으로, 엄청나게 많은 함수{}가 중첩되어 있음
                                -> 코드가 실행은 되지만, 이거 인간의 시선에서 함수가 어떻게 작동하는지와 디버깅이 참 답도 없음
                          
                                   첫째함수(function(){
                                     둘째함수(function(){
                                       셋째함수(function(){
                                         어쩌구..
                                       });
                                     });
                                   }):
           
                2) 비동기 작업 에러 처리
                    : 비동기 작업에서 발생하는 에러를 처리하기 어려울 수 있음

       @ 무명 함수(anomyous function)
          : 주로 '특정 상황'에서 '일회성'으로 사용되거나 즉시 실행되기 위해 정의되기에 함수명도 주기 귀찮아서 '함수명'이 형태로 사용이 가능한 함수
            (= 요컨데 재사용율이나 용도가 특정 용도나 함수와의 연계에 몰려있어, '함수명'을 써가면서 사전에 로딩할 필요도 없는 경우 사용하는 이름없는 함수)
                -> (중요) SO.. 특정 변수에 할당되는 '함수 표현식(expression)'과 다른 함수의 parameter자리에 argument로 전달되거나 return값으로 반환되는 '고차함수'로서 별 다른 절차 없이 간편하게 사용 가능

           # 무명 함수(anomyous function)가 주로 쓰이는 방식?
              : 함수 표현식(expression)에서 변수에 할당되거나, 타 함수를 호출시 parameter위치에 '콜백함수(callback function)' 역할의 argument로 할당되는 사용할 때 신속 간편하게 쓰임
                 -> 암튼, 선언하지 않고 사용이 가능하다는 이점에 집중

           # 즉시 실행 표현식 (IIFE)
              : {window 객체}에 해당하는 전역 {} 범위를 오염시키지 않는 무명 함수를 선언하자마자 즉시 실행되는 함수를 만드는 방법
                  -> 원래 단독으로 무명함수를 선언하는 경우에는 그것을 받아줘서 함수 표현식 형태로 유지해주는 변수가 있어야 호출이 가능하나... 
                      -> BUT! IIFE가 있으면 그냥 무명함수를 실행할 수도 있다는 말씀
                  
                         ex) IIFE 형식은 다음과 같은 형식으로 선언과 동시에 호출이 되는 구조
                           
                             ( function(){ 내용 } )(); 

                         ex) 직접적인 IIFE 예시
                         
                            (function() {
                                console.log("This IIFE executes immediately and encapsulates the code.");
                            })();
    
       @ arrow function(화살 함수)
          : ES6에서부터 함수를 보다 단순하게 표현하는 방법론에 해당하는 '람다 대수' 개념을 받아들여, '람다 표현식'에 해당하는 화살표(=>)를 이용해서 무명함수를 더 단순하게 작성할 수 있도록 개선한 문법
             -> (중요) arrow function(화살 함수) = '람다 표현식' = 무명함수를 작성하는 새로운 방식이나 다름없음 
                       (= 변수에 함수를 대입하는 '함수 표현식'과 아주 밀접한 관계를 이룸)
    
                # 기존 무명함수 선언식 -> arrow function(화살 함수) 작성법
                   1) function 예약어 대신 화살표(=>)를 함수의 몸체로 사용
                   2) 함수의 내용부가 1줄이면(= 단일 실행문) 괄호{}를 생략 가능
                       -> (주의) return문으로만 내용이 구성되어 있는 경우 {}는 생략 불가
                   
                           ex) function(...parameter){ 내용 }   ->   (...parameter) => { 내용 }

                # 즉시 실행 표현식 (IIFE)과 arrow function(화살 함수)
                   : arrow function(화살 함수)도 무명 함수이기도 하다보니, 거기에 ()로 감싸서 호출하면 그냥 무명함수 그 자체임

                     ex) arrow function(화살 함수)를 콜백함수로서 arrow function(화살 함수) 형식의 즉시 실행 표현식 (IIFE)의 parameter로 전달한 case 

                         (() => {
                              let message = "This is an IIFE using an arrow function";
                              console.log(message);
                         })();

                # arrow function(화살 함수) vs 무명 함수
                   1) function 대신 '->'를 사용한 간결하고 짧은 문법
                   2) (중요) this를 arrow function(화살 함수)의 내용부에 썼을 경우, 자신의 직속 상위 {}에 해당하는 {객체}를 의미하게 됨
                        -> arrow function(화살 함수)과 function을 쓰던 함수나 무명함수의 this는 의미가 달라짐

       @ (중요!) 모든 종류의 function에서의 this의 의미 정리
           : 기본적으로 this의 의미는 OOP에서 현재 {} 영역의 주제가 되는 {객체}를 의미
             (= 함수에서의 this 또한 해당 함수가 속한 {}영역의 주인이 되는 {객체}를 참조한다고 보면 쉬움)

             1) (중요) 어떤 {객체}의 메서드로서의 함수의 this
                 : 해당 메서드를 소유한 {객체}를 참조
                   (= 이 녀석의 function에서의 this의 중심이 된다고 봐도 무방)                               

             2) 독립된 전역 함수의 this
                 : JS에서 전역이라는 자체가 {window 객체} & {global} 객체를 참조함
                   (= 전역 함수라는거 자체가 {window 객체} & {global} 객체에 속한 메서드라고 봐도 무방함)
                       -> BUT! 엄격 모드(strict mode)에서는 undefined

                   ex) 전역함수의 this는 전역 객체(window)를 참조
                   
                       function sayHello() {
                           console.log(this);
                       }
                       
                       sayHello(); 
                        -> window 객체가 출력됨

             3) new 키워드를 사용한 어떤 class {객체}의 생성자(constructor)로서의 함수의 this
                 : 생성자가 생성한 {instance 객체}를 참조

                   ex) new Person('Bob')의 this = 오브젝트 변수에 할당된 자신이 생성한 {객체 그 자신}
                   
                       function Person(name) {
                           this.name = name;
                       }
                       
                       const 오브젝트  = new Person('Bob');
                       console.log(오브젝트 .name);
                         -> 'Bob'
   
             4) apply, call, bind 메서드
                 : parameter위치에 argument로 원하는 {객체}를 this로 설정 가능

                   ex) introduce라는 함수의 this를 obj라는 변수에 할당된 {객체}로 임의설정

                       function introduce() {
                           console.log(this.name);
                       }
                       
                       const obj = { name: 'Charlie' };
                       introduce.call(obj); 
                         -> Charlie

             5) function 무명함수의 this
                 : 무명함수가 선언된 위치에 따라 case by case로 달라짐
                   (= 호출 방식에 따라 this가 동적으로 결정될 수 있음)

             6) arrow function(화살 함수)의 this
                 : arrow function(화살 함수) 자신이 선언된 위치의 직속 상위 {}에 해당하는 {객체}를 정적으로 참조허고 절대 변경X
                   (= arrow function(화살 함수) 자신이 정의된 스코프에서의 this를 사용)

       @ 함수(function) 사용시 특이사항
          1) 함수명을 영어로 작명한다면? camelCase로 작명하는게 관습 
             (= kebab-case로 작성해도 기능에는 문제가 없음)

          2) return문에 도달하면, 해당 함수는 그 위치에서 종료되고 메모리 stack들도 차례차례 해제됨
             (= return문 뒤에 존재하는 코드들은 실행대상에서 배제됨)

          3) 함수 선언시 내용부를 마무리 시 return 문은 생략해도 상관은 없고, 함수{}의 끝을 향해 달림
              -> 물론 생략한다고 해도, 프로그램은 내부적으로 return 0;과 같은 형태의 return문을 임의로 작성함

          4) JS에서 함수(fuction)는 '1급 객체(first-class object)'로서 또한 언어 내부에서 '값'으로 표현되고 전달될 수 있는 자료형 중 하나로 취급
              -> 함수(fuction)의 parameter에는 어떤 함수 그 자체가 parameter로 들어가거나 return 값이 되기도 하는 '고차 함수(first-class object)'로서 사용이 가능
                 (= parameter로 함수가 들어가 콜백함수나 return 값으로 사용될 수 있다는 건, 함수가 변수에 대입될 수 있다는 것)

          5) (중요) '함수명()'과 '함수명'은 명확히 다른 의미를 지님
               -> '함수명()'
                    : function인 함수명()을 호출하여, 그 내용부를 parameter 자리에 들어온 값을 대입해 실행하라는 의미
                      (= 함수를 호출해서 실행하도록 하고 싶으면, '함수명()'와 같이 반드시 ()까지 같이 입력해 줌)

               -> '함수명'  
                    : function인 함수명()의 해당 함수 그 자체를 {객체}값으로 사용하는 방식 
                      (해당 함수가 어떤 함수의 콜백함수로서 parameter나 return값으로 쓰이는 '고차함수'나 변수에 할당하는 '함수 표현식'에 사용)

          6) (중요) this라는 키워드를 통해, 함수가 속한 {}를 관장하는 {객체}를 끌어다 쓸 수 있음
          7) (중요) {}내에 window객체에 선언된 전역 변수를 변경하는 내용이 있다면, 이는 함수의 스택 프레임(stack frame)이 끝나도 반영되어 있음
               -> 그래서, 전역변수 어지간하면 쓰지 말라는거

       @ apply, call, bind 메서드
          : 어떤 함수를 실행시, this로 설정할 {객체}를 다르게 설정(binding)하고, 함수 실행 방식에 영향을 주기 위해 사용하는 {함수 객체} 내부에 존재하는 메서드
              -> 3개의 메서드는 비슷하지만, 세부 기능이 조금씩 다름

                # apply, call, bind 메서드 설명

                   1) call 메서드
                       : 어떤 함수를 실행시, this로 설정할 {객체}를 다르게 설정(binding)하기 위해 사용하는 메서드
  
                        - call 메서드 문법
                           : 호출함수명.call({대입 객체명}, augument1 , ... , augumentN);
                              -> 1번쨰 parameter변수가 해당 호출함수명의 내용부의 this를 받을 {객체}에 해당되며, 그 나머지 parameter변수들은 해당 함수의 parameter 변수들의 역할을 순차적으로 맡음
  
                                 ex) greet.call(person, 'Hello', '!')의 의미
                                      : greet 함수의 this의 주체를 {person 객체}로 하고, parameter변수에는 인수(augument)로 'Hello'와 '!'가 전달하여 호출하라는 것
       
                                        function greet(greeting, punctuation) {
                                            console.log(greeting + ', ' + this.name + punctuation);
                                        }
                                        
                                        const person = { name: 'Alice' };
                                        
                                        greet.call(person, 'Hello', '!');
  
                        - call 메서드 주의점(= 단점)
                           : 나머지 매개변수(rest parameter)들은 이후 쉼표로 하나하나 구분해 직접 전달해야만 함!
                             (= 나머지 매개변수(rest parameter)들을 [배열]로 넣는건 불가능 함)
                                 -> apply 메서드의 등장 이유
  
                   2) apply 메서드
                       : call과 마찬가지로 사용되나, parameter변수에 대입하여 쓸 인수(augument)들을 [배열]로 넘긴다는 점에서 압도적인 편의성이 존재
                          -> 호출할 함수에 전달할 인수(augument)가 많거나 동적으로 설정될 때 사용하면 좋다는 점에서, 스프레드 연산자 '...'의 그것과 용도가 유사
                             (= ES6 이전 '스프레드 연산자'의 등장 이전에는 '참조자료형'의 '깊은 복사'에 이 녀석들이 간간히 활용됨)
  
                        - call 메서드 문법
                           : 호출함수명.call({대입 객체명}, augument1 , ... , augumentN);
                              -> 1번쨰 parameter변수가 해당 호출함수명의 내용부의 this를 받을 {객체}에 해당되며, 그 나머지 parameter변수들은 해당 함수의 parameter 변수들의 역할을 순차적으로 맡음
  
                                 ex) greet.apply(person, args)의 의미
                                      : greet 함수의 this의 주체를 {person 객체}로 하고, parameter변수에는 인수(augument)로 [args]가 가진 내부 요소들을 전달하여 호출하라는 것
       
                                        function greet(greeting, punctuation) {
                                            console.log(greeting + ', ' + this.name + punctuation);
                                        }
                                        
                                        const person = { name: 'Alice' };
                                        const args = ['Hello', '!'];
                                        
                                        greet.apply(person, args);
  
                   3) bind 메서드
                       : 어떤 함수를 기반으로 this로 설정할 {객체}를 다르게 설정(binding)만 변환한 새로운 함수를 반환하기 위해 사용하는 메서드
                         (= bind 메서드로 반환된 함수는 나중에 호출할 수 있음)
                             -> 기존 함수를 기반으로 this의 주체만 변한 함수를 손쉽게 생성해서 사용가능하다는 이점이 존재

                                ex) boundGreet라는 함수는 greet 함수에서 this에 대한 참조값만 변환한 새로운 함수

                                    function greet(greeting, punctuation) {
                                      console.log(greeting + ', ' + this.name + punctuation);
                                    }
                                    
                                    const person = { name: 'Alice' };
                                    
                                    const boundGreet = greet.bind(person);
                                    boundGreet('Hello', '!');

                # apply, call, bind 공통점/차이점

                  (공통점)
                    : 모두 어떤 함수 내용부의 this 값을 {특정 객체}로 설정하는 기능을 제공
                        -> 함수의 맥락(this)을 명시적으로 변경하고, 그 변경된 맥락에서 함수를 호출하는 편의성을 제공

                  (차이점)

                    1) 함수 호출 시점
                      - call, apply 함수를 즉시 호출
                      - bind는 새로운 함수(바인딩된 함수)를 반환함
                        (= 호출 시점은 원하는데로 조절)

                    2) 사용법과 함수 선언부의 구조가 제각각

  4. 조건문
      : ()안의 어떤 조건식의 결과가 true, falue이냐에 따라서, 코드 {}를 실행할지 말지를 정할 수 있게 만든 구문에 대한 문법

       @ 조건식
          : 참(True) 또는 거짓(False)의 boolean 값으로 환산될 수 있는 변수나 연산자로 or 함수 호출로 구성된 표현식.. 
            (= 조건문은 ()안의 내용을 연산한 뒤 참(True) 또는 거짓(False)을 판별하고, 어떤 {}의 코드를 실행할 지 말지를 결정함) 

           # 자료형에 따라 false에 대응하는 값들 (= 그 외의 값은 true으로 평가)
              : 0, null, undefined, NaN, "" 

                ex) false에 속하는 값들 equality 예시
                
                    console.log(0 == false);          // true
                    console.log(0 === false);         // false : 0은 number =/ false는 boolean
                    console.log('' == false);         // true
                    console.log('' === false);        // false : ''은 string =/ false는 boolean
                    console.log(null == undefined);   // true
                    console.log(null === undefined);  // false : null과 undefined는 다른 자료형

       @ 연산자(manipulator)의 종류
          1) 비교 연산자
              : 두 변수의 값을 비교하여 조건식을 만들 때 사용하는 연산자로, 실제 그 두 변수의 비교 관계가 연산자가 나타내는 범위에 해당됨에 따라 참 또는 거짓을 반환하는 연산자
                
                a. == (동등 연산자)
                    : (자료형이 다르면 형변환을 한 뒤) 2개의 변수의 값이 같은지 비교

                b. === (일치 연산자)
                    : 2개의 변수의 값과 '자료형'이 모두 같은지 비교
                        -> (중요) ==, === 둘의 차이는 일치여부 기준이 단순 내용만 같은지 보냐(==)? 아니면 자료형까지 같아야 하나(===)? 에 있다
                c. != 
                    : (자료형이 다르면 형변환을 한 뒤) 2개의 변수의 값이  다른지 비교

                d. !==
                    : 2개의 변수의 값과 '자료형'이 모두 다른지 비교
                        -> (중요) !=, !== 둘의 차이는 일치여부 기준이 단순 내용만 다른지 보냐(!=)? 아니면 자료형까지 달라야 하나(!==)? 에 있다

                e. >   : 왼쪽의 변수가 오른쪽의 변수보다 크기가 큰 지 비교
                f. <   : 왼쪽의 변수가 오른쪽의 변수보다 크기가 작은지 비교
                g. >=  : 왼쪽의 변수가 오른쪽의 변수보다 크거나 같은지 비교
                h. <=  : 왼쪽의 변수가 오른쪽의 변수보다 작거나 같은지 비교
          
          2) 논리 연산자
              : 어떤 조건문의 true/false 결과를 toogle 시키는 여집합을 의미하는 NOT의 의미를 걸거나, 2개 이상의 조건문에 AND, OR 관계를 부여하여 '복합 조건문'을 만들기 위해 사용하는 연산자
                  -> (참고) 조건문의 실행을 효율적으로 하기 위해 || &&를 사용하기도 한다

                a. && (AND)
                    : 2개의 조건문에 AND조건을 부여할 떄 사용

                     # (참고) && 연산자를 사용하는 경우, 무거운 연산의 논리변수 및 함수는 가급적 뒤에다 두는게 효율적임
                         -> why? AND 논리연산상 둘 중 하나라도 FALSE면 무조건 TRUE
                            (= JS엔진도 복합 조건문을 판별할 떄, &&가 보일 때 FALSE가 앞쪽에 감지되면, 그 뒤는 오류가 나던 말던 조건문을 보지 않음)

                b. || (OR)
                    : 2개의 조건문에 OR조건을 부여할 떄 사용

                     # (참고) || 연산자를 사용하는 경우, 무거운 연산의 논리변수 및 함수는 가급적 뒤에다 두는게 효율적임
                         -> why? OR 논리연산상 둘 중 하나라도 TRUE면 무조건 TRUE
                            (= JS엔진도 복합 조건문을 판별할 떄, ||가 보일 때 TRUE가 앞쪽에 감지되면, 그 뒤는 오류가 나던 말던 조건문을 보지 않음)

                c. ! (NOT)
                    : 여떤 조건문의 여집합에 해당하는 boolean값을 출력하는 NOT의 의미를 부여할 떄 사용

        3) 삼항 연산자(ternary operator) '?'
            : 어떤 조건문의 결과가 '참(True)' 또는 '거짓(False)'인지를 판별하고, 그에 따라 '?' 연산자 뒤에 존재하는 :를 기준으로 나뉜 값을 다르게 반환하라는 용도의 연산자
                -> (문법)
                     : 조건식 ? value1 : value2;

                       ex) name이라는 변수의 값과 자료형이 'ellie'라는 string 값과 같으면, 'yes' 다르면 'no'를 반환 
                       
                           console.log(name === 'ellie' ? 'yes' : 'no');

     @ JS에서 null 처리 관련 사용 가능한 조건 연산자
        : ES2020 ~ 21에 등장한 신기능으로 변수나 {객체}의 값이 null, NAN, undefined인 경우 일어날 수 있는 같은 에러를 피해서, 안전하게 데이터를 꺼내기 위해 사용하는 변수와 사용하는 연산자들
          (= 쉽게 말해, 복잡한 양식이나 경우에 따라 null문제로 에러가 생길 수 있는 {객체}에 대한  null, NAN, undefined 처리를 하기 싫어서 사용하는 3항 연산자의 null 여부 처리 응용버전이라 생각하면 편함)

          1) 옵셔널 체이닝 연산자 '?' (optional chaining operator)
              : 어떤 {객체}나 그 내부의 {객체 프로퍼티}가 null, NAN, undefined로 들어올 위험이 있는 경우 '?'를 붙이는데, 해당 {객체}에 해당하는 요소가 null 혹은 undefined로 밝히지면, 더 내부로 파고들지 말고 undefined로 남겨달라는 의미의 연산자
                -> (참고) '?'는 에러를 해결해주는 문법이 아니라 에러나지 않게 감추는 문법일 뿐
  
                   ex) {user} 내부에 {age1}라는 객체가 존재하지 않는데, 이 경우 '?'를 써주면 {age1}라는 프로퍼티가 없는걸 판별하고 undefined를 출력함 
                   
                       var user = {
                           name : 'kim',
                           age : { value : 20 }
                       }
       
                       console.log(user.age1.value1);    <- 에러나는 코드... null처리를 해주면 된다지만 귀찮..
                       console.log(user.age1?.value1);   <- null 에러시, 여차하면 undefined가 출력함
  

          2) 널리쉬 콜레싱 연산자 '??' (nullish coalescing operator)
              : 옵셔널 체이닝 연산자와 유사하지만, 이 연산자가 붙여진 변수가 null인 경우 오른쪽에 미리 지정한 '문자열'을 보여주라는 의미의 '??' 연산자
                (= 옵셔널 체이닝 연산자의 발전형으로 보통 프론트엔드 라이브러리나 프레임워크를 사용한 웹서비스에서 ajax 요청이 늦게 도착할 경우, 유저에게 undefined 안 보여주기 위하여 사용됨)
                    -> (문법)
                         : 변수명 ?? '해당 변수명이 null에 해당하는 경우 보여줄 문자열';

                           ex) {user} 내부에 {age1}라는 객체가 존재하지 않는데, 이 경우 '?'를 써주면 {age1}라는 프로퍼티가 없는걸 판별하고 undefined를 출력함 
                           
                               var user = {
                                   name : 'kim',
                                   age : { value : 20 }
                               }
                  
                               console.log(user.age1?.value1?? '좀만 기다려라');    <- '좀만 기다려라' 라는 문구로 모든 null처리 가능

     @ JS에서 사용 가능한 기본 조건문의 종류 
     
        1) if ~ else if ~ else 구문
            : if를 시작으로 else if까지는 상단에 놓인 구문의 ()안의 조건식을 실행하여, true로 판명되면 해당 {}를 실행하고 나머지는 다 무시함... 아무것도 해당하지 않으면 else {}로 실행
               -> 조건문 중에 우선순위를 정하고, 그만한 순위를 상단에 올리면 됨

                  ex) name이란 변수가 무엇이냐에 따라 분기가 결정되며, 일단 상단부터 true에 해당하는 조건문이 발견되면, 해당 {}를 실행하고 조건문을 빠져나옴
                  
                      const name = 'df';
                      
                      if (name === 'ellie') {
                        console.log('Welcome, Ellie!');
                      } else if (name === 'coder') {
                        console.log('You are amazing coder');
                      } else {
                        console.log('unkwnon');
                      }

        2) Switch case 구문
            : ()안의 값에 따라 분기가 결정.. 없으면 'default'로..
               -> (주의) break; 구문을 빼먹으면, 그 밑의 case들도 실행됨

                  ex) browser 변수의 값에 따라 case 분기 결정
                      
                      const browser = 'IE';
                      
                      switch (browser) {
                        case 'IE':
                          console.log('go away!');
                          break;
                        case 'Chrome':
                        case 'Firefox':
                          console.log('love you!');
                          break;
                        default:
                          console.log('same all!');
                          break;
                      }


  5. 반복문

     @ JS에서 사용 가능한 기본적 반복문의 종류 

        1) for문
            : 가장 유명한 반복문에 해당하는 구문으로 ;을 기준을 1번째는 index시작값 2번째는 종료조건에 해당하는 조건문 3번째는 index의 증감수준을 연산자로 지정함
               -> (문법)
                    : for(시작값; 조건문; 증감식)
                       -> 2번째의 조건문과 3번째의 증감 수준 지정은 창의력을 발휘하면 기상천외한 물건도 나옴 

                          ex) 가장 단순한 구조의 for문
                          
                              for (i = 3; i > 0; i--) {
                                console.log(`for: ${i}`);
                              }


             # nested loops (중첩 for문)
                : 말 그대로 for문 안에 또 for문에 해당하는 {}가 존재하는 내용

                  ex) ''가 아닌 ``으로 문자 템플릿(literal template)을 사용하여 2중 for문으로 문자열 찍는 코드
                  
                      for (let i = 0; i < 10; i++) {
                        for (let j = 0; j < 10; j++) {
                          console.log(`i: ${i}, j:${j}`);
                        }
                      }

        2) while문
            : 내용이 조건에 true값이 나올때까지 반복함

              ex) let i = 3;
                  
                  while (i > 0) {
                    console.log(`while: ${i}`);
                    i--;
                  }


        3) do ~ while문
            : while과 같지만, do안의 내용을 먼저 시작하고, while구문 진행

              ex) 일단 console.log(`do while: ${i}`)를 시작하고, i변수의 증감 연산자를 통한 연산도 1번은 실행한 뒤, while문에 진입

                  do {
                    console.log(`do while: ${i}`);
                    i--;
                  } while (i > 0);


     @ 반복문과 조건문이 같이 쓰일 경우 사용하는 break, continue
        : 반복문과 조건문이 같이 쓰일 경우, 조건문의 결과에 따라.. 해당 루프의 {}를 빠져나올지, 반복문 전체의 {}를 빠져나올지를 정하는 예약어

           1) break   
               : 그 자리에서 반복문을 멈추도록 하는 예약어

                 ex) index에 해당하는 값이 9이상이 되는 순간 반복문 전체를 중단하고 반복문의 {}를 빠져나와 코드를 진행

                     for (let i = 0; i < 11; i++) {
                       if (i > 8) {
                         break;
                       }
                       console.log(`q2. ${i}`);
                     }

            2) continue 
                : 현재의 반복 싸이클을 skip하고, 다음 반복 싸이클로 넘어가서 반복문을 계속 수행하라고 하는 예약어

                  ex) index에 해당하는 값의 2로 나눈 나머지가 0이면 해당 반복문 루프를 전체를 중단하고, 다음 반복 싸이클을 진행

                      for (let i = 0; i < 11; i++) {
                        if (i % 2 === 0) {
                          continue;
                        }
                        console.log(`q1. ${i}`);
                      }



-> 작성 필요


   {객체} 생성자, prototype 상속, ES6 class, _proto_,  getter seteer, extend/super

   구조분해

   모듈 시스템

   promise
   콜백대체(then ~ catch, asycn/await)

   비동기처리(macro quote, micro quote)

   웹브라우저의 stack/quote

   캔버스 api

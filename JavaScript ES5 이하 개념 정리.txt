[JavaScript 기초 정리 (= ES5 이하 정리)]

 - JavaScript
    : 정적인 마크업 언어인 HTML을 웹 브라우저에서 동적으로 조작 및 변경을 목적으로 제작된 '약(weak)타입' + '동적타입'을 사용하는 '인터프리터 프로그래밍' 언어
       -> But 요즘에는 node.js라고 브라우저 이외의 JS를 실행가능하게 하는 런타임 환경이 등장하고, 이걸로 웹서버로 백엔드를 실행가능하게 하는 상황까지 왔음

          @ (중요) JS의 특징
             1. 인터프리터 언어(Interpreter Language)
             2. 자료형이 프로그램이 실행되는 '런타임' 시 결정되는 동적 타입(dynamic type) 언어
             3. 함수(fuction)는 '1급 객체((first-class object)'로서 또한 언어 내부에서 '값'으로 표현되고 전달될 수 있는 자료형 중 하나로 취급
                 -> 이같은 특성을 기반으로 다른 함수의 paramter로 사용하거나 return문에서 반환할 수 있는 '고차 함수(first-class object)'를 JS에서 사용 가능
             4. 기본적으로 싱글 쓰레드(single thread)만 사용
             5. {객체}간 상속 관계는 프로토타입(prototype) 기반 구조

          @ (참고) 프로그래밍 언어 분류 기준들
             1. '실행방식'에 따른 프로그래밍 언어 분류
                 1) 인터프리트 언어(Interpreter Language)
                     : 실시간으로 컴퓨터가 소스를 1줄씩 읽고 해석해서 실행하는 방식
                        -> (장점) : 실행을 시키는 과정 자체는 간단함
                           (단점) : 컴퓨터가 소스를 읽고 해석하니까 느리다
              
                 2) 컴파일 언어(Compiled Language)
                     : 사전에 소스를 파싱(parsing)하여 컴퓨터 잘 아는 저수준 언어로 변환한 뒤 한번에 실행
                        -> (장점) : 사람이 적은 코드를 분석/검사하여 컴파일하는 시간이 있으니, 용량이 클수록 실행까지 꽤 시간이 소요되며 메모리도 좀 필요함 
                           (단점) : 성능은 매우 빠르며, 코드에 문제가 있으면 컴파일이 이뤄지지 않아서 신뢰성 측면에서 도움이 됨 
            
             2. '데이터 타입'에 따른 프로그래밍 언어 분류
                 1) 정적 타입 언어(static type)
                     : 어떤 변수의 자료형이 '컴파일' 시에 결정되기에 확실하게 자료형을 지정해야 하는 언어 (= 일단 해당되는 언어는 컴파일 언어)
                        -> (장점)
                             a. 자료형이 확실하게 정해져있기에, 실행 이후 자료형으로 인한 돌발상황 대처와 추론이 쉬움
                             b. 컴파일 과정에서 미리 자료형이 정해져 있어, 성능 측면에서 유리함
                             c. 문제가 있으면, 컴파일 과정에서 고치기도 쉬움
         
                           (단점)
                             : 변수가 받을 자료형이 고정되는 셈이라, 유연성은 매우 떨어짐
              
                 2) 동적 타입 언어(dynamic type)
                     : 어떤 변수의 자료형이 프로그램이 실행되는 '런타임' 시 결정되는 언어
                        -> (장점) : 변수의 자료형이 동적으로 변화가 가능하기에, 유연하게 프로그램이 실행 가능
                           (단점) : 자료형이 런타임 시 유연하게 결정되기 때문에, 문제가 생기면 그 떄 가봐야 알 수 밖에 없음
         
             3. '암묵적인 데이터 타입 변환(Type Casting 또는 Type Conversion) 가능 여부'에 따른 프로그래밍 언어 분류
                 1) 강타입 언어(strong type)
                     : 다른 데이터 타입끼리의 변환이 엄격하게 금지되어 있는 프로그래밍 언어
                       (= 정말 극단적이면 연산자 및 함수의 parameter로서 사용되는 변수의 데이터 타입이 선언된것과 다르면 바로 에러를 발생시킴)
         
                 2) 약타입 언어(weak type)
                     : 다른 데이터 타입끼리의 변환이 가능하며, 심지어 암묵적으로 변환을 해주기도 하는 프로그래밍 언어
                       (= 정말 극단적이면 데이터 타입이 의미가 없다 느껴질 정도로 암묵적으로 변환을 해주는 범위가 넓을수도 있음)


자바스크립트는 html 조작하는 언어라고 했습니다.

근데 조작할 html이 위쪽에 있어야 조작이 잘 됩니다.

자바스크립트를 조작할 html 위에 작성하면 안됩니다.

왜냐면 컴퓨터가 html 파일을 읽을 때 위에서 부터 한줄한줄 읽는데

미리 html을 읽어놔야 조작이 가능하기 때문입니다.



 - JavaScript 문법들

  0. window객체 & global객체
      : 

  1. 변수(variable) & 상수(constant)

     @ JS변수(variable) & 상수(constant)의 특성
        1) 동적 타입 언어(dynamic type)이기에 변수의 자료형에 해당하는 부분은 딱히 존재하지 않고 1~2개(var, let)로 통일 
            -> BUT'값'의 자료형은 존재함... 단지 2)로 인해 casting이 ㅈㄴ 유연해서 그렇지

        2) 엄청난 약타입 언어(very weak type)로서, 자동 형변환(casting)이 매우 유연하게 암묵적으로 이뤄지기까지함

     @ 스코프(scope) {} 개념
        : 변수의 영역을 설정해주는 일종의 경계이자 결계로 생각하면 되며, function, {객체}, 조건문, 반복문 등등을 사용할 때도 활용됨
           -> 이 결계는 '일종의 특수거울'과 같이 '안에서는 밖을 볼 수 있고, 밖에서는 안을 볼수 없음
               -> 이 결계를 기준으로 밖에서 선언된 변수는 최상위 global scope에 존재한다면 전역변수(global객체 or window객체의 프로퍼티에 해당), 안에서 선언된 변수는 지역변수의 논리가 통용
                         
     @ JS의 변수(variable)
        : 어떤 값을 할당 가능하며, 읽고/쓰기(= rw(read/write)) 가능한 녀석을 의미
       
          1) (ES6 이전) var
              : ES6 이전에 쓰이던 '함수 스코프' 를 기반으로 하는 변수
                (= 함수 스코프{} 만을 기준으로 변수의 영역을 구분하고, 각 영역마다 존재하는 모든 var는 각 함수{}를 기준으로 최상단에 '호이스팅' 됨)

                # var 변수 만의 특징
                   1. 함수 스코프 {}가 영역의 기준
                   2. 동일 var변수 재선언 가능
                       -> 어차피 var 나이; 하나 호이스팅 하고, 나머지는 var를 때서 코드 실행 하여 최종값을 사용함

                          ex) 어차피 최상단 호이스팅 된 var나이;를 제외하면, 나머지는 호출의 형태가 됨
                          
                              var 나이 = 'xx';
                              var 나이 = null;

                   3. 함수 스코프 {}를 기준으로 var변수의 영역들을 판별하면, hoisting(호이스팅) 처리를 해줌
                      (= 오직 함수 스코프 {}만 기준으로 삼음)

                # hoisting(호이스팅)
                   : var나 function의 경우 아래에서 선언한 것들이 실행단계에서 최상단에 올라와서 일괄적으로 선언되는 현상
                      -> (중요) let도 호이스팅이 발생...
                           -> BUT! {블록스코프} 개념을 TDZ설정으로 선언 위치와 사용 위치 관계 정립하여 해결

                # function scope (함수 스코프)
                   : 변수의 영역을 정하는 스코프{}의 영역 개념이 function의 경우에만 통용되는 개념
                       -> 함수 스코프 기준으로 지역변수 개념? function의 {}내에서만 통용됨
                          (= var의 호이스팅이 의도치 않게 문제를 만드는 이유)

                          ex) '이름'이라는 var변수는 함수 스코프 {}안에 있어, 호이스팅이 되어도 함수 {}안에 존재

                              function 함수(){
                                var 이름 = 'Kim';
                                console.log(이름); // kim
                              }
                              
                              console.log(이름);   // 에러
                             
                          ex) '이름'이라는 var변수는 조건문 스코프 {}안에 있어, 이를 무시하고 상위 {}로 호이스팅 됨

                               if ( 1 == 1 ){
                                 let 이름 = 'Kim';
                                 console.log(이름); // kim
                               }
                               
                               console.log(이름);   // kim

                # (중요) var의 hoisting(호이스팅)의 특이성
                    : var의 경우 함수의 스코프{} 만을 변수 영역 구분의 기준으로 삼음
                      (= var의 호이스팅은 '조건문'이나 '반복문'의 스코프{}는 깡그리 무시해 버림 )
                          -> (중요) function 여부에 제한받지 않고, 어떤 스코프{}라도 영역 기준으로 인정해주는 변수 let이 등장한 이유

                             ex) var hoisting의 황당함 예시1
                                  -> age변수의 선언보다 사용 시점이 빠름에도 인식이 문제없음
                                     (사실 var age; 부분은 실행 시점에서 맨 위로 올라감)
                             
                                      age = 4;          // 변수 사용이
                                      var age;          // 선언 시점보다 빠르다... (이 녀석이 호이스팅 됨)
                                      console.log(age); // 4  <- 근데 문제없이 인식했다?! 

                             ex) var hoisting의 황당함 예시2
                                  -> age변수를 감싸는 {}이 존재함에도, 이를 무시하고 상위스코프로 호이스팅 해버림
                                     (여전히 var age; 부분은 실행 시점에서 {}를 무시하고 더 위로 올라감)

                                      {
                                        age = 4;          // 변수 사용이
                                        var age;          // 선언 시점보다 빠르다... (이 녀석이 호이스팅 됨)
                                      }

                                      console.log(age); // 4  <- 근데 문제없이 인식했다?! 

                             ex) var hoisting의 황당함 예시3
                                  -> 반복문의 index에 해당하는 변수 i는 모든 반복에 대해 반복문 스코프{}가 아닌 상위 스코프{}에 var i라는 동일한 변수를 참조함
                                     (사실 var i; 부분은 실행 시점에서 맨 위로 올라가고, setTimeout을 통해 1초 후 반복문들을 코드를 실행하는 시점에서는 이미 반복이 끝나 i = 5가 들어가 있음)

                                     for (var i = 0; i < 5; i++) {
                                         setTimeout(function() {
                                             console.log(i);          // 5 5 5 5 5 출력
                                         }, 1000);
                                     }

          2) (ES6 이후) let
               : ES6에 추가된 '블록 스코프'를 기반으로 하는 변수 
                 (= 함수 스코프 {}만을 영역의 기준으로 삼고 hoisting을 일삼던 상식을 벗아나는 var변수의 약점을 일반적 언어의 변수들의 원칙이 적용되는 방향으로 보완)

                # let 변수 만의 특징
                   1. var의 문제점을 보완하기 위해 탄생
                      (= var는 '함수 스코프'를 기반으로 하며, 이 부분으로 인해 hoisting 이슈가 발생)

                   2. 동일 var변수 재선언 불가능

                      ex) 이러면 닥치고 에러 발생함
                      
                          let 나이 = 'xx';
                          let 나이 = null;

                   3. for, if, function에 제한되지 않고, 어디에서라도 {}를 기준으로 한 블록 스코프 {}를 기준으로 변수들의 영역을 판별함
                      (= 모든 {}가 let의 범위를 따지는 영역의 기준)

                   4. TDZ개념을 도입하여, 변수를 선언하기 이전에 사용을 할수 없다는 원칙을 구현
                      (TDZ : Temperary Dead Zone의 약자로, 해당 스코프에서 변수 선언 위치 이전 영역을 의미함)
                        -> let의 경우 변수 선언 이전에 사용을 하게 되면, error를 호출

                # block scope (블록 스코프)
                   : {}로 직접 변수들이 통용되는 영역 구분을 위한 '결계'와 같은 영역을 설정


     @ JS의 상수(constant) const
        : 어떤 값을 일단 한번 할당히면, 오직 읽기(= r(read))만 가능한 녀석을 의미 
          (= const로 선언된 상수에는 '값'의 재할당이 불가능함)

         # 상수(constant)를 쓰는 이유(장점)
            : '값'의 재할당이 불가능하다는 부분에서 장점이 존재

               1) 보안적으로 유리
               2) 복수의 쓰레드를 사용하는 경우, 동시다발적 접근으로 인해 프로그램이 개판되는 상황을 방지 가능
               3) 사람의 실수 가능성을 원천적으로 줄일 수 있음

         # const의 약점
            : const에 할당된 게 {객체}인 경우, 그 {객체}의 프로퍼티의 값들은 모두 재할당을 통한 변경 가능 
               -> WHY? {객체}는 엄밀하게는 heap영역의 메모리 영역을 참조값(reference)로 가지고 있을 뿐이고, const가 재할당 못하게하는 대상은 그 참조값이지 그 참조값이 가르키는 위치의 데이터들이 아님
                   -> {Object 객체}의 freeze()라는 메서드를 통해, ()안에 프로퍼티와 값들을 담으면 {frozen 객체}라고 내부 프로퍼티 값들의 재할당이 불가능하게 만들수는 있음
                       -> BUT! {frozen 객체}라도 또 그 내부의 프로퍼티의 값이 {객체}에 해당된다면, 그 {객체} 내부의 프로퍼티까지 freeze해주진 않음...
                          (= 추후 TypeScript에서 이 부분 자료형 정의에 힘쓰는 이유) 

  2. 자료형(types)
     : JS에서 인식하는 어떤 '값'을 해석하는 방식의 종류를 의미

        @ primitive (원시형)
           : number, string, boolean, null, undefined, symbol 과 같은 단일 변수
              -> (참고) 0, '', null, undefined, NaN, false는 JS에서는 자동 형변환(casting)을 통해 같은 값으로 인식

                 1) number
                     : integer(정수), decimal number(소수) 던 상관없이 하나로 통일
                
                      # 특수한 number값 유형
                         : infinity (양의 무한), -infinity (음의 무한), NaN (Not A Number : 숫자가 아닌데, 숫자로 출력해야 하는경우 나오는 값)
                
                      # (ES6 이후) bigInt 타입
                         : Java의 bigInt와 같이 기존 소수값 변수(자바의 경우 double)보다 더 큰 값을 표현가능한 변수타입

                 2) 'string'
                      : 문자에 대한 자료형으로 문자열의 경우는 배열개념으로 조합되어 있기에, 배열을 통해 원하는 위치의 문자를 찾는것이 가능
                 
                       # (ES6 이후) `template literals`
                           : `(백틱) 부호를 이용하여, 문자열을 입력 가능하게 하는 또 다른 방법이지만, ${JS변수명}과 같은 방식으로 JS변수를 문자열에 쉽게 가져올 수도 있도록 템플릿(template)적 요소와 기능을 추가함
                 
                             ex) helloBob를 출력해보면, 'hi brendan'으로 출력됨
                             
                                 const brendan = 'brendan';
                                 const helloBob = `hi ${brendan}!`;
                 3) boolean
                     : 참/거짓... 
                 
                 4) null
                     : null이라고 사용자가 선언한 경우에 할당되는 자료형 (undefined는 사용자는 개입한거 없는데 비어있을때 등장)
                 
                 5) undefined
                     : 값이 그냥 비었을경우 (null은 사용자가 null이라고 명시)
                 
                 6) (ES6 이후) Symbol
                     : 어떤 { Object } 자료형의 값에 공개되지 않은 비밀스런 key값(= 프로퍼티)를 부여할 필요가 있을 때 사용하는 자료형
                       (= 정확히는 Symbol 타입의 값 자체가 어떤 {객체}의 비밀스런 key값(= 프로퍼티)에만 해당하는 값에 포함됨)
                           -> for문이나 for in 같은 방법으로 해당 {객체}의 프로퍼티 순회시 이를 보여주지 않는 개념에 가까움
                              (= 캡슐화와 접근제어자 private를 썼을 때, 해당 프로퍼티에 외부 {객체}에서 접근이 불가능 한 것과는 전혀 다름)
             
                       # 어떤 {객체}에 Symbol에 해당하는 for문에 걸리지 않는 비밀스런 key값을 만들고 사용하는 방법

                         A. var, let 변수명 = Symbol('주석내용')
                             : 생성된 Symbol값을 변수에 할당받아서, 이를 어떤 {객체}의 비밀스런 key값(= 프로퍼티)으로서도 바로 할당될 수 있게 준비함

                         B. Symbol값이 할당된 '변수명'을 특정 {객체}의 '프러퍼티'에 접근하듯 사용한 뒤, value에 해당하는 값을 할당

                            a. 생선된 {객체}의 프로퍼티로서, '객체명[변수명]'으로 접근


                            b. {객체}를 생성할 때, Symbol값의 value값도 같이 입력
                                 -> {객체} 정의할 때, Symbol값을 프로퍼티로서 같이 입력하고 싶다면, { ... , [변수명] : value값} 이렇게 입력하자

                                    ex) var height = Symbol('내 키임');
                                        var person = { name : 'Kim', [height] : 160 };

                       # Symbol 타입값 관련 함수
                          : 새로운 Symbol값을 생성하면, 해당 Symbol값은 어떤 {객체}의 비밀스런 key값(= 프로퍼티)으로서도 바로 할당될 수 있음

                            a. Symbol('주석내용')
                                : Symbol 타입에 해당하는 값을 생성하는 생성자에 해당.. 
                                   -> BUT! '주석내용'과 관계없이, 각 Symbol() 생성자를 사용해서 생성된 Symbol값은 별개임
                                      (= class생성자를 사용해서 만든 {객체}와 유사함)
                          
                            b. Symbol.for('주석내용')
                                : 전역 Symbol 타입에 해당하는 값을 생성하는 생성자에 해당.. 
                                   -> BUT! '주석내용'이 같은 Symbol값은 같은 값으로 인정
                 
                       # Symbol 자료형의 주요 특징
                          a. 고유성
                              : 같은 '주석내용'이라도, 각각 Symbol() 생성자를 통해 생성한 Symbol 타입은 다른 Symbol로 인정
                                  -> obj[Symbol('mySymbol')] 식으로 Symbol() 생성자를 index처럼 직접 쓰지 못하고, 변수에 할당해서 쓰는 이유가 여기에 있음
                 
                                     ex) Symbol('주석내용')을 각각 사용해서 생성된 경우, '주석내용'이랑 상관없이 다른 Symbol값(= 다른 프로퍼티명)으로 인정됨
                                         (= class생성자를 사용해서 만든 {객체}와 유사함)
                 
                                         const symbol1 = Symbol('id');
                                         const symbol2 = Symbol('id');
                                         console.log(symbol1 === symbol2);    // false에 해당
                 
                          b. (중요) 전역 Symbol값의 존재
                              : Symbol.for('주석내용') 메서드를 통해 전역 Symbol을 만들 경우, '주석 내용'이 같을 경우 같은 Symbol값으로 인정됨
                 
                                ex) Symbol.for()를 통해 만들어진, 2개의 Symbol 타입 값은 같은 주석인 '설명1'을 가졌기에, 같은 Symbol값으로 인정됨
                 
                                    var a = Symbol.for('설명1');
                                    var b = Symbol.for('설명1');
                                    console.log(a === b);                    // true에 해당
                 
                          c. 공개되지 않는 프로퍼티(= 접근자체는 가능)
                              : for문으로 순회시 안 보일 뿐이지, '객체명[심볼명]'으로 접근이 가능하며, '객체명'으로도 볼수 있음
                                 -> 공개되지 않은 비밀스런 key값(= 프로퍼티)이기 때문
                 
                          d. 기본적으로 내장된 Symbol인 'Symbol.내장Symbol명'
                             (= {Object 객체}의 프로퍼티와 유사한 용도이나... 이미 존재하는 {Object 객체}를 손댈수는 없으니.. ES6부터 추가된 기능에 대해 Symbol로 이를 구현한 걸로 추측)
                              : JS에는 기본적으로 정의된 기본적인 Symbol 타입이 존재하며, 'Symbol.내장Symbol명' 형식으로 호출
                 
                                ex) Symbol.iterator
                                     : ES6에서 {객체}, [배열] 등의 iterable한 특성이 있는 {객체}의 기본 iterator를 정의하어, for of 반복문을 사용할 수 있도록 함
                                     
                                       ex) arr[Symbol.iterator]()로 arr라는 변수에 할당된 이터러블 객체에 해당하는 [배열]의 내장 Symbol로 정의된 iterator에 관련된 기능을 쓸 수 있게 함
                                       
                                           let arr = [1, 2, 3];
                                           let iterator = arr[Symbol.iterator]();
                                           console.log(iterator.next());          // { value: 1, done: false }

        @ {object(객체)}
            : 연관된 변수(= 프로퍼티)나 그 변수들을 조작하는 함수(= 메서드)들을 모아놓은 타입을 구현한 key와 value의 집합체인 데이터 구조에 해당하는 JS의 자료형 (!= Json)
              (= 여러가지의 데이터를 모아놓았기에 한번에 메모리에 할당하지 않고, 특정 힙(heap)영역에 데이터들을 저장하고 '변수명'에 해당되는 부분은 그 위치값를 참조값(reference)으로 저장하여 찾아갈 때 사용) 
                 -> (참고) JS에서는 함수도 '1급 객체(first-Class Citizen)'에 속하는 {객체}로서, 함수를 변수, return문, 함수의 인자로 할당 가능

  3. 함수(function)
      : 특정 기능에 해당하는 코드 묶음을 쉽게 불러와서 재사용하기 위해 스코프{}를 지정해놓고 모아서 모듈화해놓은 코드
         -> 엄밀하게 JS에서 함수는 {객체}에 해당하며, 심지어 '1급 객체'임

       @ (중요) 1급 시민 객체(First-Class Citizen)
          : JS에서 함수(fuction)는 '1급 객체(first-class object)'이기에 그에 따른 특성과 이점이 존재

             1) JS 언어 내부에서 '값'으로 표현되고 전달될 수 있는 자료형 중 하나로 취급되기에, 변수의 '값'으로서도 받을 수 있음
                  -> 이같은 특성을 기반으로 '다른 함수의 paramter(= 콜백함수)'로 사용하거나 return문에서 반환할 수 있는 '고차 함수(first-class object)'를 JS에서 사용 가능
            
             2) 엄연히 {객체}라는 점에서, 프로퍼티와 메서드를 가질 수 있음
                  -> 함수 {객체}의 프로퍼티에는 '지역변수', {}, 'closer 변수' 등등에 대한 정보가 모두 포함됨
                     (= 함수 {객체}를 변수에 할당하면 '함수 표현식' 형태가 되며, 그 변수는 해당 함수{객체}의 모든 정보를 가지고 있음)


       @ 전통적인 함수(function) 문법 사용법 (= 1급 시민 객체(First-Class Citizen) 개념이 없는 함수 선언식과 호출만 사용하는 패턴)
          : 프로시저 프로그래밍 패러다임에 따른 고전적인 함수 사용 방식
            (= JS에 1급 객체 함수적 특성은 1도 반영하지 않았을 경우의 함수 사용 패턴이라고 봐도 무방함)

             1) 함수 선언(function declaration)
                 : 재사용 하길 원하는 코드들을 모으고 {}안에 묶은 뒤, 이를 어떤 이름으로 호출할 것인지에 대한 '함수명'을 명명하고, 그 앞에 해당 {}는 함수임을 알리는 function이란 예약어를 작성
                    -> 해당 함수(function)를 상황에 따라 동적으로 사용하고 싶다면, 함수 선언 시 동적인 역할을 수행할 코드에 사용된 변수에를 parameter로 넣을 수 있도록 ()안에 parameter 변수를 정의하고, 내용부에서 사용함
                 
                       ex) '함수명'이란 함수 선언 예시
                       
                           function 함수명(... parmeter들){
                           
                             재사용을 하길 원하는 코드..
                             parameter에 해당하는 변수도 사용해도 됨
                           
                             return 영역  <- (생략해도 됨)
                           }
   
                  # 함수 선언(function declaration)과 호출만 존재하는 경우의 단점
                    a. 무조건 '함수명'이 필요함
                    b. 함수를 선언한 코드가 위치에 상관없이 무조건 최상단으로 호이스팅이 일어남
                        -> 작성 의도와는 다른 결과가 나올 수 있음
                        -> 그렇게 호이스팅 된 함수는 무조건 먼저 읽기 때문에, 함수 종류가 많아지면 성능에 문제 생김

             2) 함수(function) 호출
                 : 선언했던 함수의 '함수명'의 선언부에 해당하는 형식대로 '함수명(...argument들)'을 작성하면, 런타임 상황에서 해당 함수명의 내용부를 실행
                   (= 사용을 원하는 위치에 '함수명(...argument들)'을 작성하면 간단하게 원하는 코드를 재사용이 가능함)
                 
                   ex) '함수명'이란 함수 or 표현식 호출하기 + 결과값을 변수에 할당
                   
                        const result = 함수명(... argument들);
   
                  # (중요) 함수 선언(function declaration)과 호출만 존재하는 경우의 단점 (= 함수 표현식(fuction expression)의 이점)
                     : 함수가 호출(function call)되는 타이밍이 단순하면 상관없지만, 다른 함수들과 연계되어 타 함수들을 로직의 일부로서 사용하려고 들 때 상황에 맞게 동적으로 쓰기 힘들어짐
                       (= 함수 자체를 값으로 취급해서, 변수에 저장하거나 parameter의 argument로 사용하거나 return 할 수 있다면? 좀 더 유연하고 다양한 코딩 패턴의 가능성을 열어줄 수 있음)
                           -> 함수 표현식(function expression)의 사용 이유

                               ex) 함수를 동적으로 순차적 호출이 가능, 콜백함수를 동적으로 구성이 가능, 클로저 패턴을 사용 가능


       @ (중요) 함수 표현식(function expression) 
          : JS에서 함수(function)가 변수에 할당 가능한 값을 가진 {객체} 자료형에 해당하는 '1급 객체'라는 특성을 이용, 함수(function)을 변수에 할당하여 표현하는 광범위한 방식을 통칭
            (= 변수에 할당되는 함수는 기존에 선언된 함수일 수도 있고, 실행 타이밍이 되서야 알게되는 무명함수일 수도 있음!)

            a. 기존 선언된 함수를 변수에 할당하는 방식의 함수 표현식(function expression) 
               
               ex) 상단의 '함수명'이란 함수가 선언되고, 이를 변수명이 표현식으로 할당한 경우, 변수명(...parameters);는 그 함수를 호출하는 구문이 됨
               
                   var 변수명 = 함수명;

                   변수명(...argument);
            
            b. 무명함수를 변수에 할당하는 방식의 함수 표현식(function expression) 
                : 재사용 하길 원하는 코드들을 모으고 {}안에 묶고 그 앞에 해당 {}는 함수임을 알리는 function이란 예약어를 작성하는 것까지는 같지만, '함수명'을 명명하지 않는 무명함수 방식으로 변수에 할당하여 작성     
                   -> 마찬가지로 parameter를 넣을 수 있도록 ()안에 parameter 변수를 정의하고, 내용부에서 사용하면 해당 함수를 상황에 따라 유연하게 적용 가능            
            
                      ex) greet라는 변수에 무명함수가 할당된 '함수 표현식' 형식 예시
           
                          const 함수명 = function(... parmeter들){
           
                            재사용을 하길 원하는 코드..
                            parameter에 해당하는 변수도 사용해도 됨
                          
                            return 영역  <- (생략해도 됨)
                          };

            # 함수 표현식(function expression)을 사용하는 이유 및 이점?
               : 단순히 선언된 함수만 변수에 대입하는 것으로는 별 쓸모 없지만... 
                  -> {객체} 값으로서 활용가능한 '1급 객체'로서, '고차함수'로서 사용이 가능한 JS 함수의 특성에 따른 유연성 및 확장성에 대한 포텐셜을 극강으로 끌어올릴 수가 있음
                      (= 그 자체로도 '1급 객체'로서의 함수의 특성이 있기에 존속이 가능하나, = 함수를 argument값이나 return값으로 사용하는 '고차함수' 개념까지 연계되면 활용도와 유연성이 정말 높아짐)
    
                      ex) 함수를 동적으로 순차적 호출이 가능, 콜백함수를 동적으로 구성이 가능, 클로저 패턴을 사용 가능

       @ 함수 선언(function declare) VS  함수 표현식(function expression)
          : 함수 표현식(function expression) 개념은 함수 선언(function declare)과 양립 불가능하지 않음!
            (= 오히려 '1급 객체'로서 함수의 특성을 극한으로 이용하여, 선언된 함수를 더 유연하게 쓰이게 하거나, 더 고차원적인 패턴으로 활용할 수 있음을 의미함)
          
             1. 호이스팅(Hoisting) 여부
                 : 함수의 선언 및 작성 위치와 상관없이, 프로그램이 코드 실행전 무조건 코드의 가장 최상위로 올려두는지 여부
                   (= 대충 var와 let의 관계와 유사)
                    -> 원본 코드의 실행 순서대로의 전개가 전혀 달라질 수 있는 사안이 될 수 있음
   
                  a. 함수 선언 (Function Declaration)
                      : 코드 실행 전에 최상단에 호이스팅 됨
                        (= 무조건 함수 호출부에서 함수를 발견하지 못하는 문제가 생기지 않도록 만듦)
   
                  b. 함수 표현식 (Function expression)
                      : 호이스팅과 전혀 관계가 X
                        (= 어떤 변수에 함수를 할당하는 함수 표현식의 형태의 경우 코드가 실행되는 시점에 함수가 정의되기에, 함수의 호출은 함수의 변수 할당 이후에만 호출이 가능)
   
                    # (중요) 만약 'var 변수'로 '함수 표현식'에 해당하는 할당을 받는다면?
                        : var변수의 호이스팅 원칙이 먼저 적용되어서, var 변수명; 상태로 호이스팅 되고, 함수가 할당되기 전까지는 undefine 값으로 출력되게 됨
   
                          ex) var변수의 호이스팅 결과로 var sayHello = ''; 코드가 최상단에 위치하는 효과를 낳게 됨
   
                              console.log(sayHello);  // Output: undefined
                              sayHello();             // TypeError: sayHello is not a function
                              
                              var sayHello = function() {
                                  console.log("Hello!");
                              };
                              
                              sayHello();             // Output: "Hello!"
   
             2. 무명 함수(anomyous function) 사용 가능 여부
   
                  a. 함수 선언 (Function Declaration)
                      : '함수명'은 무조건 설정되어야 함
   
                  b. 함수 표현식 (Function expression)
                      : '기존 선언 함수' 말고도 '무명 함수' 또한 변수에 할당이 가능함
                        (= 변수를 통해 단순히 선언된 함수를 받아주는 수준이 아니라, 그 변수 자체가 할당된 무명함수를 통해 선언된 함수처럼 기능하면서 더 유연한 사용이 가능)

       @ (중요) 함수 호출(function call) VS {객체}값으로서의 함수
           : 작성에 있어.. 아주 약간의 차이가 있지만 그 의미는 어마무시하게 차이가 남
             (= 별 차이 없어 보이기에 작성하는 입장에서도 햇갈리고, 경우에 따라서는 코드를 읽는 입장에서도 해석을 잘못할 위험이 존재함)

             1) 함수 호출(function call)
                 : 어떤 함수를 정의된대로 argument를 넣고 실행하라는 명령어.. 반드시 '함수명(...argument)'와 같이 ()가 들어가며, 결과값은 호출된 함수의 {}의 return값을 가져옴
                    -> {}내에 window객체에 선언된 전역 변수를 변경하는 내용이 있다면, 이는 함수의 스택 프레임(stack frame)이 끝나도 반영되어 있음

                       ex) const result = 함수명(... argument들);
                            -> result는 함수명(... argument들)을 실행한 return값을 가짐
                                -> (중요) JS에서는 함수의 return값은 또 다른 함수도 가능하니.. '함수 호출 != return 함수' 라고 생각하면 안됨!
           
             2) '{객체}값'으로서의 함수 (!= 함수 포인터)
                  : 말 그대로 어떤 변수에 대입가능하고, 함수의 return값으로 반환도 가능한 선언된 스코프와 클로저와 같은 모든 맥락(context)를 가지고 있는 값으로서의 함수... '함수명'과 같이 ()를 쓰지 않고 사용함
                     -> (주의) '함수 포인터'와 유사한 개념이나 메모리 주소만을 저장하는 함수 포인터와는 다르게, {객체}값으로서의 함수는 맥락(context)에 해당하는 정보를 프로퍼티로 가지고 메서드 또한 가질 수 있음

                  # '{객체}값'으로서의 함수를 사용하는 경우의 이점?
                      a. 함수(function)을 변수에 할당하여 표현하는 함수 표현식(function expression)에 사용시 이점
                          : 단순히 선언된 함수만 변수에 대입하는 것으로는 별 쓸모 없음
                              -> if 대입되는 함수가 무명함수라던지... 
                              -> if 대입되는 함수의 return값이 또 다른 함수라던지 하는 경우가 있다면?
                                  -> 변수에 대입되는 함수를 동적으로 변환이 가능하기에, 같은 변수명으로도 동적으로 함수를 호출하는 것이 가능
                                     (= 함수를 argument값이나 return값으로 사용하는 경우와 시너지를 이룸)

                                     ex) const itself = 함수명;
                                          -> itself는 '함수명'이란 선언된 맥락(context)에 대한 모든 정보와 프로퍼티 메서드를 가지는 함수 {객체}를 저장

                                     ex) 무명함수를 변수에 대입하면, 사실상 함수 선언을 대체 가능
                                     
                                         const itself =  function(x) {
                                           return x*x
                                         }

                      b. 다른 함수 호출시 parameter자리에 argument값으로 사용시 이점
                          : 호출한 함수의 {}에서 argument값으로 보낸 함수를 parameter 변수에 넣어 동적으로 호출할 수 있도록 해줌
                             -> 함수{} 안에서 호출을 하던, 다른 함수를 호출시 parameter자리에 argument값으로 또 보내던, return값으로 보내던 다양하게 응용이 가능하게 함

                            ex) executeFunction의 parameter는 함수에 해당하고, 그 함수를 콜백함수로서 사용... 
                                 -> executeFunction(createFunction)의 경우 parameter에 해당하는 createFunction값 자체는 함수{} 안으로 해당 함수를 사용할 수 있게 함수 {객체}를 전달하며, 함수{} 안에서 createFunction()의 형태로 호출시킴 
                            
                                    function createFunction() {
                                       return function() {
                                           console.log("Hello, World!");
                                       };
                                    }
            
                                    function executeFunction(func) {
                                      func();
                                    }
            
                                    executeFunction(createFunction);

                      c. return값에 사용
                          : 함수의 결과로 어떤 함수를 반환하며, 이를 변수에 할당하면 함수 표현식(function expression)이 됨
                             -> 어떤 함수의 return값이 함수이고, 그 함수의 내용부가 해당 함수 {객체}가 저장하는 맥락(context)에서 자신을 호출한 함수{}의 프로퍼티와 연관이 되어 있다면?
                                 -> return된 함수를 받아주는 변수를 통해 함수 표현식이 완성되고, 그 표현식을 통해 함수가 호출되어 프로퍼티가 변동한다면, 상위 함수 호출이 끝나도 그 내부 프로퍼티는 계속 메모리에 할당된 일종의 {객체}의 캡슐화된 프로퍼티로서 메모리에 남아있게 하는 패턴을 사용 가능함
                                    (= 클로저(closer) 패턴)


                  # 클로저(closer) 패턴
                     : {객체}개념은 존재해도 이를 통제하는데 있어 캡슐화나 접근 제어자 개념이 없던 JS의 문제점을 극복하기 위하여.. 함수의 '1급 객체'로서의 특성을 활용하여 이를 구현함
                        -> 함수{} 내부의 변수를 프로퍼티로 return되는 함수를 메서드로서 활용할 수 있도록 설계하여, 캡슐화된 {객체}의 프로퍼티와 일종의 setter기능을 유사하게 구현한 패턴 
                           (= 본격 접근제어자가 ES6 이후 등장하기 전까지, 개발자들은 접근제어자 개념이 JS에서 필요할 시 이를 사용함)
                     

                           ex) 클로저(closer) 패턴 예시
                                -> createCounter라는 변수는 무명함수를 할당받는 표현식에 해당하는 함수를 할당받으면, return값은 그 내부 프러퍼티 count의 값을 증가시키는 함수 {객체}를 반환함
                                   (= createCounter 변수는 해당 무명함수의 {객체}가 가진 {}나 프로퍼티 정보를 모두 저장하게 됨)

                                -> 그 createCounter라는 함수 표현식을 호출하여 그 반환되는 함수를 counter라는 변수가 받으면, createCounter에 할당된 무명함수의 프로퍼티 count는 호출이 끝나도 계속 남아있음
                                   (= counter라는 변수는 createCounter에 할당된 해당 무명함수가 return한 다른 무명함수의 {객체}가 가진 {}나 프로퍼티 정보를 모두 저장하게 되기 떄문)

                                -> createCounter라는 함수 표현식이 호출될 때마다 count의 값은 1씩 증가함
                                   (= 애초에 createCounter, counter라는 변수들에 각자 할당된 함수 {객체}의 정보들을 기억하고 있어서 가능한 일)
                           
                                   const createCounter = function() {
                                       let count = 0;
                                   
                                       return function() {
                                           count++;
                                           return count;
                                       };
                                   };
                                   
                                   const counter = createCounter();
                                   
                                   // counter()는 createCounter에 할당된 무명함수의 return되는 무명함수를 호출하여 실행함 
                                   console.log(counter());  // Output: 1
                                   console.log(counter());  // Output: 2
                                   console.log(counter());  // Output: 3


       @ (중요) parameter(매개변수)와 argument(인자) 개념의 차이
          : 둘 다 함수의 내용부에 전달되는 데이터와 연관된 해당되는 개념들이지만, 함수를 '선언' 혹은 '호출' 하는지 여부에 따라 개념이 나뉨

           # parameter와 argument 공통점/차이점 
              1) 공통점
                  : 함수의 내용부에 전달되는 '인자'에 해당되는 개념 

              2) 차이점
                  a. parameter
                      : 함수를 '선언(declare)'할 때 내용부에 입력받을 값을 '전달하는 역할의 변수'에 해당

                  b. argument
                      : 함수를 '호출(call)'할 때 parameter자리에 입력되어, 함수의 내용부에 parameter 변수를 통해 전달될 '값' 그 자체를 의미

                        ex) greet란 함수 정의시 ()의 name이라는 parameter 변수가 존재하고, greet를 호출시 Alice와 Bob이 name이라는 parameter 변수에 전달되는 argument

                            function greet(name) {
                                console.log("Hello, " + name);
                            }

                            greet("Alice"); 
                            greet("Bob");   

           # parameter를 통해 argument가 함수에 전달되는 과점
              : 함수를 호출 시, parameter 변수에 argument가 할당되고, 그렇게 값을 할당받은 parameter는 이를 함수의 내용부에 전달하는 구조라고 보면 됨

                ex) 다음의 showDetails(x, y)라는 함수가 showDetails(10, 20)로 호출되면, 내용부에 'parameter = argument값' 이런식으로 정의되고 사용된다 생각하면 편함

                    function showDetails(x = 10, y = 20) {

                        let x = 10;
                        let y = 20;

                        console.log("x before assignment: ", x); // 10
                        console.log("y before assignment: ", y); // 20
                    }

       @ (중요) 콜백 함수(callback function)
          :


       @ 무명 함수(anomyous function)
          : 주로 '특정 상황'에서 '일회성'으로 사용되거나 즉시 실행되기 위해 정의되기에 함수명도 주기 귀찮아서 '함수명'이 형태로 사용이 가능한 함수
            (= 요컨데 재사용율이나 용도가 특정 용도나 함수와의 연계에 몰려있어, '함수명'을 써가면서 사전에 로딩할 필요도 없는 경우 사용하는 이름없는 함수)
                -> (중요) SO.. 특정 변수에 할당되는 '함수 표현식(expression)'과 다른 함수의 parameter자리에 argument로 전달되거나 return값으로 반환되는 '고차함수'로서 별 다른 절차 없이 간편하게 사용 가능

           # 무명 함수(anomyous function)가 주로 쓰이는 방식?
              : 함수 표현식(expression)에서 변수에 할당되거나, 타 함수를 호출시 parameter위치에 argument로 할당되는 '콜백함수'로 사용할 때 신속 간편하게 쓰임
                 -> 암튼, 선언하지 않고 사용이 가능하다는 이점에 집중

           # 즉시 실행 표현식 (IIFE)
              : {window 객체}에 해당하는 전역 {} 범위를 오염시키지 않는 무명 함수를 선언하자마자 즉시 실행되는 함수를 만드는 방법
                  -> 원래 단독으로 무명함수를 선언하는 경우에는 그것을 받아줘서 함수 표현식 형태로 유지해주는 변수가 있어야 호출이 가능하나... 
                      -> BUT! IIFE가 있으면 그냥 무명함수를 실행할 수도 있다는 말씀
                  
                         ex) IIFE 형식은 다음과 같은 형식으로 선언과 동시에 호출이 되는 구조
                           
                             ( function(){ 내용 } )(); 

                         ex) 직접적인 IIFE 예시
                         
                            (function() {
                                console.log("This IIFE executes immediately and encapsulates the code.");
                            })();
    
       @ arrow function(화살 함수)
          : ES6에서부터 함수를 보다 단순하게 표현하는 방법론에 해당하는 '람다 대수' 개념을 받아들여, '람다 표현식'에 해당하는 화살표(=>)를 이용해서 무명함수를 더 단순하게 작성할 수 있도록 개선한 문법
             -> (중요) arrow function(화살 함수) = '람다 표현식' = 무명함수를 작성하는 새로운 방식이나 다름없음 
                       (= 변수에 함수를 대입하는 '함수 표현식'과 아주 밀접한 관계를 이룸)
    
                # 기존 무명함수 선언식 -> arrow function(화살 함수) 작성법
                   1) function 예약어 대신 화살표(=>)를 함수의 몸체로 사용
                   2) 함수의 내용부가 1줄이면(= 단일 실행문) 괄호{}를 생략 가능
                       -> (주의) return문으로만 내용이 구성되어 있는 경우 {}는 생략 불가
                   
                           ex) function(...parameter){ 내용 }   ->   (...parameter) => { 내용 }

                # 즉시 실행 표현식 (IIFE)과 arrow function(화살 함수)
                   : arrow function(화살 함수)도 무명 함수이기도 하다보니, 거기에 ()로 감싸서 호출하면 그냥 무명함수 그 자체임

                     ex) arrow function(화살 함수)를 콜백함수로서 arrow function(화살 함수) 형식의 즉시 실행 표현식 (IIFE)의 parameter로 전달한 case 

                         (() => {
                              let message = "This is an IIFE using an arrow function";
                              console.log(message);
                         })();

                # arrow function(화살 함수) vs 무명 함수
                   1) function 대신 '->'를 사용한 간결하고 짧은 문법
                   2) (중요) this를 arrow function(화살 함수)의 내용부에 썼을 경우, 자신의 직속 상위 {}에 해당하는 {객체}를 의미하게 됨
                        -> arrow function(화살 함수)과 function을 쓰던 함수나 무명함수의 this는 의미가 달라짐

       @ (중요!) 모든 종류의 function에서의 this의 의미 정리
           : 기본적으로 this의 의미는 OOP에서 현재 {} 영역의 주제가 되는 {객체}를 의미
             (= 함수에서의 this 또한 해당 함수가 속한 {}영역의 주인이 되는 {객체}를 참조한다고 보면 쉬움)

             1) (중요) 어떤 {객체}의 메서드로서의 함수의 this
                 : 해당 메서드를 소유한 {객체}를 참조
                   (= 이 녀석의 function에서의 this의 중심이 된다고 봐도 무방)                               

             2) 독립된 전역 함수의 this
                 : JS에서 전역이라는 자체가 {window 객체} & {global} 객체를 참조함
                   (= 전역 함수라는거 자체가 {window 객체} & {global} 객체에 속한 메서드라고 봐도 무방함)
                       -> BUT! 엄격 모드(strict mode)에서는 undefined

                   ex) 전역함수의 this는 전역 객체(window)를 참조
                   
                       function sayHello() {
                           console.log(this);
                       }
                       
                       sayHello(); 
                        -> window 객체가 출력됨

             3) new 키워드를 사용한 어떤 class {객체}의 생성자(constructor)로서의 함수의 this
                 : 생성자가 생성한 {instance 객체}를 참조

                   ex) new Person('Bob')의 this = person 변수에 할당된 자신이 생성한 {객체 그 자신}
                   
                       function Person(name) {
                           this.name = name;
                       }
                       
                       const person = new Person('Bob');
                       console.log(person.name);
                         -> 'Bob'
   
             4) apply, call, bind 메서드
                 : parameter위치에 argument로 원하는 {객체}를 this로 설정 가능

                   ex) introduce라는 함수의 this를 obj라는 변수에 할당된 {객체}로 임의설정

                       function introduce() {
                           console.log(this.name);
                       }
                       
                       const obj = { name: 'Charlie' };
                       introduce.call(obj); 
                         -> Charlie

             5) function 무명함수의 this
                 : 무명함수가 선언된 위치에 따라 case by case로 달라짐
                   (= 호출 방식에 따라 this가 동적으로 결정될 수 있음)

             6) arrow function(화살 함수)의 this
                 : arrow function(화살 함수) 자신이 선언된 위치의 직속 상위 {}에 해당하는 {객체}를 정적으로 참조허고 절대 변경X
                   (= arrow function(화살 함수) 자신이 정의된 스코프에서의 this를 사용)

       @ 함수(function) 사용시 특이사항
          1) 함수명을 영어로 작명한다면? camelCase로 작명하는게 관습 
             (= kebab-case로 작성해도 기능에는 문제가 없음)

          2) 함수를 호출해서 실행하도록 하고 싶으면, '함수명()'와 같이 반드시 ()까지 같이 입력해 줌

          3) 함수 선언시 내용부를 마무리 시 return 문은 생략해도 상관은 없음
              -> 물론 생략한다고 해도, 프로그램은 내부적으로 return 0;과 같은 형태의 return문을 임의로 작성함

          4) JS에서 함수(fuction)는 '1급 객체(first-class object)'로서 또한 언어 내부에서 '값'으로 표현되고 전달될 수 있는 자료형 중 하나로 취급
              -> 함수(fuction)의 parameter에는 어떤 함수 그 자체가 parameter로 들어가거나 return 값이 되기도 하는 '고차 함수(first-class object)'로서 사용이 가능
                 (= parameter로 함수가 들어가 콜백함수나 return 값으로 사용될 수 있다는 건, 함수가 변수에 대입될 수 있다는 것)

          5) (중요) '함수명()'과 '함수명'은 명확히 다른 의미를 지님
               -> '함수명()'
                    : function인 함수명()을 호출하여, 그 내용부를 parameter 자리에 들어온 값을 대입해 실행하라는 의미

               -> '함수명'  
                    : function인 함수명()의 해당 함수 그 자체를 {객체}값으로 사용하는 방식 
                      (해당 함수가 어떤 함수의 콜백함수로서 parameter나 return값으로 쓰이는 '고차함수'나 변수에 할당하는 '함수 표현식'에 사용)

          6) (중요) this라는 키워드를 통해, 함수가 속한 {}를 관장하는 {객체}를 끌어다 쓸 수 있음





  4. 조건문

     @ 

  5. 조건문

     @ 
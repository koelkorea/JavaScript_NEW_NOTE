[JavaScript 기초 정리 (= ES5 이하 정리)]

 - JavaScript
    : 정적인 마크업 언어인 HTML을 웹 브라우저에서 동적으로 조작 및 변경을 목적으로 제작된 '약(weak)타입' + '동적타입'을 사용하는 '인터프리터 프로그래밍' 언어
       -> But 요즘에는 node.js라고 브라우저 이외의 JS를 실행가능하게 하는 런타임 환경이 등장하고, 이걸로 웹서버로 백엔드를 실행가능하게 하는 상황까지 왔음

     @ 실행방식에 따른 프로그래밍 언어 분류
        1. 인터프리트 언어(Interpreter Language)
            : 실시간으로 컴퓨터가 소스를 1줄씩 읽고 해석해서 실행하는 방식
               -> (장점) : 실행을 시키는 과정 자체는 간단함
                  (단점) : 컴퓨터가 소스를 읽고 해석하니까 느리다
     
        2. 컴파일 언어(Compiled Language)
            : 사전에 소스를 파싱(parsing)하여 컴퓨터 잘 아는 저수준 언어로 변환한 뒤 한번에 실행
               -> (장점) : 사람이 적은 코드를 분석/검사하여 컴파일하는 시간이 있으니, 용량이 클수록 실행까지 꽤 시간이 소요되며 메모리도 좀 필요함 
                  (단점) : 성능은 매우 빠르며, 코드에 문제가 있으면 컴파일이 이뤄지지 않아서 신뢰성 측면에서 도움이 됨 
    
     @ 데이터 타입에 따른 프로그래밍 언어 분류
        1. 정적 타입 언어(static type)
            : 어떤 변수의 자료형이 '컴파일' 시에 결정되기에 확실하게 자료형을 지정해야 하는 언어 (= 일단 해당되는 언어는 컴파일 언어)
               -> (장점)
                    a. 자료형이 확실하게 정해져있기에, 실행 이후 자료형으로 인한 돌발상황 대처와 추론이 쉬움
                    b. 컴파일 과정에서 미리 자료형이 정해져 있어, 성능 측면에서 유리함
                    c. 문제가 있으면, 컴파일 과정에서 고치기도 쉬움

                  (단점)
                    : 변수가 받을 자료형이 고정되는 셈이라, 유연성은 매우 떨어짐
     
        2. 동적 타입 언어(dynamic type)
            : 어떤 변수의 자료형이 프로그램이 실행되는 '런타임' 시 결정되는 언어
               -> (장점) : 변수의 자료형이 동적으로 변화가 가능하기에, 유연하게 프로그램이 실행 가능
                  (단점) : 자료형이 런타임 시 유연하게 결정되기 때문에, 문제가 생기면 그 떄 가봐야 알 수 밖에 없음
 
      @ 암묵적인 데이터 타입 변환(Type Casting 또는 Type Conversion) 가능 여부에 따른 프로그래밍 언어 분류
        1. 강타입 언어(strong type)
            : 다른 데이터 타입끼리의 변환이 엄격하게 금지되어 있는 프로그래밍 언어
              (= 정말 극단적이면 연산자 및 함수의 parameter로서 사용되는 변수의 데이터 타입이 선언된것과 다르면 바로 에러를 발생시킴)

        2. 약타입 언어(weak type)
            : 다른 데이터 타입끼리의 변환이 가능하며, 심지어 암묵적으로 변환을 해주기도 하는 프로그래밍 언어
              (= 정말 극단적이면 데이터 타입이 의미가 없다 느껴질 정도로 암묵적으로 변환을 해주는 범위가 넓을수도 있음)


 - WEB API
    : 웹표준에서 모든 웹 브라우저에서 제공하기로 표준화 되어 있는 기능을 의미
      (= WEB API에 명시된 기능을 API로 제공할 수 없는 브라우저는 제대로 된 브라우저가 아니라는 말씀)

     # WEB API와 JavaScript(= EMCA Script)의 관계
         : (중요) 분명 양쪽은 별개의 개념이지만! 애초에 JS자체가 브라우저에서 사용하기 위해 개발된 프로그래밍 언어 = WEB API는 JavaScript로 접근하고 사용할 수 있는 기능
            -> 브라우저 엔진은 JavaScript 엔진으로 일부가 구성되고, Web API는 JavaScript 엔진으로 구현됨
               (= 새로운 JavaScript 기능이 추가될 시, 이를 연계하여 Web API에 사용하면 여러가지 측면의 개선점을 보일 수 있음)

               ex) fetch API의 발전
                    : 무자비한 비동기 구문의 콜백지옥을 벗어나기 위한 ES6의 Promise 기능을 기반으로 WEB API에 새롭게 등장함
                       -> 이후 ES8에서 등장한 async/await를 fetch API에 사용가능하게 적용하여, 개발자 편의성과 만족도를 개선

     # WEB API의 종류
        : 매우 많지만, 대표적인거 몇가지 추리면 다음과 같음

          1. DOM API
              : HTML 및 XML 문서의 구조를 표현하고 조작하게 해주는 API (DOM 트리 탐색 및 수정)
  
          2. CSSOM API
              : CSS 스타일시트를 조작할 수 있게 해주는 API (CSSOM 트리 탐색 및 수정)
  
          3. Fetch API
              : Promise 문법 기반으로 제작되어, 비동기적으로 네트워크 요청을 더 쉽게 수행할 수 있게 해주는 API
  
          4. Web Storage API
              : 클라이언트 측에서 데이터를 로컬 및 세션에 저장하게 해주는 브라우저 내부의 저장소 관리용 API
  
          5. Canvas API
              : 브라우저 화면에 2D 그래픽을 그릴 수 있게 하며(= 2D 렌더링 컨텍스트), 프레임 단위로 동적인 환경에 반응하고 움직일 수 있는 무대를 제공하는 API
                 -> 극단적으로는 이걸로 게임도 만들 수 있으며, 기능을 확장해주는 라이브러리들도 많으니... 브라우저로 그래픽을 그리고 싶으면 참고해보기
  
          6. WebSocket API
              : client - server간 실시간 양방향 통신을 가능하게 해주는 WebSocket을 사용하게 해주는 API
  
          7. Geolocation API
              : 사용자의 위치 정보를 가져올 수 있게 해주는 API
  
          8. File API
              : 사용자가 로컬 파일을 웹 애플리케이션에 업로드하고 처리할 수 있게 해주는 API
  
          9. Web Audio API
              : 브라우저에서 <audio> 태그 이상의 기능으로 오디오를 복합적으로 제어하는 다양한 기능을 구현할 수 있도록 도와주는 API
                 -> Video나 WebRTC(Web Real-Time Communication) API에서도 사용하는 범용성이 높은 API

                    ex) 오디오에 이펙트를 추가, 소리 파형을 시각화
          
          10. WebRTC(Web Real-Time Communication) API
              : client - client 간 웹브라우저를 통해서, 별도의 중간 소프트웨어 없이 음성이나 영상 데이터 및 임의의 데이터를 포착하고 마음대로 재생하고 P2P로 교환할 수 있도록 하는 기술인 WebRTC를 사용하게 해주는 API
          
          11. Notification API 
              : 웹브라우저에서 사용자에게 알림 기능 구현시 이를 쉽게 가능하게 해주는 API

    # DOM(document object model) VS CSSOM(CSS object model)

      @ 공통점
         : 브라우저는 DOM tree를 참고하여 HTML구조를 잡고, CSSOM tree를 참고하여 styling을 하여 웹페이지의 랜더링(rendering)을 수행함
             -> 어쨌든 DOM과 CSSOM은 상호작용하여 웹페이지의 랜더링과 동적인 조작이 가능하게 함

      @ 차이점 (DOM트리와 CSSOM트리는 다를 수 있음을 암시)
         : 각 모델이 제어하는 객체와 목적이 차이점
            -> DOM(document object model) : HTML 요소들을 객체화시켜 트리 구조로 표현하여, 이를 JS로 조작하고 변경이 목적
            -> CSSOM(CSS object model)    : style sheet의 각각의 규칙들중 '화면에 들어가야 할 녀석'들만 render 객체화하여 트리 구조로 표현, 이를 조작하고 변경이 목적

 - (참고) 브라우저의 랜더링 과정
    : 브라우저의 랜더링 엔진이 웹페이지의 구체적인 렌더링을 담당하게 되며 다음과 같은 과정을 거침
      (DOM트리, CSS트리 -> Render 트리 ->  Render & Graphic 레이어 -> Layout 설정 -> 레이어 paint -> composite 레이어 -> GPU텍스처 이미지화 -> 택스터 랜더링)
        -> 이 모든 건, 브라우저가 C++로 제작되어 있기 때문에, 랜더링 쓰레드를 따로 쓸 수 있기에 가능한 것이라고 볼 수 있음

           1. 작성된 HTML문을 파싱, 각각의 Node로 구성되어 연결된 DOM트리를 구축하여 웹페이지 구조를 잡음
           2. CSS도 마찬가지로 파싱, 적혀있는 스타일 규칙들이 연결된 CSSOM트리를 구축
           3. CSSOM과 스타일규칙과 DOM의 Node들의 정보를 결합하여, Render Object(랜더 객체)로 구축된 Render Tree(랜더 트리)를 생성
 
           4. Render Tree의 내용 중 화면에 없는 요소라 쳐낼거 쳐내고, 최적화할거 최적화해서 Render Layer(랜더 레이어)를 완성
               -> display:none이 포함된 노드는 지우고, 상속적인 스타일은 부모노드에만 위치하게 설계하는 과정이 여기 들어감
                   -> (중요) display:none인 Node가 지워지기에 렌더트리와 DOM트리는 1:1 대응이 아니다!
  
           5. 만약, Render Layer(랜더 레이어)가 완성될 때 'GPU에서 처리되는 부분'이 있다면, 이 부분들은 강제적으로 Graphic Layer(그래픽 레이어)로 분리
               -> Grapic 레이어 부분은 GPU가 작업처리를 하기에, 결과적으로 멀티쓰레드적인 비동기처리를 하게 됨
                  (= 이 모든 건, 브라우저가 C++로 제작되어 있기 때문에, 랜더링 쓰레드를 따로 쓸 수 있기에 가능한 것)
 
                   ex) CSS3D / video & canvas / filter / animation/ transform : translateZ(0) 등
 
           6. (4, 5의 과정을 거쳐 만들어진) Render Layer(랜더레이어)을 기반으로 LayOut 설정
                -> 좌표는 보통 부모를 기준으로 설정
                -> 이 과정에서 CSS의 width, height, margin, padding 등의 HTML 요소의 공간과 연관된 속성을 처리함
                -> Global Layout은 브라우저 화면 크기를 늘리거나 폰트 사이즈가 커지면 변경
 
           7. Render Layer(랜더레이어)을 대상으로 paint(칠하기) = 레스터화
               -> 이 과정에서 CSS의 color 관련 속성을 처리해줌
 
           8. 만들어진 레이어(Render & Graphic Layer)들을 합쳐서, 복합 레이어(composite layer)로 만들고 표기하기
               -> 이 과정에서 CSS의 transform, opacity 속성을 처리해줌
 
           9. (8의 결과로) 각각의 레이어로부터 비트맵이 생성되고, GPU에 텍스처로 업로드..
               -> GPU 텍스처들은 서로 합쳐져 하나의 이미지로 렌더링되어 화면으로 출력되어 마무리


 - DOM(Document Object Model) API
    : 브라우저에서 표준적으로 기본 제공하는 WEB API 중 하나로, HTML 문서(document)의 구성 요소들을 읽고 파싱(parsing)하여서, JS로 조작이 가능한 {Node객체} 모델인 document객체로 표현해주고 그 요소들을 조작까지 가능하게 해주는 기능
      (= Node객체는 곧 {JS객체}로서의 특징을 모두 가지고 있다고 생각하면 됨)
          -> HTML 요소(element)를 노드(node)로 표현하고, 각 노드는 다른 노드와의 관계를 갖고 있는 tree로 표현되어 HTML 문서의 구조를 표현함
             (= 당장 HTML의 영역이라 볼 수 있는 document 또한 DOM조작을 통해 접근이 가능하며, 그렇기에 브라우저의 화면에 표현된 HTML이나 XML요소들을 조작이 가능)

    # document 객체
       : window 객체의 프로퍼티로 'DOM(Document Object Model) tree 구조로 표현된 HTML 문서에 대한 전체 정보'를 담고 있는 {Node객체}fh 웹 페이지 그 자체를 의미
         (= JS를 통해 현재 브라우저가 출력한 화면의 HTML요소를 접근하려면, 반드시 document 객체부터 호출해서 시작하고 메서드들을 호출해야 함)
             -> 특정 HTML요소를 DOM 객체 형식으로 호출하기 위한 메서드 = document 메소드들 중 DOM 셀렉터 메서드 

        @ (참고) document 객체 관련 참고사항
           1. document 객체는 window객체의 프로퍼티로 document = window.document에 해당함 
               -> Window 객체가 브라우저의 창에 해당하는 부분을 의미한다면, document 객체는 window객체 내부에 로드된 HTML문서(= document)를 의미
           2. document 객체 내부에는 DOM객체 형식으로 표현된 HTML요소를 지정하기 위한 DOM selector API에 해당하는 메서드(= DOM API)가 존재
           3. document 객체 자체는 해당 화면의 DOM tree의 root(= 뿌리)에 해당하는 부분으로 사실상 DOM객체로 변환된 화면 전체를 의미
               -> (중요) document객체의 root에 해당하는 부분은 <html> 태그

    # (참고) {유사 배열 객체}
        : index를 가지고, length 프로퍼티를 가지고 있어 순환이 가능한 iterable한 특성을 가지고 있는 {객체}지만, [배열]은 아닌 {객체}
          (= 일부 [배열]의 특성을 가지고 있는 {객체}를 의미)
         
         @ {유사 배열 객체} vs [배열]

            - (공통점)
                1. index를 가지고, length 프로퍼티를 가지고 있는 iterable한 특성을 가지고 있음
                2. iterable한 특성이 있어 반복문(스프레드 연산자, for ...of , Array.from() 등) 사용 가능함
        
            - (차이점)
                : map, forEach, reduce과 같은 [배열]의 메서드를 사용이 불가능함

    # {document 객체}의 메소드들
       : {document 객체} 내부의 메서드들에 해당하며, API 호출은 'document.메서드명(파라미터)' 식으로 호출함

      1. DOM 객체 요소 검색 메서드
          : 브라우저에서 표준적으로 기본 제공하는 WEB API 중 하나로, JS문법을 사용하여 DOM(document object model) 형태로 표현된 document객체에 있는 화면의 요소들을 지정하여 접근하기 위한 document객체의 메서드
   
        @ (참고) {HTMLCollection 객체} VS {NodeList 객체}
           : 각각 getElements 메서드와 querySelector 메서드의 반환값으로 각자의 방식으로 여러개의 HTML태그 정보들을 담을 수 있는 {유사 배열 객체}지만, 차이점도 존재하는 객체

            1) {HTMLCollection 객체}, {NodeList 객체} 각각 설명

               a. {HTMLCollection 객체}
                   : 개별 HTML요소를 {live DOM 객체} 형식으로 여러개 저장 가능한 {유사 배열 객체}
         
               b. {NodeList 객체}
                   : 개별 HTML요소를 {Node 객체}라는 {non-live DOM 객체} 형식으로 여러개 저장 가능한 {유사 배열 객체} + 자체적으로 forEach 메서드는 사용 가능
                      -> (중요) BUT! {NodeList 객체}에서도 ES6 이전 감각으로 사용가능하게 만든 {NodeList 객체}의 일부 메서드들은 최대한 유사하게 재현하였기에 예외적으로 {live DOM 객체}를 반환하기도 함

                          ex) {NodeList 객체}.childNodes, {NodeList 객체}.getElementsByTagName(), {NodeList 객체}.getElementsByClassName()

               (참고) {live DOM 객체} VS {non-live DOM 객체}
                 : 어떤 {객체}가 저장하는 HTML요소의 정보의 상태 변화가 실시간으로 반영되는가?
                     -> YES : {live DOM 객체} 
                     -> NO  : {non-live DOM 객체} = 해당 HTML요소의 정보가 저장될 시점의 값이 정적(static)으로 남아있음

            2) 공통점, 차이점 분석
   
               a. (공통점)
                   : {HTMLCollection 객체}, {NodeList 객체} 둘 다 {유사 배열 객체}
                      -> {유사 배열 객체} != [배열] 
                          - map, forEach, reduce와 같은 JS [배열] 객체의 메서드 사용X
                          - length 프로퍼티를 가짐 = {객체}를 [배열]처럼 접근 가능 = 반복문을 돌 수 있음
                          -  깊은 복사를 통하던 얕은 복사를 통하던 둘 다 {유사 배열 객체} -> [배열] 변환이 권유
                             (= [배열] 관련 메서드를 사용하고 못하고의 차이를 극복하려고 하기 때문)
                                 -> (중요) 특히 {live DOM 객체}의 경우 무조건 실시간으로 HTML요소의 변화를 반영하니, [배열]로 변환해서 정적(static)한 HTML요소를 저장하여 다루도록 하는 것이 좋음
   
               b. (차이점)
                   : 각 {객체} 타입의 HTML요소들이 실시간으로 HTML요소의 변화를 반영하는지 
                   
                    {live DOM 객체}가 아닌 {non-live DOM 객체}를 반환받는지 여부 + 사용 가능한 메서드의 수

                     - {HTMLCollection 객체}
                        [1] 무조건 {live DOM 객체} 형태로 저장되어 있음
                              -> {HTMLCollection 객체}에 저장된 모든 HTML태그 정보들은 각각 실시간으로 HTML객체의 변화를 감지하고 반영하여 저장함
                                 (= {HTMLCollection 객체} 내부의 HTML태그들의 정보는 시시각각 동적으로 변해 예측이 힘들 수 있음)

                        [2] 메서드가 item(), nameditem() 2가지 뿐
          
                     - {NodeList 객체}
                        [1] 일반적으로 HTML 정보를 정적(static)으로 저장하여 상태 변화를 실시간으로 반영 X하는 {non-live DOM 객체} 형태로 저장되어 있음

                        [2] [배열]은 아니지만, 내부 요소 순환용 메서드 foreach메서드는 사용 가능함 
                             -> 그 이외에 keys(), values(), entries(), item() 등의 메서드들이 존재 

                        [3] {HTMLCollection 객체}처럼 실시간으로 HTML객체의 변화를 감지하고 반영하여 저장하는 {live DOM 객체}를 저장하는 예외성이 존재
                             : ES6 이전부터 사용되어 왔던, {HTMLCollection 객체}의 일부 DOM 탐색 메서드나 프로퍼티들을 사용하던 개발자들도 포용할 수 있도록 함
                                -> (중요) DOM탐색 메서드명도 같지만, 이들이 반환하는 HTML요소들을 품은 {객체}들 또한 실시간으로 변화를 반영하는 {live DOM 객체}에 해당하도록 예외성이 강한 대목

                                    ex) {NodeList 객체}.childNodes, {NodeList 객체}.getElementsByTagName(), {NodeList 객체}.getElementsByClassName()


        @ (ES6 이전까지 사용) getElement 메서드 seris
           : ES6가 등장하기 이전까지 원하는 HTML요소에 해당하는 DOM객체에 접근하기 위해 사용했던 {document 객체}의 DOM 검색 메서드 종류
              -> (단점) CSS선택자의 종류에 대응하는 메서드들이 각각 존재하기에, 관련 메서드가 너무 많고 확장성이 구리다는 면에서 매우 불편함
                   -> document.querySelector('css속성명') 방식이 등장하게 된 이유

             a. 조건에 맞는 HTML 태그를 여러 개 탐색하여, 각각 {live DOM 객체} 형태로 변환 후 이를 유사배열인 {HTMLCollection 객체}에 담아서 반환하는 메서드 
                (= {HTMLCollection 객체}는 검색된 HTML요소를 {live DOM 객체}로 변환한 데이터들을 담는 컨테이너 역할을 수행하는 {객체}라고 볼 수 있음 )
                    -> 여러개의 {live DOM 객체} 형태의 HTML요소들의 정보를 담을것을 상정하였음 = 개별 HTML요소 데이터에 접근하려면 [배열]과 같은 index접근 필요

                1) document.getElementsByTagName('html태그명')
                    : 현재 화면의 DOM객체에서 parameter로 입력한 <html태그명>에 해당하는 모든 HTML 태그들을 {HTMLCollection 객체} 형식으로 반환하는 메서드
                      (= 해당 화면의 HTML에서 <html태그명>에 해당하는 모든 태그들을 {HTMLCollection 객체} 형식으로 찾아서 담아 제공함)
      
                      ex) 모든 <h1> 태그를 찾아서 {HTMLCollection 객체} 형식으로 반환하고, 2번째 {HTML요소 객체}를 반환함
                           : document.getElementByTagName("h1")[1]
                              
   
                      ex) 존재하는 모든 html 태그를 찾아서 {HTMLCollection 객체} 형식으로 반환함
                           : document.getElementByTagName("*");
   
                2) document.getElementsByClassName('class속성명')
                    : 현재 화면의 DOM객체에서 parameter로 입력한 'class속성명'을 가지는 모든 HTML 태그들을 {HTMLCollection 객체} 형식으로 반환하는 메서드
                        -> (참고) 공백을 사용하면 여러 개의 class를 지정 가능
      
                      ex) 'product'와 'premium'라는 class속성명을 모두 가진 모든 html요소들을 찾아서 {HTMLCollection 객체} 형식으로 반환함
                            : document.getElementByClassName("product premium");
      
                3) document.getElementsByName('name속성명')
                    : 현재 화면의 DOM객체에서 parameter로 입력한 'name속성명'을 가지는 모든 HTML 태그들을 {HTMLCollection 객체} 형식으로 반환하는 메서드
                       -> BUT! WebKit 브라우저에서는 NodeList 를 반환한다고 함
      
                      ex) 'my-form'라는 name속성명을 가진 모든 html요소들을 찾아서 {HTMLCollection 객체} 형식으로 반환함
                            : document.getElementByClassName("my-form");

             b. 조건에 맞는 HTML 태그를 1개만 탐색하여, HTML 태그를 {live DOM 객체}형식의 {HTML요소 객체} 형식으로 반환하는 메서드
                (= {HTML요소 객체} : 사실상 HTML태그 그 자체를 의미하는 {객체})

                1) document.getElementById('Id명')
                    : 현재 화면의 DOM객체에서 parameter로 입력한 'Id명'을 가지는 HTML 태그들 중 1번째로 찾은 요소만 {HTML element 객체} 형식으로 반환하는 메서드
                       -> 1개만 찾는 이유는 ID속성 자체가 document 내에서 유일하다는 특성을 가진다는 의미(symantic)를 가지고 있는 속성이기 때문  
      
                      ex) 'box'라는 Id속성명을 가진 1개의 html요소들을 찾아서 {HTML요소 객체} 형식으로 반환함
                            : document.getElementByClassName("box");

        @ (ES6 이후 사용) querySelector 메서드 seris
           : ES6 이후 querySelector라는 1종류의 DOM요소 검색 메서드에 parameter로 넣을 속성값으로 'CSS 선택자' 문법을 적용할 수 있게 개선 + {NodeList 객체}만을 반환하는 DOM검색 메서드 계열
              -> (참고) 검색할 속성 종류에 따라 메서드를 외울 필요가 없고, parameter로 넣을 속성값으로 'CSS 선택자'를 다르게 하면 되는지라 편의성이 급상승함
              -> (중요) 일반적으로 반환하는 {NodeList 객체}는 {non-live DOM 객체} 형태로 저장되어 있음
                        (= {NodeList 객체}에서 저장하는 개별 HTML요소의 정보를 정적(static)으로 저장하여 상태 변화가 일어나도 반영 X)
                             ->  BUT! 몇몇 예외적으로 {live DOM 객체}를 반환하는 경우가 존재함
                 
                                 ex) ES6 이전부터 사용되어 왔던, {HTMLCollection 객체}의 일부 DOM 탐색 메서드나 프로퍼티들을 {NodeList 객체}에서도 사용할 수 있게 한 경우.. 기능 유사성을 위해 많은 부분의 예외성을 허용
                                      : {NodeList 객체}.childNodes, {NodeList 객체}.getElementsByTagName(), {NodeList 객체}.getElementsByClassName()

             a. document.querySelectorAll('CSS 선택자')
                 : 'CSS 선택자' 조건에 해당하는 HTML 태그를 여러 개 탐색하여, 각각 정적인 HTML형태의 {non-live DOM 객체} 형태로 변환 후 이를 유사배열인 {NodeList 객체}에 담아서 반환하는 메서드 
                     -> 여러개의 {non-live DOM 객체} 형태의 정적인 HTML요소들의 정보를 담을것을 상정하였음 = 개별 HTML요소 데이터에 접근하려면 [배열]과 같은 index접근 필요

                   ex) class속성의 값이 product와 premium이 동시에 적용되어 있는 HTML요소를 모두 찾은 뒤, 모든 HTML요소의 내용은 탐색이 이뤄진 실행 시점 기준으로 하여 {NodeList 객체}로 저장하고 거기서 3번째  {non-live DOM 객체}인 Node를 반환 
                        : document.querySelector(".product.premium")[2];

             b. document.querySelector('CSS 선택자')
                 : 'CSS 선택자' 조건에 해당하는 HTML 태그를 1개만 탐색하여, 정적인 HTML형태의 {non-live DOM 객체} 형태로 변환 후 이를 유사배열인 {NodeList 객체}에 담아서 반환하는 메서드 
             
                   ex) id속성의 값이 userForm고, 그 자식 HTML요소의 id속성의 값이 username에 해당하는 HTML요소를 1개만 찾은 뒤, 탐색이 이뤄진 시간 당시의 내용을 가지는 HTML요소 정보를 반환해라
                        : document.querySelector("#userForm #username");


 - WEB component
    : 사용자가 스스로 정의해서 제작한 만들어진 '커스텀 HTML <태그>'라고 생각하면 됨
      (= 역으로 말하자면, 기본 HTML태그는 기본 제공되는 WEB component라고 볼 수 있음)
          -> (중요) React, Vue 등등 대부분의 프론트엔드 관련 라이브러리나 프레임워크에서 말하는 component도 해당 개념과 비슷

     # WEB component 제작법

        1. class 문법으로 HTMLElement라는 JS객체를 상속받는 class를 선언

        2. 그 내부의 메서드로 connectedCallback()을 정의하고, {}안에 넣을 HTML 내용들에 해당하는 명령어를 입력해주면 됨

          @ connectedCallback() 작성시 참고 사항

             1) connectedCallback() 함수는 해당 WEB compoent가 HTML에 장착될 시점에서 실행됨
                (= component 생성 시점을 잘못 계산하면, 없는 태그라니 하는 식으로 페이지 로드시 많은 것들이 꼬일 수 있음)

             2) connectedCallback() 함수에 HTML 내용 입력 방식
                 a. HTML 내용 입력시 this.innerHTML = 'compoent 내용'에 해당하는 부분을 문자열 형식으로 입력
                 b. HTML 내용 입력시 태그를 생성하고 배치하는 JS 함수를 사용

             3) this.getAttribute('속성명')을 사용하면, 추후 <component /> 선언 시 사용자가 넣는 '속성명'의 값을 가져올 수 있음
                 -> 이를 지역변수에 할당해서, 구체적인 component 내용에 써먹음으로서, HTML을 동적으로 구성 가능 

             4) style을 넣고 싶으면, 내용에 <style> 태그를 넣고 스타일을 부여하면 됨
                 -> BUT! 해당 WEB component 이외의 다른 component들에도 style 선택자 조건만 맞으면 영향을 미칠 수 있음
                    (= 의도하지 않은 오염이 발생할 수 있음)
                        -> (중요) WEB component의 style이 지역변수처럼 작동하게 하고 싶다면, shadow DOM까지 열어서 거기 집어넣으면 해결됨
      
        3. 작성한 component에서 특정 '속성명'의 변경이 감지되면, 이를 바로 HTML내용에 반영되도록 반응형 component를 원한다면?
            -> static get observedAttributes() 메서드와 attributeChangedCallback()를 작성함
               (이 부분을 응용하면, React, Vue에서 제공하는 새로고침 없는 자동 html 재렌더링 기능도 특정 attribute 변화를 감지하면 변경해주는 식으로 구현 가능함!)

               @ static get observedAttributes() 메서드
                  : 해당 WEB component에서 변경여부를 감시할 속성들을 제시하도록 도와주는 메서드로 [변경여부를 감시할 속성들] 형식으로 반환
     
               @ attributeChangedCallback()
                  : static get observedAttributes()에서 반환한 [변경여부를 감시할 속성들]이 변하는것이 감지되면, 해당 메서드의 내용을 수행하여 component의 변경을 수행하는 함수

        3. 다 작성했으면 customElements.define("원하는 compoent명",작성한 component 클래스명); 를 class 외부에 작성함
           (= 이를 통해, 사용자 정의 WEB component가 사용 가능)

           ex) name 속성에 따라 동적으로 내용이 달라지고 실시간 변경되는 Web component 작성
           
               class 클래스 extends HTMLElement {
    
                  connectedCallback() {
                     let name = this.getAttribute('name');
                     this.innerHTML = '<label>${name}을 입력하쇼</label><input>
                                       <style> label { color : red } </style>`
                  }
               
                  static get observedAttributes() {
                      return ['name']
                  }
                  attributeChangedCallback() {
                      (attribute 변경시 실행할 코드)
                  }
               }
 
                customElements.define("custom-input", 클래스);

        4. HTML 영역에 원하는 부분에 <compoent명 속성명="값"></compoent명> 이런 식으로 작성하면 완료..

           ex) HTML 영역에 해당 WEB component를 name속성과 함께 작성

                <custom-input name="이메일"></custom-input>
                <custom-input name="비번"></custom-input>
 
      # WEB component의 세부적 개념 및 특성 정리

         1. 해당 WEB component에만 귀속되고 적용되는 style을 적용하기 쉽지 않음
             -> shadow DOM을 쓰거나, ``과 style속성을 써보면 해결은 될 수 있음

         2. WEB component class를 export하고 어디서나 import하여 <component>를 재활용이 가능함
             -> BUT! 누누히 말하지만, style과 같이 다른 component에도 적용이 되는 암묵적 결합 요소가 있을 수 있음
                 -> 타 component를 오염시키지 않으면서, 내부에서 완전히 독립적으로 작동하고, 일부를 사용자에게 보여주지 않을 component를 제작하려면? 
                     -> shadowDOM을 알아야 함

         3. react나 vue의 component들도 기본적으로 WEB component가 제공하는 기술적 역할을 모두 수행가능하나... 
             -> BUT, 해당 라이브러리나 프론트엔드에서 추구하는 VDOM을 통한 state기반 재랜더링과 같은 기능들이 추가된 것으로 이해하면 됨

 - Shadow DOM(document of model)
    : 개별 WEB component(웹 컴포넌트)의 내부 구조가 DOM모델로 구성되어 있는 영역을 그림자와 같이 드러나지 않게 캡슐화하여, 사용자로부터 그 구조와 스타일이 변형되지 않도록 보호하고 독립적인 모듈로서 사용이 가능하게 만드는 기술
      (쉽게 설명하자면, 메인보드의 설정 화면이 평소에는 초보사용자가 알 필요없는 부분은 보이지 않지만, 숙련자용 설정을 키면 세세한 세팅까지 다 할 수 있게 기술적으로 보여줄 수 있게 하는 원리와 유사함)
        -> 기본 HTML 태그들이 생각보다 내용이 복잡함에도 <태그명> 방식으로 쉽게 사용이 가능한 이유에 지분을 많이 가지고 있음

            ex) <input type="range">의 경우 실제로는 꽤 복잡한 component와 같이 내부가 설계되어 있음

     # shadowDOM의 키워드
        1. 내부 HTML요소들의 캡슐화
        2. 캡슐화를 통한 편의성 증대
        3. shadowDOM 내부 요소들의 지역변수화 (= 암묵적 결합 원천 봉쇄)
        4. WEB component에 적용하여, HTML 모듈화 개발이 가능하게 하는 기술적 원천

     # Shadow DOM을 보지 못하게 하는 이유 요약
        : 보안과 연관된 설계의도로 인해, 개발된  web component(웹 컴포넌트)의 구조와 스타일이 기본적으로 외부로부터 보호되길 원했음
          (= 브라우저가 Shadow DOM의 내부 구조를 외부로 노출하지 않는 것은 캡슐화가 설계 의도에 들어있기 때문임)
              -> 캡슐화를 적용하여 논리적인 그룹을 형성하고, 재사용성을 높이고 유지 보수를 용이하게 함

     # Shadow DOM을 통한 캡슐화의 이점

        1. 개발자 편의성 제공 

           ex) 웹 개발시 기본적인 HTML태그의 세부 설계구조를 몰라도, 개발자는 input 같은 복잡한 기본태그를 WEB component(웹 컴포넌트) 사용하듯 쉽게 쓸 수 있음 
               (= Shadow DOM을 볼 수 있다는 의미는 HTML 개발시 코드가 너무 복잡해지지 않기 위해 숨겨놓은 HTML 요소들에 대한 구조를 원한다면 까볼 수 있다는 이야기)

        2. 진정한 의미의 html 태그들의 독립적인 모듈화 개발이 가능
           (= 각 web component들이 다른 모듈로 취급되어, 서로 영향을 끼치는걸 막을 수 있음)

           ex) WEB component(웹 컴포넌트)의 style의 경우 shadow DOM 열어서 거기 집어넣으면, 다른 DOM이나 WEB component(웹 컴포넌트)에 영향을 끼치지 않음
                -> 원하는 곳에서 class 만 export 해서 가져다 쓰면 컴포넌트로 모듈식 개발이 가능하게 만듦

                   ex) 일반 WEB component(웹 컴포넌트)에 style을 넣으면? 다른 component나 태그에 영향을 줌
                   
                       class 클래스 extends HTMLElement {
                         connectedCallback() {
                           this.innerHTML = `<label>이름을 입력하쇼</label><input>
                             <style> label { color : red } </style>`
                         }
                       }
                       customElements.define("custom-input", 클래스);
        
                       <custom-input></custom-input>
                       <label>왜 나까지 빨개짐?</label>
               
                   ex) shadow DOM에 style을 넣으면? 다른 component나 태그에 1도 영향을 주지 않고, 해당 WEB component(웹 컴포넌트)에서만 영향을 미침
                   
                       class 클래스 extends HTMLElement {
                         connectedCallback() {
                           this.attachShadow({mode : 'open'});
                           this.shadowRoot.innerHTML = `<label>이름을 입력하쇼</label><input>
                             <style> label { color : red } </style>`
                         }
                       }
        
                       customElements.define("custom-input", 클래스);
        
                       <custom-input></custom-input>
                       <label>왜 나까지 빨개짐?</label>

     # 그래서 Shadow DOM을 알아야 하는 이유?

        1. Shadow DOM 개념을 안다면, 평소에는 수정하거나 변경 못하게 한 component들의 내부구조에 해당하는 영역도 CSS의 가상 요소(pseudo element)와 결합하여 셀렉터로 접근할 수 있음
           (= 일반적으로는 막혀있어 커스터마이징 할 수 없었던 특정 태그나 component들의 내부 HTML요소(ex. input)도 커스터마이징이 가능!)
           
           ex) shadowDOM 요소에 style이나, 이벤트리스너 부착 가능!

               <custom-input></custom-input>
               
                 <template id="template1">
                   <label>이메일을 입력하쇼</label><input>
                   <style>label { color : red }</style>
                 </template>
               
                 <script>

                   class 클래스 extends HTMLElement {

                     connectedCallback() {

                       this.attachShadow({mode : 'open'});
                       this.shadowRoot.append(template1.content.cloneNode(true));

                       let el = this.shadowRoot.querySelector('label');

                       el.addEventListener('click', function(){
                         console.log('클릭함')
                       })

                     }
                   }

                   customElements.define("custom-input", 클래스);
                 </script>

        2. 어떤 WEB component의 style 속성이 완전히 독립적으로 해당 component에서만 지역변수처럼 작동하게 하고 싶다면, shadow DOM에 style을 적용해야 하기 때문
           (= react나 vue의 그 component들처럼 해당 component안에서만 style이 국한되게 할 수 있음)

        3. Shadow DOM 개념이 있어야 완벽하게 사이드이팩트 없이 독립적으로 기능하는 WEB component를 제작하여, html 모듈화 개발을 할 수 있음
           (= export한 WEB component class를 어디서나 import하여 <component>를 붙여넣어도 완벽히 독립적으로 작동할 수 있기에, html 모듈화가 가능하고 이를 웹 개발이 편의적으로 활용이 가능함)

     # Shadow DOM VS WEB component
        : WEB component와 Shadow DOM은 전혀 다른 개념이지만, 둘이 결합된 개념을 통해 사용자가 정의한 <태그>에 재사용성을 통한 편의와 더불어 높은 수준의 캡슐화를 더해서, 진정으로 독립적으로 기능하는 Web Component를 제작가능
           -> (중요) 이렇게 만들어진 완벽하게 독립적으로 기능하는 WEB component를 통해서, html을 조립하듯 html 모듈화 개발을 할 수 있기에.. Shadow DOM과 WEB component는 세트메뉴로 묶일 수 밖에 없음

              @ WEB component
                : 사용자가 제작한 <태그>가 모듈로서 기능할 수 있도록, 재사용성이라는 키워드에 포커스를 맞추고 구현된 기능
                   -> 그래서인지 캡슐화적 개념이 기능에서는 집중되지 않음
       
              @ Shadow DOM
                : 이미 존재하는 <태그>의 내용을 기본적으로 비공개하고, 내부 요소들을 완벽하게 독립적인 지역변수화시켜 component 외부로 영향성을 주지도, 내부에서 받지도 않게 만들기를 원할 때 사용하는 것이 Shadow DOM
                   -> (참고) 엄연히 실존하는 HTML문서에 해당하는 DOM요소이기에, DOM셀렉터로 지정할 수 있음
                             (= Shadow DOM의 DOM요소들도 DOM 조작이 가능하며, style 지정이나 이벤트리스너의 부착도 가능함)

     # Shadow DOM을 개발자 도구에서 확인하는 방법
        : 개발자도구를 켠 상태에서 F12 (혹은 Settings 메뉴)를 누르면 나오는 곳에서, Show user agent shadow DOM을 체크하면 됨

     # Shadow DOM(document object model) 생성을 위한 JS문법
        1. 어떤 HTML요소를 DOM셀렉터를 통해 지정
        2. DOM셀렉터.attachShadow({mode : 'open'})을 통해, 해당 DOM요소의 ShadowDOM 영역에 진입할 수 있게 해주기
        3. DOM셀렉터.shadowRoot 영역에 원하는 <태그> 내용을 기입할 수 있도록 코드를 입력하면 됨
            -> a. HTML 내용 입력시 DOM셀렉터.shadowRoot.innerHTML = 'Shadow DOM compoent 내용'에 해당하는 부분을 문자열 형식으로 입력
 
                  ex) mordor라는 class 속성값을 가진 <div> 속성의 shadowDOM 속성으로 <p>심연에서왔도다</p>라는 태그가 들어가서, 평소에는 가려져서 보이지 않게 함
                  
                      <div class="mordor"></div>
                      <script>
                        document.querySelector('mordor').attachShadow({mode : 'open'});
                        document.querySelector('mordor').shadowRoot.innerHTML = '<p>심연에서왔도다</p>'
                      </script>
 
               b. HTML 내용 입력시 태그를 생성하고, DOM셀렉터.shadowRoot 영역에 배치하는 JS 함수를 사용
               c. HTML 내용 입력시 DOM셀렉터.shadowRoot.append('shadowDOM component 내용' or 변수명 등)을 사용
 
                  ex) 랜더링이 되지 않는 <template>태그에 shadowDOM에 담을 태그 내용을 기록한 뒤, 이를 this.shadowRoot.append(템플릿 내용 복사코드)로 태그내용 복붙하여 구현
                  
                      <template id="template1">
                        <label>이메일을 입력하쇼</label><input>
                        <style>label { color : red }</style>
                      </template>
                    
                      <script>
                        class 클래스 extends HTMLElement {
                          connectedCallback() {
                            this.attachShadow({mode : 'open'});
                            this.shadowRoot.append(template1.content.cloneNode(true));
                          }
                        }
                        customElements.define("custom-input", 클래스);
                      </script>
 
      # Shadow DOM을 활용하여 CSS 셀렉터를 통해 스타일링 하는 요령
         1. #shadow-root 아래의 숨겨진 해당 HTML태그의 Shadow DOM 구조의 HTML요소에서 pesudo속성을 찾고 그 속성값을 복사하여 가상 요소(pesudo element)와 결합하여 셀렉터 생성
            -> 원하는 HTML태그를 디버그 모드에서 검사한 뒤, #shadow-root 아래의 숨겨진 해당 HTML태그의 Shadow DOM 구조를 확인  
            -> 거기서 스타일링을 주고 싶은 요소의 pesudo속성을 찾고 그 속성값을 복사함
            -> 복사한 pesudo속성값을 가상 요소(pesudo element) 셀렉터에 이용하기 or 개발자 도구에서 셀렉터를 찾아서 그대로 CSS에 적용해도 됨 
 
                 ex) input::-webkit-input-placeholder {
                       color : red; 
                     }
 
         2. pesudo속성값이 없어서, 1번과 같은 방법을 사용 못 하는 경우?
             : 개발자 도구를 통해 CSS 셀렉터와 거기에 적용된 스타일을 찾을 수 있는데, 거기서 가상 요소가 적용된 셀렉터를 잘 찾아보면 해당 셀렉터가 등장하기도 함
 
                 ex) <inpur type="range">
                      -> [shadow DOM구조]
                         <div>
                           <div pesudo="-webkit-slider">     <- 얘는 가상요소 셀렉터로 쉽게 가져올 수 있는데?
                           <div id="thumb">                  <- 얘는 그렇게는 못 가져옴
                         </div>
                 
                      -> 개발자도구 style 영역 잘 뒤져보면 해당 html태그에 대한 셀렉터 있는데 그거 가져와서 셀렉터도 써도 됨 
 
                         input[type="range" i]::-webkit-slider-thumb {
                           appearance : none;  <- 기존 브라우저의 HTML 스타일을 아예 꺼버리는 기능 (shadow DOM 커스텀 스타일링 적용할거면 잘 참고하자) 
                           display : block;
                         }


          


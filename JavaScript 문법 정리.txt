 - JavaScript
    : 정적인 마크업 언어인 HTML을 웹 브라우저에서 동적으로 조작 및 변경을 목적으로 제작된 '약(weak)타입' + '동적타입'을 사용하는 '인터프리터 프로그래밍' 언어
       -> But 요즘에는 node.js라고 브라우저 이외의 JS를 실행가능하게 하는 런타임 환경이 등장하고, 이걸로 웹서버로 백엔드를 실행가능하게 하는 상황까지 왔음

          @ (중요) JS의 특징

             1. 인터프리터 언어(Interpreter Language)
             2. 자료형이 프로그램이 실행되는 '런타임' 시 결정되는 동적 타입(dynamic type) 언어
             3. 함수(fuction)는 '1급 객체((first-class object)'로서 또한 언어 내부에서 '값'으로 표현되고 전달될 수 있는 자료형 중 하나로 취급
                 -> 이같은 특성을 기반으로 다른 함수의 paramter로 사용하거나 return문에서 반환할 수 있는 '고차 함수(first-class object)'를 JS에서 사용 가능
             4. 기본적으로 싱글 쓰레드(single thread)만 사용
             5. {객체}간 상속(inheritance) 관계는 프로토타입(prototype) 기반 구조
             6. 다중 프로퍼래밍 패러다임 언어에 해당하는 하이브리드 패러다임 언어
                (= 함수형 프로그래밍, 객체지향 프로그래밍, 프로시저 프로그래밍 등의 다양한 패러다임에 해당하는 요소를 갖춤)

          @ (참고) 프로그래밍 언어 분류 기준들

             1. '실행방식'에 따른 프로그래밍 언어 분류
                 1) 인터프리트 언어(Interpreter Language)
                     : 실시간으로 컴퓨터가 소스를 1줄씩 읽고 해석해서 실행하는 방식
                        -> (장점) : 실행을 시키는 과정 자체는 간단함
                           (단점) : 컴퓨터가 소스를 읽고 해석하니까 느리다
              
                 2) 컴파일 언어(Compiled Language)
                     : 사전에 소스를 파싱(parsing)하여 컴퓨터 잘 아는 저수준 언어로 변환한 뒤 한번에 실행
                        -> (장점) : 사람이 적은 코드를 분석/검사하여 컴파일하는 시간이 있으니, 용량이 클수록 실행까지 꽤 시간이 소요되며 메모리도 좀 필요함 
                           (단점) : 성능은 매우 빠르며, 코드에 문제가 있으면 컴파일이 이뤄지지 않아서 신뢰성 측면에서 도움이 됨 
            
             2. '데이터 타입'에 따른 프로그래밍 언어 분류
                 1) 정적 타입 언어(static type)
                     : 어떤 변수의 자료형이 '컴파일' 시에 결정되기에 확실하게 자료형을 지정해야 하는 언어 (= 일단 해당되는 언어는 컴파일 언어)
                        -> (장점)
                             a. 자료형이 확실하게 정해져있기에, 실행 이후 자료형으로 인한 돌발상황 대처와 추론이 쉬움
                             b. 컴파일 과정에서 미리 자료형이 정해져 있어, 성능 측면에서 유리함
                             c. 문제가 있으면, 컴파일 과정에서 고치기도 쉬움
         
                           (단점)
                             : 변수가 받을 자료형이 고정되는 셈이라, 유연성은 매우 떨어짐
              
                 2) 동적 타입 언어(dynamic type)
                     : 어떤 변수의 자료형이 프로그램이 실행되는 '런타임' 시 결정되는 언어
                        -> (장점) : 변수의 자료형이 동적으로 변화가 가능하기에, 유연하게 프로그램이 실행 가능
                           (단점) : 자료형이 런타임 시 유연하게 결정되기 때문에, 문제가 생기면 그 떄 가봐야 알 수 밖에 없음
         
             3. '암묵적인 데이터 타입 변환(Type Casting 또는 Type Conversion) 가능 여부'에 따른 프로그래밍 언어 분류
                 1) 강타입 언어(strong type)
                     : 다른 데이터 타입끼리의 변환이 엄격하게 금지되어 있는 프로그래밍 언어
                       (= 정말 극단적이면 연산자 및 함수의 parameter로서 사용되는 변수의 데이터 타입이 선언된것과 다르면 바로 에러를 발생시킴)
         
                 2) 약타입 언어(weak type)
                     : 다른 데이터 타입끼리의 변환이 가능하며, 심지어 암묵적으로 변환을 해주기도 하는 프로그래밍 언어
                       (= 정말 극단적이면 데이터 타입이 의미가 없다 느껴질 정도로 암묵적으로 변환을 해주는 범위가 넓을수도 있음)



 - 웹 브라우저(Web browser)
    : HTML, CSS, JS를 실행시켜주는 C++로 개발된 프로그램으로 JS를 해석하고 실행할 수 있는 JS엔진을 탑재함
      (= C++로 개발된 브라우저는 직접 JS코드를 해석하지 않기에, 동기적으로 작동하는 JS코드를 발견하면  C++로 개발된 stack 메모리에 넣고 탑재된 JS엔진으로 JS코드를 해석함, 화면의 렌더링 또한 마찬가지로 C++가 수행함)
          -> 웹 표준은 W3, JS엔진에 대한 표준은 ECMA가 만들며, 각 IT기업마다 자신의 브라우저를 제작할 때 해당 엔진을 명세서를 참고하여 구현함
              -> 구글의 크롬 브라우저에 탑재된 V8이 매우 유명하며, 해당 JS엔진을 기반으로 웹서버로서도 기능할 수 있도록 제작한 JS런타임 환경이 Node.js

     @ HTML과 JS 관련 팁
        1) JS는 조작할 html 위에 작성하지 않는 것이 좋음
            -> 브라우저가 html 파일을 위에서부터 순차적으로 읽어서 DOM트리를 구성하는데, 미리 html을 읽어놔야 해당 DOM요소를 조작이 가능하기 때문
               (= 요즘 <script> 태그가 <body> 끝나기 직전에 작성되는게 관습화 되는 이유... 이게 싫으면 load, DOMContentLoaded 이벤트를 활용한 이벤트리스너 함수를 쓰는 방법이 존재)

               ex) 아직 <p id="test">를 읽기 전이라 p태그에 대한 DOM이 아직 생성되지 않은 상태라, 갑자기 자바스크립트로 id="test"인 요소를 DOM에서 찾으라고 하면 에러가 남

                   <script>
                     document.getElementById('test').innerHTML = '안녕'
                   </script>
                   
                   <p id="test">임시글자</p>

        2) <script> 태그 안에 적은 JavaScript 코드는 페이지 로드시 1회만 메인 쓰레드(main thread)에 의해 콜스택(call stack)에 올라가서 실행
            -> 특정 상황에 반복되서 실행되는 이벤트 같은게 있다면, 반드시 그렇게 반복 실행되는 코드를 입력해줘야 함
 


 - 이벤트 루프(event loop) = JavaScript의 코드 실행방식
    : 프로그램 실행시 코드를 실행하는 주체인 쓰레드가 1개인 '싱글 쓰레드(single thread)' 구조라 코드를 '병렬 프로그래밍(Parallel Programming)'적으로 처리가 불가능해 보이는 JS 런타임 환경에서, 유사 '병렬적 프로그래밍'의 작동이 가능하게 구현해주는 코드 작동 로직
      (= 브라우저나 Node.js나 전부 같은 방식을 따름)
  
     
     @ 프로그래밍 언어로서 JS의 특수성
         : 브라우저가 브라우저의 웹페이지를 동적으로 제어해야 하지만, 싱글쓰레드(single thread)만 사용하는 언어로서... JS만의 특수성이 존재하게 됨
            -> 웹페이지를 사용자가 느끼기에 느리지 않게 그려야 하고, 그들의 예측 불가능한 동작에 반응해야 하며, 동시 다발적인 서버를 향한 요청을 보내고 또 반응해야 함...
               (= 싱글쓰레드(single thread)에서 어떻게든 유사 '병렬 프로그래밍'을 구현해서 '동시 처리'를 이루고 최적화를 해야 함 + 브라우저 또한 제어를 해야하는 숙명을 가지고 있음)

                ex) WEB API (DOM, event 등등 브라우저 제어 API), Macro task Queue & Micro task Queue 등... 다른 언어에서는 보기 힘든 해괴한 개념들이 많이 등장함

          # (중요) '싱글쓰레드(single thread)'인 JS가 비동기식(Asynchronous) - 비차단(Non-Blocking) 처리를 구현하고 '병렬 처리'를 구현한 방법
              : 비동기 코드 처리를 위한 전용 대기열(주요 업무 대기열(Macro task Queue) & 부수 업무 대기열(Micro task Queue))을 2개를 배치
                 -> 코드를 1개의 쓰레드로 순차적으로 동기식으로 처리하다가.. 특정 비동기로 작동하라고 내부적으로 설계된 작업(WEB API, queueMicrotask(함수명))들을 우선순위에 따라 2개로 구분하고 대기열에 배분한 뒤
                     -> 호출 더미(call stack)에 아무것도 없는 상태에서 이를 처리함
                        (= 이러한 JS의 동작 알고리즘을 이벤트 루프(event loop)라고 명명)

          # (참고) JS가 초기 설계부터 싱글쓰레드(single thread) 모델의 언어로 결정된 이유
             : 멀티 쓰레드(Multi Thread) 환경은 브라우저 환경에서 사용자 인터페이스(UI)를 조작하고, 웹 페이지와 상호작용할 시 충돌이 발생할 수 있는 동시성 문제(데드락, 레이스 컨디션 등) 위험이 존재하기 때문
                -> 프로그램 안정성과 사용자 경험이 주요 이유라고 생각하면 편하다는 말씀


     @ (중요!) 이벤트 반복(event loop) 알고리즘
        : JS에서 혼재한 동기식 코드와 비동기식 코드의 효율적인 처리 위해, 주요 업무 대기열(Macro task Queue)과 부수 업무 대기열(Micro task Queue)에 놓은 코드들을 어떤식으로 순번을 정해 처리할 지에 대한 알고리즘
          (= 이를 통해, JS는 1개의 쓰레드로도 사용자의 화면에서의 동작에 반응하면서, 요청된 코드를 처리하고, 서버로부터의 응답을 받는 '병렬 프로그래밍(Parallel Programming)'적인 처리를 동시성(Concurrency) 개념 성립을 통해 구현 가능함) 

          # 이벤트 반복(event loop) 알고리즘 로직 흐름
             : (결론) 쓰레드는 1개지만, 비동기 로직 처리용 대기열을 2개나 만들어두고, 순차적으로 코드를 실행하여 비동기코드 나오면 던져버리고, 호출 더미(call stack)에 아무것도 없으면, 그 대기열에 있는 것들을 순차적으로 실행하는.. 
                 -> 일종의 눈속임으로 병렬 프로그래밍이 되는거처럼 보이게 하나... 최적화가 ㅈㄴ게 이뤄진 끝에 요즘은 매우 부드럽게 동작함... 
                     -> BUT! 그럼에도 너무 처리시간이 오래 걸리는 업무가 있으면, 에러페이지가 나오는건 피하진 못함 

                1) 가장 위에 위치한 코드를 기점으로 JS런타임 환경에서 JS코드를 실행
                    -> 현재 코드가 동기식(synchronous) 방식에 해당하는 코드면, 호출 더미(call stack)에 올려두고 실행하여 완료될 때까지 대기
                    -> 현재 코드가 비동기식(Asynchronous) 방식에 해당하는 코드면, 종류에 따라 주요 업무 대기열(Macro task Queue)이나 부수 업무 대기열(Micro task Queue)에 올려두고 다음 줄에 해당하는 코드로 이동
                
                2) 현재 호출 더미(call stack)에 처리해야 할 내용들이 남아 있다면, 호출 더미(call stack) 실행
                    -> 호출 더미(call stack)이 비어서 대기상태에 있을 때까지 계속함
   
                3) 부수 업무 대기열(Macro task Queue)에서 FIFO(first in first out)에 따라 가장 오래된 업무를 꺼내 순차적으로 실행
                    -> 부수 업무 대기열(Macro task Queue)에 업무가 없을때까지 반복함
                
                4) 주요 업무 대기열(Macro task Queue)에서 FIFO(first in first out)에 따라 가장 오래된 업무를 꺼내 1번만 실행
                    -> 주요 업무 대기열(Macro task Queue)의 1개의 업무가 끝날 때마다 호출 더미(call stack), 부수 업무 대기열(Macro task Queue)을 확인
                        -> 호출 더미(call stack)에 내용이 있다면 2)로...
                        -> 부수 업무 대기열(Macro task Queue)에 내용이 있다면 3)으로
                        -> 둘 다 없는데? 
                            -> 주요 업무 대기열(Macro task Queue)에 내용이 있다면 4)반복
                            -> 주요 업무 대기열(Macro task Queue)에 내용이 없다면, 다음으로..

                5) 호출 더미(call stack), 부수 업무 대기열(Macro task Queue), 주요 업무 대기열(Macro task Queue)이 전부 비어 있다면? 화면에 렌더링(Rendering) 할 것이 있으면 처리
                   (= 대기열의 업무가 남아있는 동안에는 랜더링은 일어나지 X)
   
                6) 1)로 돌아가서, 계속 코드를 수행

                   ex) 'code' - 'promise' - 'timeout'의 순서대로 실행되는 alert 메서드
                         -> 이벤트 반복의 '호출더미(call stack) - 부수 업무 대기열(Macro task Queue) - 주요 업무 대기열(Macro task Queue)'로 흘러가는 실행 순서를 볼 수 있음

                            setTimeout(() => alert("timeout"));
                            
                            Promise.resolve()
                              .then(() => alert("promise"));
                            
                            alert("code");

          # 호출 더미(call stack) 개념
             : 다른 언어들 처럼, 쓰레드가 '위 -> 아래' 방향으로 코드를 실행 중 동기식으로 작동하는 함수 발견하여 호출하게 되면, 현재 함수 ~ 그 과정에서 호출한 다른 함수들을 LIFO(Last In, First Out) 구조로 관리하는 메모리 스택
                -> 그러니까, 가장 깊은 단계에서 호출된 함수는 메모리 스택의 가장 최상단으로 가게 되며, 그것이 끝나면 스택에서 지워지고, 계속 다음 코드를 수행함
                    -> C++로 개발된 브라우저는 직접 JS코드를 해석하지 않기에, 동기적으로 작동하는 JS코드를 발견하면  C++로 개발된 stack 메모리에 넣고 탑재된 JS엔진으로 JS코드를 해석함

                        ex) first() 함수를 호출하면, 호출 더미 구조는 다음과 같이 진행 
     
                            function first() {
                                console.log('First');
                                second();
                                console.log('First End');
                            }
                            
                            function second() {
                                console.log('Second');
                            }
                            
                            first();
                              -> first()      // 가장 처음 콜스택에 쌓임
                              -> second()     // 2번쨰로 쌓이면, 스택의 최상단으로
                                 first()
                              -> first()      // second()의 내용이 끝나서, 콜스택에서 해제되고, first()의 내용을 계속 진행
                              -> 비어있음      // first()도 끝나서 없어짐


               - (중요) 호출 더미(call stack)에서 너무 오랜 작업시간(side effecy)이 필요해서 지연시간이 길어진 나머지 사용자 경험을 저해하는 경우 이를 해결하는 방법론
                   1) 긴 작업을 끊어가며 진행할 수 있게 조정
                        -> 주요 업무 대기열(Macro task Queue) & 부수 업무 대기열(Micro task Queue)에 이를 주기적으로 배정하여

                           ex) 반복문이 1000억 이상 갈 경우... 이를 몇천번에 한번씩 잘라서, 한 구간이 끝나면 setTimeout을 통해 몇 초후 다시 시작하는 방식 채용

                   2) '병렬 프로그래밍'을 통한 '병렬 작업'을 통해 빠르게 작업을 수행함
                        -> WEB API 중 WEB Worker API를 사용

          # (ES6 이후) 주요 업무 대기열(Macro task Queue) & 부수 업무 대기열(Micro task Queue) 개념
             : 둘 다 비동기식(synchronous) 방식으로 작동하는 코드들이 놓이게 되나, 비동기적 코드들 또한 종류별로 작업의 우선순위를 정할 필요가 있음에 따라 구분된 비동기식(synchronous) 방식 코드 처리 전용 대기열
                -> (중요) 둘 다 FIFO(first in first out)방식으로 순번이 정해짐

                    1) 주요 업무 대기열(Macro task Queue)
                        : 부수 업무 대기열(Micro task Queue)보다 우선순위가 떨어지는 비동기식(synchronous)으로 작동되는 기능들
                           -> 해당 대기열의 업무는 1개가 끝날 때마다, 호출 더미(call stack)와 부수 업무 대기열(Micro task Queue)을 체크
                               -> (중요) 그렇게 주요 업무 대기열(Macro task Queue)까지 다 끝나서야 브라우저의 렌더링이 진행되어 UI 변화가 일어남

                          ex) setTimeout, setInterval, I/O 이벤트, addEventListener, ajax, 외부 scripr 로드

                    2) 부수 업무 대기열(Micro task Queue)
                        : 주요 업무 대기열(Macro task Queue)보다 우선순위가 높은 비동기식(synchronous)으로 작동되는 기능들
                            -> (참고) 부수 업무 대기열(Micro task Queue) 전체가 처리되는 동안에는 UI 변화나 네트워크 이벤트 핸들링이 일어나지 않음
                         
                          ex) Promise의 then - catch - finally 구문, async/await, MutationObserver, queueMicrotask(함수명)


          # (ES6 이후) 비동기 코드용 대기열에 사용자가 임의로 스케쥴링(schaduling) 하는 방법
             : 주요 업무 대기열(Macro task Queue)과 부수 업무 대기열(Micro task Queue)를 구분해 놓은 이유를 명심하며, 스케쥴링에 뭘 쓸지를 골라야 함
                -> 비동기코드 실행 '우선순위'와 더불어 '랜더링'이 필요한지까지 염두에 두고 골라야 함

                   A. 주요 업무 대기열(Macro task Queue)에 임의의 작업 추가
                      : setTimeout(함수명)을 통해, 지연시간을 0으로 설정해두면 가능함
                         -> (중요) 이를 통해 과도한 반복횟수로 인해 지연시간이 길어지는 코드(side effect)를 어려번 재시작 할 수 있게 됨으로서, 그 시간동안 브라우저는 유저의 입력을 받을수 있게 되어 사용자의 유저경험 저하를 막을 수 있음
                      
                        - (중요) 주요 업무 대기열(Macro task Queue)의 스케쥴링이 필요한 경우

                           1) 반복문 + 재귀함수로 호출과 연계하면, 복잡한 큰 업무를 여러 개로 쪼개서 진행 가능하게 할 수 있음
                               -> 사이드이팩트(side effect)에 해당하여 유저 경험(user experiment)를 망치는 코드의 효율화에 사용 가능

                           2) 우선순위가 상대적으로 낮아도 되며, 실행결과에 따른 랜더링이 필요하다고 판단될 때 사용함
                           
                              ex) count() 함수의 호출에 따른 호출 더미(call stack)이 끝나지 않는 한, 렌더링은 진행되지 않음
                                    -> 1000ms 마다 함수를 종료해서 호출 더미(call stack)를 끊고, 지연시간을 0인 setTimeout을 통한 주요 업무 대기열(Macro task Queue)의 재귀호출로 인해, 함수는 계속되게 하면서 모든것이 끝났기에 중간정산용 랜더링이 가능하게 함
           
                                       <div id="progress"></div>
                                       
                                       <script>
                                         let i = 0;
                                       
                                         function count() {
                                       
                                           // 무거운 작업을 쪼갠 후 이를 수행
                                           do {
                                             i++;
                                             progress.innerHTML = i;
                                           } while (i % 1e3 != 0);
                                       
                                           if (i < 1e7) {
                                             setTimeout(count);
                                           }
                                       
                                         }
                                       
                                         count();
                                       </script>
      
                           3) 특정 함수의 호출 더미(call stack)가 완전히 끝나고, 실행시킬 필요가 있는 내용이 있다고 판단되면 사용함
      
                              ex) 지연시간이 0인 setTimeout은 이벤트가 완전히 처리되고 난 후(버블링이 끝난 후)에 특정 작업을 수행하도록 스케줄링할 때도 사용
                                   -> onclick 이벤트가 처리된 이후, 원하는 사용자의 이벤트가 진행되도록 주요 업무 대기열(Macro task Queue)의 스케쥴링을 통해 구현
           
                                      menu.onclick = function() {
                                      
                                        // 클릭한 메뉴 내 항목 정보가 담긴 커스텀 이벤트 생성
                                        let customEvent = new CustomEvent("menu-open", {
                                          bubbles: true
                                        });
                                      
                                        // 비동기로 커스텀 이벤트를 디스패칭
                                        setTimeout(() => menu.dispatchEvent(customEvent));
                                      };
      
                   B. 부수 업무 대기열(Micro task Queue)에 임의의 작업 추가
      
                      - (중요) 부수 업무 대기열(Micro task Queue)의 스케쥴링 방법들

                         1) queueMicrotask(함수명) 사용하기
                             : 부수 업무 대기열(Micro task Queue)에 새로운 작업을 비동기적으로 작동하게 추가하는 JS 표준 API에 해당하는 메서드
                                -> 이를 반복문 + 재귀함수로 호출과 연계하면 복잡한 큰 업무를 여러 개로 쪼개서 진행 가능하게 할 수 있음
                  
                                   ex) count() 함수의 호출에 따른 호출 더미(call stack)이 끝나지 않는 한, 렌더링은 진행되지 않음
                                         -> 1000ms 마다 함수를 종료해도, 부수 업무 대기열(Micro task Queue)에 재귀함수가 남아있으니, 결국 랜더링은 부수 업무 대기열(Micro task Queue)이 완전히 끝나는 마지막에 이뤄짐
                                            (= 하지만?  애플리케이션 상태의 일관성은 가장 믿을 수 있음)
                           
                                            <div id="progress"></div>
                                            
                                            <script>
                                              let i = 0;
                                            
                                              function count() {
                                            
                                                // 무거운 작업을 쪼갠 후 이를 수행
                                                do {
                                                  i++;
                                                  progress.innerHTML = i;
                                                } while (i % 1e3 != 0);
                                            
                                                if (i < 1e7) {
                                                  queueMicrotask(count);
                                                }
                                            
                                              }
                                            
                                              count();
                                            </script>
                  
                         2) Promise.resolve().then( 함수명 ) 사용하기
                         3) async/await를 사용한 함수

                      - (중요) 주요 업무 대기열(Macro task Queue)의 스케쥴링이 필요한 경우
                          : 부수 업무 대기열(Micro task Queue) 전체가 처리되는 동안에는 UI 변화나 네트워크 이벤트 핸들링이 일어나지 않음
                            (= 부수 업무 대기열(Micro task Queue)에 임의의 작업 추가시 애플리케이션 상태의 일관성이 보장)
                                -> 우선순위가 중요하고, 랜더링은 1번에 처리될 필요가 있는 비동기 처리시, 애플리케이션 상태의 일관성이 중요한 경우 이를 사용함


     @ (참고) 프로세스 실행 방식을 분류하는 기준들
         : 이 부분은 프로퍼래밍 언어 관련 공통으로 쓰일 수 있는 부분이니 정확한 이해가 필요
            -> (결론) 동기식(synchronous) - 차단(Blocking) 처리 <-> 비동기식(Asynchronous) - 비차단(Non-Blocking) 처리.. 보통 이렇게 세트로 묶이게 됨

           A. 출력 순서 기준('완료'라는 상태가 키워드)
               : 요청한 작업에 대해 '완료 여부'를 신경 써서 수행할지 여부에 대한 관점을 기준으로 코드 실행 방식을 분류한 기준
                 (= 어느쪽이던 코드의 진행은 먼저 적혀있는 녀석이 우선시 되는 것은 똑같음!)
                     -> (참고) 정말 복잡해 지는건, 이 2종류의 코드가 조합되는 경우... 코드 흐름이 예측하기 힘들다...
       
                 a. 동기식(synchronous) 처리
                     : 코드가 '위 -> 아래'로 적혀있는 순서대로 순차적으로 실행 + 코드 작업을 '완료'한 뒤 다음 코드를 실행하는 방식
                        -> (장점) : 순차 + 완료 여부라는 작업 흐름의 법칙대로 진행되니, 코드 흐름의 예측이 쉬움
                           (단점) : 특정 코드가 시간이 오래 걸리는 작업인 경우, 그게 끝날때 까지 기다려야 하며... 다른 작업이 차단되기도 함 (= 블로킹(blocking))
                     
                 b. 비동기식(Asynchronous) 처리
                     : 코드가 '위 -> 아래'로 적혀있는 순서대로 순차적으로 실행 + BUT! 코드 '완료 여부랑 상관X' 다른 코드를 실행하는 방식
                        -> (장점) : 특정 코드가 시간이 오래 걸리는 작업이라 하더라도, 그거랑 상관없이 다른 작업을 '동시에 수행' 가능 (= 비차단(Non-Blocking) 처리와 시너지 존재)
                           (단점) : 특정 작업의 완료 여부를 가정하고 순차적으로 실행되는 기능에 대한 개발을 수행시 코드 진행이 예측이 안 감 
      
           B. 병렬 처리 여부 기준('동시 수행'이 키워드)
               : 현재 코드 실행 시, 완료되지 않은 상황에서 다른 코드 수행 요청이 들어왔을 경우..? 이를 차단(Blocking)할 건지 여부를 기준으로 코드 실행 방식을 분류한 기준
                  -> (참고) 차단(Blocking) / 비차단(Non-Blocking) 처리와 동기식(synchronous) / 비동기식(asynchronous) 처리는 전혀 다른 성질로 다른 분류 기준
       
                 a. 차단(Blocking) 처리
                     : 현재 코드 실행 시 해당 작업이 '완료' 될 때까지 다른 코드 수행 요청이 들어오면 이를 차단(Blocking)
                        -> (참고) 작업의 '완료' 여부를 기준으로 다른 코드 수행을 금지한다는 점에서, 순차적 완료 여부를 법칙으로 삼는 동기식(synchronous) 처리와 시너지가 있음
                     
                           ex) 파일 입/출력이 블로킹 방식이면? 프로그램은 파일을 다 읽을 때까지 대기함

                 b. 비차단(Non-Blocking) 처리
                     : 현재 코드 실행 시 다른 코드 수행 요청이 들어와도 막지 않고(Non-Blocking), '동시에 수행'되게 함

                        ex) 파일 입/출력이 논블로킹 방식이면? 파일을 다 읽지 않아도 다른 작업을 할 수 있음


     @ (참고) 병렬 프로그래밍(Parallel Programming) 개념
         : 공동의 목적을 달성하기 위해, 다수의 실행 주체(프로세스, 쓰레드)가 동시에 작업을 수행하는 방식
            -> 실제 컴퓨터 시스템에서 프로그램을 실행하는 주체는 CPU (or Core)
               (= 프로세스(processor)나 쓰레드(Thread)는 여러 프로그램이 CPU를 공유해서 사용하기 위한 추상적 단위)

           # 동시에 수행할 작업의 단위에 따른 분류
              : 동시에 진행할 작업 단위가 무엇인가(프로세스, 코드)에 따라 그것을 진행시킬 주체(프로세서, 쓰레드) 또한 다르다는 것을 기억해야 함

                A. 프로세스(process) 개념
                    : 우리가 아는 컴퓨턴 프로그램에 해당하는 녀석.. HDD에서 저장된 내용이 RAM에 객체화 되어 올라와 운영체제에서 실행되며, 이를 실행하는 주체는 '프로세서(processor)'라고 함
                       -> (참고) 보통 1개의 CPU 코어는 1개의 프로세서 역할을 수행하게 됨
     
                B. 프로세스 내부의 코드
                    : 개별 프로그램 내부의 코드를 통한 개별 기능을 의미하며, 이를 실행하는 주체는 '쓰레드(thread)'라고 함
                       -> (참고) 코어가 1개인 CPU라도 여러개의 쓰레드를 둘 수는 있고, 맥락(context)를 번갈아가며 처리하는 동시성(Concurrency)을 달성하는 것은 가능함

           # 동시에 어떤 작업을 수행할 주체
              : 사실 컴퓨터 시스템에서 프로그램을 실행하는 주체는 CPU (or Core)
                (= 프로세스(processor)나 쓰레드(Thread)는 여러 프로그램이 CPU를 공유해서 사용하기 위한 추상적 단위)

                A. 프로세서(processor) 개념
                    : 운영체제에서 프로그램들인 프로세스(process)들을 실행하는 주체에 해당하는 추상적 단위
                       -> (참고) 보통 1개의 CPU 코어는 1개의 프로세서 역할을 수행하게 됨
      
                      a. 싱글 프로세서(single processor)
                          : 프로세스(process)들을 실행하는 주체가 단 1개에 해당하는 시스템을 의미
                            (= 코어가 1개인 CPU로 시스템이 실행되는 경우를 의미함)
      
                      b. 멀티 프로세서(Multi processor) = 멀티 코어 프로세서
                          : 프로세스(process)들을 실행하는 주체가 여러개가 존재하는 해당하는 시스템을 의미
                            (= 코어가 N개인 CPU로 시스템이 실행되는 경우를 의미함)
      
                B. 쓰레드(Thread) 개념
                   : 개별 프로세스(process) 내부의 코드들을 실행되는 진원지에 해당하는 흐름의 단위로, 실제 작업을 수행하는 주체에 해당하는 추상적 단위
    
                     a. 싱글 쓰레드(single Thread)
                         : 개별 프로세스(process) 내부의 코드들을 실행되는 흐름의 단위가 단 1개라서, 실제로 1개의 진원지에서 1방향으로 프로세스가 실행되는 시스템을 의미
                             -> (참고) JS는 싱글 쓰레드(single Thread)로 동작하는 언어라서.. 원칙적으로는 맥락(context)를 번갈아가며 처리하는 동시성(Concurrency)의 달성을 꿈도 꿀 수 없음
                                  -> 이를 가능하게 하는게 이벤트 반복(event loop) 알고리즘
      
                     b. 멀티 쓰레드(Multi Thread)
                         : 개별 프로세스(process) 내부의 코드들을 실행되는 흐름의 단위가 여러개라서, 실제로 여러 진원지에서 프로세스가 실행되는 시스템을 의미
                             -> (참고) 코어가 1개인 CPU라도 여러개의 쓰레드를 둘 수는 있고, 맥락(context)를 번갈아가며 처리하는 동시성(Concurrency)을 달성하는 것은 가능함


     @ 병렬성(Parallelism) & 동시성(Concurrency) 개념
        :  병렬 프로그래밍(Parallel Programming)의 '동시 처리'를 구현하는 방법론적인 측면의 구현 방식의 성격 차이에 대한 개념
            -> (주의) 동시성(Concurrency)은 병렬성(Parallelism)은 상호 베타적이지 않으며, 동시에 성립할 수도 있는 개념

                  ex) 동시성(Concurrency) O , 병렬성(Parallelism) O 
                       : '동시에 일어나는 작업의 수 > 작업 주체'이나, CPU 코어가 여러개인 '멀티 코어 프로세서' 환경에서는 여러개의 프로세서 및 쓰레드가 맥락 교환(Context Switch)까지 동원하여 병렬 프로그래밍을 구현하는 경우

                  ex) 동시성(Concurrency) O , 병렬성(Parallelism) X
                       : '동시에 일어나는 작업의 수 > 작업 주체'이나, CPU 코어가 1개인 '싱글 프로세서' 환경에서는 1개의 쓰레드의 맥락 교환(Context Switch) 똥꼬쇼로만 병렬 프로그래밍을 구현하는 경우

                  ex) 동시성(Concurrency) X , 병렬성(Parallelism) O
                       : '동시에 일어나는 작업의 수 <= 작업 주체'로, CPU 코어가 여러개인 '멀티 코어 프로세서' 환경에서 맥락 교환(Context Switch)없이 개별 코어들의 동기적 처리로만 병렬 프로그래밍을 구현되는 경우

           1) 동시성(Concurrency) 
               : '논리적인 개념'의 동시 처리로 여러 작업(프로세스 실행, 코드 작업)이 동시에 실행되는 것 같이 보이는 것을 의미
                 (= 실제로는 여러 작업이 물리적인 동시가 아니라, 빠르게 번갈아가며 수행되는 맥락 교환(Context Switch)에 해당함)

                # 맥락(Context)
                   : 각 프로그램인 프로세스(process)의 현재 실행 상태에 해당하는 정보(코드 진행 위치, 변수 정보, call stack 상황 등)를 의미
                      -> 이를 바탕으로 맥락 교환(Context Switch)이 일어나도 프로세서나 쓰레드는 작업의 연속성을 이어갈 수 있고, 동시성(Concurrency)을 달성 가능
     
                # 맥락 교환(Context Switch) 개념
                   : '동시에 일어나는 작업의 수 > 작업 주체'에 해당하는 경우, 동시에 실행되는 것 처럼 보이기 위해 작업을 번갈아가는 과정에서 일어나는 현상
                     (= '논리적인 개념'의 동시 처리인 '동시성(Concurrency)'을 충족하기 위해서 반드시 필요한 로직)

           2) 병렬성(Parallelism)
               : '물리적인 개념'의 동시 처리로 여러 작업이 실제로 여러개의 실행 주체에 따라 동시에 처리되는 것을 의미
                   -> (중요) 물리적으로 복수개의 프로세서(processor) 들로 이루는 '동시 처리' = 멀티 코어 프로세서(Multi processor)들이 필수적...
                        : 사실 컴퓨터 시스템에서 프로그램을 실행하는 주체는 CPU (or Core)
                          (= 프로세스(processor)나 쓰레드(Thread)는 여러 프로그램이 CPU를 공유해서 사용하기 위한 추상적 단위)



 - {window 객체} & {global 객체} = JavaScript의 특수성 있는 {전역 객체}
    : JS를 해석하는 프로그램의 런타임 환경 최상위 단계인 전역 스코프 영역 {}에 해당하는 {객체} = 전역변수, 전역함수, 전역객체가 멤버로서 소속 
        -> (중요!) index.html <script> 태그나 index.js와 같은 지정된 실행파일에 적힌 변수, 함수, {객체}는 전역 스코프{}에 실행된 것으로 보면 됨

            ex) 여기서 변수 x는 {window 객체}의 전역변수, 간지나는함수()라는 함수는 {window 객체}의 전역함수(메서드)
            
                <script>
                  var x = 300;

                  function 간지나는함수(){
                    console.log()
                  }
                </script>

            ex) 'window.변수명'은 전역변수, 'window.메서드명 = 무명함수'는 전역함수로 선언된 함수표현식(expression)으로 생각하면 편함

                <script>
                  window.x = 300;

                  window.간지나는함수() = () => console.log();
                </script>


       @ JS런타임 환경의 {전역 객체}들의 종류

          1) {window 객체}
               : JS를 실행 해석하는 주체가 '브라우저'인 경우의 최상위 단계에 존재하는 {전역 객체} 
                 (= 브라우저의 공통 기능 및 상태 정보에 대한 내용을 프로퍼티(= 전역변수), 메서드(= 전역함수)로 가지게 됨)
                      -> (중요) {JS객체}화 된 HTML 요소에 접근하고 조작하는 {DOM 객체} 또한 {window 객체}의 프로퍼티(= 전역 객체)며, alert('문자열'), comfirm('문자열'), prompt('문자열', 초기값) 또한  {window 객체}의 메서드(= 전역 함수)로 보면 됨

             # 브라우저에서의 전역변수 var와 {window 객체}와의 관계
                : 일반함수 스코프{}에 속하지 않는 전역변수인 var 변수는 최상위 {전역 객체}인 {window 전역 객체}와 메모리 영역을 자동으로 공유함
                  (= 브라우저의 전역변수 'var 변수 != window.변수' 성립)

                  ex) 브라우저에서의 '전역변수 var'와 {window 전역 객체}의 프로퍼티는 같은 메모리 영역을 공유함
                       -> 브라우저에서는 b4 == window.b4가 성림
                  
                          var b4 = 2;
                          window.b4 = 4;
                          
                          console.log(b4 + window.b4);  // 8 = 4 + 4

          2) {global 객체}
               : JS를 실행 해석하는 주체가 'Node JS'인 경우의 최상위 단계에 존재하는 {전역 객체}
                 (= 'Node JS'의 공통 기능 및 상태 정보에 대한 내용을 프로퍼티(= 전역변수), 메서드(= 전역함수)로 가지게 됨)

             # Node JS에서의 전역변수 var와 {global 객체}와의 관계
                : Node JS에서 실행하는 경우, {전역 객체}는 {global 전역 객체}가 되는데, 이 경우는 var 또한 let변수 처럼 {global 전역 객체}와는 영역이 절대 안 겹침!
                  (= Node JS의 전역변수 'var 변수 != global.변수')

                 ex) Node JS에서의 '전역변수 var'와 {window 전역 객체}의 프로퍼티는 같은 메모리 영역을 공유하지 않으며, 자동으로 동기화 되지 않음
                      -> Node JS에서는 b4 != global.b4가 성림
                 
                         var b5 = 2;
                         global.b5 = 4;
                         
                         console.log(a5 + global.b5);  // 6 = 2 + 4


       @ 대표적인 {전역 객체}의 메서드들
       
          1) setInterval(콜백함수, (선택) 숫자(ms단위))
              : '숫자(ms단위)'에 해당하는 간격으로 '콜백함수'의 내용부를 반복실행
                  -> (중요) 해당 메서드를 통한 콜백함수의 내용부는 기존 쓰레드(thread)가 순차적으로 코드를 호출 더미(call stack)에 올려 수행하는 것과 별개로 '주요 업무 대기열(Macro task Queue)'에 쌓이는 비동기 코드에 해당
                      -> 이는 호출 더미(call stack)가 끝나고 '부수 업무 대기열(Micro task Queue)'이 끝나고 실행됨

          2) setTimeout(콜백함수, (선택) 숫자(ms단위))
              : '숫자(ms단위)'에 해당하는 시간이 지난뒤 '콜백함수'의 내용부를 실행
                  -> (중요) 해당 메서드를 통한 콜백함수의 내용부는 기존 쓰레드(thread)가 순차적으로 코드를 호출 더미(call stack)에 올려 수행하는 것과 별개로 '주요 업무 대기열(Macro task Queue)'에 쌓이는 비동기 코드에 해당
                      -> 이는 호출 더미(call stack)가 끝나고 '부수 업무 대기열(Micro task Queue)'이 끝나고 실행됨

          3) clearTimeout(타이머)
              : 원하는 setInterval, setTimeout의 진행을 중단시키는 메서드
                  -> (참고) 보통 setInterval, setTimeout를 변수에 대입시켜서 사용함
                      
                      ex) '타이머' 라는 변수에 setInterval, setTimeout의 반환값에 해당하는 {타이머 객체}의 정보가 저장되고, 이를 통해 원하는 진행중인 타이머 메서드에 접근이 가능함
                      
                          var 타이머 = setInterval(콜백함수, 1000);  
                          clearTimeout(타이머);

          3) alert('문자열')
              : 해당 '문자열'을 브라우저가 알림창 형식으로 띄어주는 메서드

          4) prompt('문자열', (선택) '기본값')
              : 해당 '문자열'을 질문으로 띄우면, 사용자가 '값'을 입력하는 것을 대입하여 반환하는 메서드
                 -> 선택인 2번째 인자(augument)인 '기본값'이 있으면, 이를 입력란에 띄우고 시작

          5) comfirm('문자열')
              : 해당 '문자열'을 질문으로 띄우면, 사용자가 yes/no를 선택함에 따라 true/false를 반환하는 메서드

          6) getComputedStyle({Node 객체})
              : 해당 DOM요소에 해당하는 {Node 객체}에 전역적으로 적용된 모든 형태의 style속성들을 담은 {CSSStyleDeclaration 객체} 형식으로을 반환
                ( {CSSStyleDeclaration 객체} = {Node 객체}.style 프로퍼티에 저장된 해당 {Node 객체}에 적용된 style 정보가 모인 {style 객체})

          7) parseFloat('숫자로 적힌 문자열')
              : 문자'로 된 숫자 -> '부동소수'로 변경해주는 메서드

          8) parseInt('숫자로 적힌 문자열')
              : 문자'로 된 숫자 -> '정수'로 변경해주는 메서드


       @ 스크롤바(scrollbar)와 관련된 {window 전역 객체}의 프로퍼티와 메서드

          1) 스크롤바(scrollbar)와 관련된 {window 전역 객체}의 프로퍼티
              : 스크롤 위치에 대한 정보를 담음
  
                a. scrollX = document.querySelector('html').scrollLeft;
                    : 현재 x축의 스크롤 위치를 px단위로 저장
  
                b. scrollY = document.querySelector('html').scrollTop;
                    : 현재 y축의 스크롤 위치를 px단위로 저장

          2) 스크롤바(scrollbar)와 관련된 {window 전역 객체}의 메서드
              : 스크롤을 강제 이동시키는 기능들에 해당하며, 순간이동이 되지 않는다면, CSS에 :root { scroll-behavior : auto }를 추가함
                  -> (주의) 스크롤 내린 양은 정수 단위 표기 X에 OS 마다 부정확함..  = 스크롤 양의 여유를 두고 비교하는게 좋음
  
                     ex)  끝까지 스크롤했는지? -> 끝에서 10px 정도 남기고 스크롤했는지로 변경
  
                a. scrollTo(x, y)
                    : paramter로 적은 x, y축에 해당하는 (x, y) 좌표에 해당하는 위치에 스크롤을 강제 이동
     
                b. scrollBy(x, y)
                    : 현재 (x, y) 좌표에 해당하는 스크롤 위치에서 x, y축에 적은 숫자만큼 +하여 스크롤을 강제 이동




 - JavaScript 문법들

  1. 변수(variable) & 상수(constant)

     @ JS변수(variable) & 상수(constant)의 특성
        1) 동적 타입 언어(dynamic type)이기에 변수의 자료형에 해당하는 부분은 딱히 존재하지 않고 1~2개(var, let)로 통일 
            -> BUT'값'의 자료형은 존재함... 단지 2)로 인해 casting이 ㅈㄴ 유연해서 그렇지

        2) 엄청난 약타입 언어(very weak type)로서, 자동 형변환(casting)이 매우 유연하게 암묵적으로 이뤄지기까지함


     @ 스코프(scope) {} 개념
        : 변수의 영역(범위)을 설정해주는 일종의 경계이자 결계로 생각하면 되며, function, {객체}, 조건문, 반복문 등등을 사용할 때도 활용됨
           -> 이 결계는 '일종의 특수거울'과 같이 '안에서는 밖을 볼 수 있고, 밖에서는 안을 볼수 없음
               -> 이 결계를 기준으로 밖에서 선언된 변수는 최상위 global scope에 존재한다면 전역변수(global객체 or window객체의 프로퍼티에 해당), 안에서 선언된 변수는 지역변수의 논리가 통용
                   -> (참고!) 수동으로 작성되어 변수에 할당된 {리터럴 객체} 형식은 스스로의 스코프(scope) {} 영역이 존재하지 않음
             
                      (= {리터럴 객체}의 스코프(scope)는 코드상으로는 있는거처럼 보이나, 실제로는 없는 상상 속의 개념 같은 것을 의미)
                         
     @ JS의 변수(variable)
        : 어떤 값을 할당 가능하며, 읽고/쓰기(= rw(read/write)) 가능한 녀석을 의미
           -> (정리된 내용)
                | var   | 변수  재선언O  재할당O  함수{}
                | let   | 변수  재선언X  재할당O  블록{}
                | const | 상수  재선언X  재할당X  블록{}

          1) (ES6 이전) var
              : ES6 이전에 쓰이던 '전역 스코프' or '함수 스코프' 를 기반으로 하는 변수
                (= 함수 스코프{} 만을 기준으로 변수의 영역을 구분하고, 각 영역마다 존재하는 모든 var는 각 함수{}를 기준으로 최상단에 '호이스팅' 됨)
                    -> 일반함수 스코프{}에 속하지 않는 전역변수 영역의 var 변수는 최상위 {전역 객체}인 {window 전역 객체}와 메모리 영역을 자동으로 공유함
                       (= 브라우저의 전역변수 'var 변수 != window.변수')
                           -> BUT! Node JS에서 실행하는 경우, {전역 객체}는 {global 전역 객체}가 되는데, 이 경우는 var 또한 let변수 처럼 {global 전역 객체}와는 영역이 절대 안 겹침!
                              (= Node JS의 전역변수 'var 변수 != global.변수')

                # var 변수 만의 특징

                   1. 함수에 속하는 지역변수는 함수 스코프 {}가 영역의 기준

                   2. 일반함수 스코프{}에 속하지 않는 전역변수인 var 변수는 최상위 {전역 객체}인 {window 전역 객체}와 메모리 영역을 자동으로 공유함
                      (= 브라우저의 최상위 'var 변수 != window.변수')
                         -> BUT! Node JS에서 실행하는 경우, {전역 객체}는 {global 전역 객체}가 되는데, 이 경우는 var 또한 let변수 처럼 {global 전역 객체}와는 영역이 절대 안 겹침!
                            (= Node JS의 전역변수 'var 변수 != global.변수')

                            ex) 브라우저에서의 '전역변수 var'와 {window 전역 객체}의 프로퍼티는 같은 메모리 영역을 공유함
                                 -> 브라우저에서는 b4 == window.b4가 성림
                            
                                    var b4 = 2;
                                    window.b4 = 4;
                                    
                                    console.log(b4 + window.b4);  // 8 = 4 + 4
                            
                            ex) Node JS에서의 '전역변수 var'와 {window 전역 객체}의 프로퍼티는 같은 메모리 영역을 공유하지 않으며, 자동으로 동기화 되지 않음
                                 -> Node JS에서는 b4 != global.b4가 성림
                            
                                    var b5 = 2;
                                    global.b5 = 4;
                                    
                                    console.log(a5 + global.b5);  // 6 = 2 + 4

                   3. 함수 스코프{} or {전역 객체}의 {}를 기준으로 var변수의 영역들을 판별하면, 그에 맞는 영역으로 hoisting(호이스팅) 처리를 해줌
                      (= 오직 함수 스코프 {}만 기준으로 삼음)

                   4. 동일 var변수 재선언 가능
                       -> 어차피 var 나이; 하나 호이스팅(호이스팅) 하고, 나머지는 var를 때서 코드 실행 하여 최종값을 사용함

                          ex) 어차피 최상단 호이스팅 된 var나이;를 제외하면, 나머지는 호출의 형태가 됨
                          
                              var 나이 = 'xx';
                              var 나이 = null;

                # hoisting(호이스팅)
                   : var나 function의 경우 아래에서 선언한 것들이 실행단계에서 최상단에 올라와서 일괄적으로 선언되는 현상
                      -> (중요) let도 호이스팅이 발생...
                           -> BUT! {블록스코프} 개념을 TDZ설정으로 선언 위치와 사용 위치 관계 정립하여 해결

                # function scope (함수 스코프)
                   : 변수의 영역을 정하는 스코프{}의 영역 개념이 function의 경우에만 통용되는 개념
                       -> 함수 스코프 기준으로 지역변수 개념? function의 {}내에서만 통용됨
                          (= var의 호이스팅이 의도치 않게 문제를 만드는 이유)

                          ex) '이름'이라는 var변수는 함수 스코프 {}안에 있어, 호이스팅이 되어도 함수 {}안에 존재

                              function 함수(){
                                var 이름 = 'Kim';
                                console.log(이름); // kim
                              }
                              
                              console.log(이름);   // 에러
                             
                          ex) '이름'이라는 var변수는 조건문 스코프 {}안에 있어, 이를 무시하고 상위 {}로 호이스팅 됨

                               if ( 1 == 1 ){
                                 let 이름 = 'Kim';
                                 console.log(이름); // kim
                               }
                               
                               console.log(이름);   // kim

                # (중요) var의 hoisting(호이스팅)의 특이성
                    : var의 경우 함수의 스코프{} 만을 변수 영역 구분의 기준으로 삼음
                      (= var의 호이스팅은 '조건문'이나 '반복문'의 스코프{}는 깡그리 무시해 버림 )
                          -> (중요) function 여부에 제한받지 않고, 어떤 스코프{}라도 영역 기준으로 인정해주는 변수 let이 등장한 이유

                             ex) var hoisting의 황당함 예시1
                                  -> age변수의 선언보다 사용 시점이 빠름에도 인식이 문제없음
                                     (사실 var age; 부분은 실행 시점에서 맨 위로 올라감)
                             
                                      age = 4;          // 변수 사용이
                                      var age;          // 선언 시점보다 빠르다... (이 녀석이 호이스팅 됨)
                                      console.log(age); // 4  <- 근데 문제없이 인식했다?! 

                             ex) var hoisting의 황당함 예시2
                                  -> age변수를 감싸는 {}이 존재함에도, 이를 무시하고 상위스코프로 호이스팅 해버림
                                     (여전히 var age; 부분은 실행 시점에서 {}를 무시하고 더 위로 올라감)

                                      {
                                        age = 4;          // 변수 사용이
                                        var age;          // 선언 시점보다 빠르다... (이 녀석이 호이스팅 됨)
                                      }

                                      console.log(age); // 4  <- 근데 문제없이 인식했다?! 

                             ex) var hoisting의 황당함 예시3
                                  -> 반복문의 index에 해당하는 변수 i는 모든 반복에 대해 반복문 스코프{}가 아닌 상위 스코프{}에 var i라는 동일한 변수를 참조함
                                     (사실 var i; 부분은 실행 시점에서 맨 위로 올라가고, setTimeout을 통해 1초 후 반복문들을 코드를 실행하는 시점에서는 이미 반복이 끝나 i = 5가 들어가 있음)
                                       -> (중요) 해당 사항이 문제가 되는 부분은 반복문에 들어가는 코드가 당장 콜스택(callstack)에 들어가지 않고, 주요 업무 대기열(macro task queue)나 보조 업무 대기열(micro task queue)에 들어가서 나중에 실행되는 경우에 있음

                                     예시1) setTimeout의 경우

                                            for (var i = 0; i < 5; i++) {
                                                setTimeout(function() {
                                                    console.log(i);          // 5 5 5 5 5 출력
                                                }, 1000);
                                            }

                                     예시2) addEventListener의 경우
                                             : var의 경우 i, j 둘 다 for문의 {} 밖에 생성되어 추후 뭘 눌러도 [4]에 해당하는 같은 이벤트만 수행됨, 
                                               let의 경우 i, j의 반복문이 진행될 때마다, 매번 새로운 {}을 전개하고 index를 해당 {}의 새로운 변수를 생성하여 대입하여 해당 {}에 index는 고정되게 설정함
                                     
                                               for (var i = 0; i < 5; i++) {
                                                  document.querySelectorAll('.tab-button')[i].addEventListener('click', function (e) {
                                      
                                                      for(var j = 0; j < 5; j++){
                                      
                                                          if(i == j){
                                                              document.querySelectorAll('.tab-button')[j].classList.add('orange');  
                                                              document.querySelectorAll('.tab-content')[j].classList.add('show');  
                                                          }else{
                                                              document.querySelectorAll('.tab-button')[j].classList.remove('orange');  
                                                              document.querySelectorAll('.tab-content')[j].classList.remove('show');  
                                                          }
                                                      }
                                                  });
                                               }

          2) (ES6 이후) let
               : ES6에 추가된 '블록 스코프'를 기반으로 하는 변수 
                 (= 함수 스코프{}와 {window 객체}, {global 객체}과 같은 {전역 객체} 스코프{} 만을 영역의 기준으로 삼아 hoisting을 일삼던, 상식을 벗아나는 var변수의 약점을 일반적 언어의 변수들의 원칙이 적용되는 방향으로 보완)
                     -> (중요) '블록 스코프'를 기반 let는 아무리 최상위에 선언되도 {전역 객체} 스코프{}에 속하지 않음

                # block scope (블록 스코프)
                   : {}로 직접 변수들이 통용되는 영역 구분을 위한 '결계'와 같은 영역을 설정
                       -> (참고!) 수동으로 작성되어 변수에 할당된 {리터럴 객체} 형식은 스스로의 스코프(scope) {} 영역이 존재하지 않음
                          (= {리터럴 객체}의 스코프(scope)는 코드상으로는 있는거처럼 보이나, 실제로는 없는 상상 속의 개념 같은 것을 의미)

                # let 변수 만의 특징
                   1. var의 문제점을 보완하기 위해 탄생
                      (= var는 '함수 스코프'를 기반으로 하며, 이 부분으로 인해 hoisting 이슈가 발생)

                   2. 동일 var변수 재선언 불가능
                      (= 코드 크기가 늘어나는 상황에서, 변수만든거 또 만들고 그런 실수를 방지해줌)

                      ex) 이러면 닥치고 에러 발생함
                      
                          let 나이 = 'xx';
                          let 나이 = null;

                   3. for, if, function에 제한되지 않고, 어디에서라도 {}를 기준으로 한 블록 스코프 {}를 기준으로 변수들의 영역을 판별함
                      (= 모든 {}가 let의 범위를 따지는 영역의 기준)

                   4. (중요) let 변수는 블록 스코프의 특성으로 인해 {window 객체}, {global 객체}과 같은 {전역 객체}와 독립적으로 작동함
                       (= 뭔 짓을 해도 let 변수로는 {전역 객체}의 변수로 선언이 불가능함)

                       ex) a4는 let으로 선언되어 최상위 레벨에서 선언되도, {window 전역 객체}와 동일하게 취급되지 않음
                            -> a4 != window.a4가 성립

                               let a4 = 1;
                               window.a4 = 3;
                               
                               console.log(a4 + global.a4);  // 4 = 1 + 3

                   5. for문에서 index 변수를 let으로 설정하는 경우, 각 반복(iteration)마다 해당되는 스코프 {}이 생성되고, 거기에 변수가 생성된 뒤 현재 반복 index값을 대입한 뒤 해당 반복문 내용을 작성함
                        -> 그렇게 만들어진 각 반복의 영역에 해당하는 {}는 해당 반복 {} 내부에서만 접근 가능하며, 각 {}의 index값은 늘 고정됨
                            -> (중요) 이 부분이 콜스택 이후 실행되는 주요 업무 대기열(macro task queue)나 보조 업무 대기열(micro task queue)에 해당하는 코드가 들어있는 반복문의 내용도 늘 일정함을 보장해주는 부분임

                               ex) i는 let으로 선언되었기 때문에 각 반복마다 새로운 블록 스코프가 생성
                                   (= 반복문이 한 번 실행될 때마다, i는 해당 블록 스코프에서 새로운 변수로 생성되고 유지)
                                       -> i값은 해당 반복의 블록 스코프에 고정되어 있기에, 나중에 실행되더라도 각 i 값은 올바르게 유지

                                          for (let i = 0; i < 3; i++) {
                                              setTimeout(function() {
                                                  console.log(i);
                                              }, 100);
                                          }

                   6. TDZ개념을 도입하여, 변수를 선언하기 이전에 사용을 할수 없다는 원칙을 구현
                      (TDZ : Temperary Dead Zone의 약자로, 해당 스코프에서 변수 선언 위치 이전 영역을 의미함)
                        -> let의 경우 변수 선언 이전에 사용을 하게 되면, error를 호출


     @ JS의 상수(constant) const
        : 어떤 값을 일단 한번 할당히면, 오직 읽기(= r(read))만 가능한 녀석을 의미 
          (= const로 선언된 상수에는 '값'의 재할당이 불가능함)

         # 상수(constant)를 쓰는 이유(장점)
            : '값'의 재할당이 불가능하다는 부분에서 장점이 존재
               (= 혹시라도 절대로 수정되면 안 되서, 나중에 값을 변경하는 실수를 방지하고 싶을 때 상수를 사용하면 방지 가능)

               1) 보안적으로 유리
               2) 복수의 쓰레드를 사용하는 경우, 동시다발적 접근으로 인해 프로그램이 개판되는 상황을 방지 가능
               3) 사람의 실수 가능성을 원천적으로 줄일 수 있음

         # const의 약점
            : const에 할당된 게 {객체}인 경우, 그 {객체}의 프로퍼티의 값들은 모두 재할당을 통한 변경 가능 
              (= 상수 써봐야 {객체} 내부의 값까지 방어가 불가능하다 이 말임)
                  -> WHY? {객체}는 엄밀하게는 heap영역의 메모리 영역을 참조값(reference)로 가지고 있을 뿐이고, const가 재할당 못하게하는 대상은 그 참조값이지 그 참조값이 가르키는 위치의 데이터들이 아님
                      -> {Object 객체}의 freeze()라는 메서드를 통해, ()안에 프로퍼티와 값들을 담으면 {frozen 객체}라고 내부 프로퍼티 값들의 재할당이 불가능하게 만들수는 있음
                          -> BUT! {frozen 객체}라도 또 그 내부의 프로퍼티의 값이 {객체}에 해당된다면, 그 {객체} 내부의 프로퍼티까지 freeze해주진 않음...
                             (= 추후 TypeScript에서 이 부분 자료형 정의에 힘쓰는 이유) 



  2. 자료형(types)
     : JS에서 인식하는 어떤 '값'을 해석하는 방식의 종류를 의미

        @ 대분류적 종류에 따른 구분

          [1] primitive (원시형)
             : number, string, boolean, null, undefined, symbol 과 같은 단일 변수로 값이 직접 변수에 저장되고 복사되는 불변의 자료형
                -> (참고) 0, '', null, undefined, NaN, false는 JS에서는 형변환이 하지 않고, 같은 falsy에 해당하는 같은 false로 인식함 (하단의 Truthiness개념 참고)
  
                   1) number
                       : integer(정수), decimal number(소수)던 상관없이 하나로 통일
                         (= 기본적으로 JS의 숫자 자료형은 int와 같이 정수에 해당하는 자료형이 없고, 64비트 부동소수점에 해당하는 JAVA에서는 double에 해당하는 자료형으로 통일됨)
                  
                         # number 자료형의 범위/정밀도
                            - 범위   : ±(2^-1074) ~ ±(2^1023)
                            - 정밀도 : 최대 소수점 이하 17자리
                                      
                         # 특수한 number값 유형
                            a. infinity (양의 무한)
                            b. -infinity (음의 무한)
                            c. NaN (Not A Number : 숫자가 아닌데, 숫자로 출력해야 하는경우 나오는 값)
                               : Not a Number의 의미의 숫자 연산이 유효하지 않을 때 반환되는 숫자(Number) 자료형의 특수값   
                                  -> (NaN값의 특징)
                                       a. falsy에 해당하는 number 자료형의 값
                                       b. 어떤 값과 연산을 하더라도 그 결과는 NaN이 반환
                                          
                                          ex) NaN + 5        -> NaN이 반환
    
                                       c. 동등 연산자(==)를 통해서 자신(NaN)과 비교해도 같지 않음
    
                                          ex) NaN == NaN;    -> false가 반환
                   
                         # (ES6 이후) bigInt 타입
                            : Java의 bigInt와 같이 기존 소수값 변수(자바의 경우 double)보다 더 큰 값을 표현가능한 변수타입
              
                         # 정수 자료형이 없는 JS의 문제점
                            1) (중요) 정확도 문제
                                : 부동소수점 연산시 정확도 문제
                                  (= 2진법으로 부동소수점을 표현시 그 특성상 오차가 발생 = 숫자 비교를 수행할 때의 부정확성이 존재)
                                      -> 해결하고 싶다면?
                                          :  반올림(.toFixed() 같은 메서드 or 수동으로 '대상 / 10 * 10')하거나 외부 라이브러리 사용
  
                                  ex) console.log(0.1 + 0.2);
                                       -> 0.3이 아닌 0.30000000000000004 출력...
  
                                  ex) itemsInCart가 30000000000000004이라 조건문의 코드가 실행되지 않음
                                  
                                      let itemsInCart = 0.0;
                                      itemsInCart += 0.1;
                                      itemsInCart += 0.2;
                                      
                                      if (itemsInCart === 0.3) {
                                          console.log('Cart has 0.3 items'); 
                                      }
  
                            2) 데이터 일관성 문제
                                : 정수로 다뤄야 할 데이터에 소수를 끼얹어도 타언어들처럼 정수가 아니라고 에러를 뱉는 것을 할 수 없음
                                  (= 정수를 다뤄야 할 때, 정수의 일관성을 유지할 수 없음)
  
                            3) 정수 연산시 성능 문제  
                                : 정수 자료형으로 정수를 계산하는 것에 비해, 정수연산도 쓸데없이 부동소수점으로 하니 연산의 성능 저하
  
                            4) 정수 표현 범위 제한 문제
                                :  부동소수점으로 읽는 방식의 특성상 안전하게 표현될 수 있는 정수의 최대 범위가 제한적
                                   (Number.MAX_SAFE_INTEGER ~ Number.MIN_SAFE_INTEGER 범위 밖의 정수는 정확하지 않을 수 있음)
  
                         # number의 메서드
                            : '숫자.메서드명(...parameter)' 메서드 체이닝 형식으로 호출
  
                               1) 숫자.toFixed(원하는소수님자리수)
                                   : 해당 숫자가 실수인 경우, 원하는 소수점 자리수에 해당하는 자리수로 반올림해주는 메서드..
                                      -> (주의) 해당 메서드의 반환값은 '문자열'이니, 추후 연산을 할거면 반드시 형변환을 해줘야 함
  
                                          ex) (1.4).toFixed(1)
  
                               2) Number(값)
                                  : 해당 함수의 매개변수(paramter)에 대입된 인자(augument)에 해당하는 값의 자료형을 숫자로 바꿔주는 함수
  
                                   - parameter의 자료형에 따른 Number(값)
  
                                      a. Number('문자열')
                                          : 문자열은 숫자 형식이라면 그에 맞게 변환하나, 숫자라고 할 수 있는게 아니면 NaN반환
                                            
                                            ex) Number('123')  -> 123
                                                Number('ABC')  -> NaN
             
                                      b. Number(boolean)
                                          : true = 1, false = 0 로 변환
             
                                            ex) Number(true)  -> 1
             
                                      c. Number(null) = 0
                                      d. Number(undefined) = NaN
  
                          # (중요) 'string'과 '+' 연산자
                            : JS는 동적 자료형과 극한의 약타입에 해당하는 언어의 특성 상, '산술 연산자'나 '논리 연산자' 관련 연산을 수행시 꼴리는데로 형변환(casting)을 시도해서 사람을 복창터지게 하는 특성이 있음
                               -> '+' 연산자의 경우 대상자 중 하나라도 '문자'가 들어가면, 나머지 대상도 자동으로 문자로 형변환해서 문자열 붙이기 연산을 수행해버림
  
                                  ex) '+' 연산자를 쓸 때, JS런타임 환경은 엄격하게 지정한게 아니면 '문자열'로 형변환을 시도하려는 경향이 있다는거 참고
  
                                       1  +  1  =  2 
                                       1  + '1' = '11'
                                      '1' + '1' = '11'
  
                   2) 'string'
                        : '문자'에 대한 자료형으로 '문자열'의 경우는 [배열]개념으로 조합되어 있기에, 원하는 위치의 문자를 찾는것이 가능
  
                         # 'string' 메서드
                            : string 자료형으로 입력된 '문자열'을 조사/탐색/변경 등을 수행할 때 유용한 기능을 제공
  
                              a. includes('문자열')
                                  : 어떤 string 형식의 문자열 값에 '문자열'과 완전히 일치하는 부분이 존재하는지를 true/false의 boolean값으로 반환
  
                              b. String(값)
                                  : 해당 함수의 매개변수(paramter)에 대입된 인자(augument)에 해당하는 값의 자료형을 '문자열'로 바꿔주는 함수
  
                                    - parameter의 자료형에 따른 정리
  
                                       [1] String(숫자)
                                            : '숫자' 형식의 문자열로 변경
                                             
                                               ex) String(123)  -> '123'
                
                                       [2] String(boolean)
                                            : true는 'true'
                                              false는 'false' 로 변환
                
                                               ex) String(true)  -> 'true'
                
                                       [3] String(참조자료형)
                                            : toString() 메서드를 사용하여 문자열로 변환
  
                                       [4] String(특수값)
                                            : null, undefined, NaN이 각각 '문자열'로 변환
  
                                              ex) String(null);      -> "null"
                                                  String(undefined); -> "undefined"
                                                  String(NaN);       ->  "NaN"
  
                              c.  규식형식/.test('검사할 문자열') 
                                  : '검사할 문자열'의 형식이 작성된 /정규식/의 규칙을 준수하는지를  true/false의 boolean값으로 반환
  
                                    ex) /\S+@\S+\.\S+/.test('검사할 이메일주소') 
                                         : '검사할 문자열'이 '아무문자들모음@아무문자들모음.아무문자들모음' 형식이면 통과
  
                                   - (참고) JS에서의 정규식 작성 규칙
                                      A. JS의 정규식은 /정규식규정/과 같은 양식으로 // 안에 적음
                                          -> (중요) '+' 기호가 없는 /정규식/은 연속성과 순서를 따지지 않고, 해당 문자들이 있는지 없는지 여부만 체크
  
                                             ex) /a/
                                                  : 문자열에 a가 1자 들어가 있는지를 체크
  
                                             ex) /acd/  
                                                  : 문자열에 a, c, d 중 1자라도 들어가 있는지를 체크   
  
                                      B. []안에 - 기호를 사용하면, 허용문자들을 일일히 적지 않고 범위를 지정할 수 있음
                                         (= A와 같이 노가다를 할 필요가 없음)
  
                                         ex) /[a-d]/
                                              : 문자열에 a부터 d까지의 아무 문자라도 1개 이상 들어가 있는지를 체크
  
                                         ex) /[a-zA-Z]/ 
                                              : 문자열에 대/소문자 상관없이 아무 알파벳 문자라도 1개 이상 들어가 있는지를 체크
  
                                         ex) [ㄱ-ㅎ가-힣ㅏ-ㅣ] 
                                              : 문자열에 한글 자음/모음/모든 글자 중 1개 이상 들어가 있는지를 체크
  
                                      C. 정규식에 사용되는 특수문자들은 다음과 같으며 그 의미는 이러함
  
                                          a. \S   
                                              : '문자열에 특수문자 포함 아무문자라도 1개 이상 들어가 있는지'를 체크
  
                                          b. ^문자 
                                              : '문자열이 해당 문자로 시작하는지'를 체크
                                            
                                                ex) ^a
                                                    : 어떤 문자열이 a로 시작하는지를 체크
  
                                          c. 문자$
                                              : '문자열이 해당 문자로 끝나는지'를 체크
  
                                                ex) e$
                                                    : 어떤 문자열이 e로 끝나는지를 체크
  
                                          d. (문자1|문자2)
                                              : '문자열이 문자1, 2 중 하나만 가지고 있어도 OK'를 의미하는 OR의 의미를 가진 부호
                                                 
                                                 ex) /(e|f)/
                                                      : 문자열에 e나 f가 1개 이상 들어가 있는지를 체크
                                                        (= /(e|f)/ == /ef/)
  
                                          e. 문자+
                                              : '문자열에 해당 문자가 연속으로 나오는지'에 대한 문자의 연속성을 체크
  
                                                 ex) /a+/
                                                      : 'aaaaaa'와 같이 문자 'a'가 반복되는지 여부를 체크
  
                                          f. 문자1+문자2
                                              : '문자1에 해당 문자가 연속으로 나오고 난 뒤, 문자2가 나오는지'까지와 같이 문자의 연속성 및 순서까지 체크                                           
                                                  -> (중요!) /문자+문자+문자/ 이런식으로 문자열이 양식에 맞게 원하는 순서에 맞게 문자가 등장하는지를 체크가 가능함
  
                                                      ex) /\S+t/
                                                           : '아무문자들모음' 다음에 t가 등장하는지 여부를 체크하는 정규식
  
                                                      ex) /\S+@\S+\.\S+/
                                                           : '아무문자들모음@아무문자들모음.아무문자들모음' 형식인지 체크
  
                         # (중요) 'string'과 '+' 연산자
                            : JS는 동적 자료형과 극한의 약타입에 해당하는 언어의 특성 상, '산술 연산자'나 '논리 연산자' 관련 연산을 수행시 꼴리는데로 형변환(casting)을 시도해서 사람을 복창터지게 하는 특성이 있음
                               -> '+' 연산자의 경우 대상자 중 하나라도 '문자'가 들어가면, 나머지 대상도 자동으로 문자로 형변환해서 문자열 붙이기(String concatenation) 연산을 수행해버림
  
                                  ex) '+' 연산자를 쓸 때, JS런타임 환경은 엄격하게 지정한게 아니면 '문자열'로 형변환을 시도하려는 경향이 있다는거 참고
  
                                       1  +  1  =  2 
                                       1  + '1' = '11'
                                      '1' + '1' = '11'
  
                         # (참고) ''로 선언한 문자열에 특수기호를 넣고 싶다면?
                             : \n (줄바꾸기), \' (쉼표) 등 \를 사용해서 알아보면 됨                      
  
                         # parseFloat('123'), parseInt('123') 
                             : '문자'로 된 숫자 -> '숫자' 변경해주는 함수 (각각 부동소수점, 정수로 변환)
  
                         # (ES6 이후) `template literals`
                             : `(백틱) 부호를 이용하여, 문자열을 입력 가능하게 하는 또 다른 방법으로 ''와 다른 이점이 존재
  
                                a. ${JS변수명}과 같은 방식으로 JS변수를 문자열에 쉽게 가져올 수도 있도록 템플릿(template)적 요소와 기능을 추가함
                   
                                   ex) helloBob를 출력해보면, 'hi brendan'으로 출력됨
                                   
                                       const brendan = 'brendan';
                                       const helloBob = `hi ${brendan}!`;
  
                                b. ''와 다르게 줄바꿈이 정말 쉬움
                                    -> \n (줄바꾸기) 를 쓰지 않고, `` 안에서 그냥 enter키 눌러서 코드상의 줄바꿈을 해도 줄바꿈으로 인식함
                   
                                       ex) 문자라는 변수의 문자열은 줄바꿈을 이미 인지 중
                                       
                                           var 문자 = `안녕
                                           하세요`;
  
                                c. ${변수명}과 줄바꿈 편의성을 이용하여, <HTML> 내용을 작성하고 인지시키는 것도 참 쉬워짐
                                    -> ''를 사용하면... '+'와 '\n'과 "'"와 같은 끔직한 특수기호와 함께 속성값까지 입력하는 참극이 시작됨...
                   
                                       ex) 이런식으로 특수문자와 +연산자 뻘짓 없이 <HTML> 내용을 입력가능
                                       
                                           var 문자 = `<div>
                                                         <div class='${속성명}'>
                                                           ${변수명}
                                                         </div>
                                                       </div>`;
  
                          # (ES6 이후) Tagged Literals
                              : 함수를 실행시키는 또 다른 문법에 해당하는 방법으로 `(백틱)으로 감싸진 문자열(string)인 `template literals`를 해체하여, 문자 중간 중간에 있는 단어 순서를 바꾸거나 변수를 제거하거나 하는 기능
                                 -> (참고) 정확히는 함수를 호출하는 방식이 Tagged Literals 방식에 해당하면, Tagged Literals 방식으로 실행해주는듯함
  
                                     a. Tagged Literals 함수 선언법
                                         : TL함수명(1번째 parameter명, ... parameters){
                                              TL함수 내용부
                                           }
  
                                     b. Tagged Literals 함수 선언시 parameter들이 의미하는 것
                                         : parameter들이 각각 `원본 문자열`을 분리한 결과를 가지고 있음을 가정하기에 `문자열`을 재조합하거나 분석가능
  
                                           - 1번째 parameter
                                               : `(백틱)으로 감싸진 문자열(string)인 `template literals`에서 순수 문자열들만 선별해 [배열]로 저장한 변수에 해당
                                                   -> Tagged Literals 함수가 호출시 `원본 문자열`을 분해를 해줄 것을 전제로 함 
    
                                                      ex) 다음을 Tagged Literals 함수가 해체해서 1번째 paramter로 담는 [배열] = [`안녕하세요`, `나는` , `입니다`];
  
                                                          var 직업 = `축구선수`;
                                                          var 이름 = `손흥민`;
  
                                                          function 해체분석기(문자배열, 변수1, 변수2) { ~~ }; 
  
                                                          해체분석기 `안녕하세요 나는 ${직업} ${이름} 입니다` 
    
                                           - 그 이후 모든 parameter들
                                               : `template literals`에서 ${변수명} 방식으로 들어간 (n-1)번째 변수에 해당하는 값들을 각각 저장한 변수에 해당
                                                   -> `template literals` 내부의 변수가 n개다 그러면, 그만큼 파라미터를 뒤에 더 추가하면 됨
  
                                                      ex) 다음을 Tagged Literals 함수가 해체해서 2번째 paramter로 담는 내용 = `손흥민`
  
                                                          var 직업 = `축구선수`;
                                                          var 이름 = `손흥민`;
  
                                                          function 해체분석기(문자배열, 변수1, 변수2) { ~~ }; 
  
                                                          해체분석기 `안녕하세요 나는 ${직업} ${이름} 입니다` 
                                                     
                                     c. Tagged Literals 함수 호출법
                                         : TL함수명 `template literals 방식의 문자열(${변수명}까지 사용 포함)`
                                             -> 이렇게 호출하면, a에서 선언한데로 Tagged Literals 함수가 실행됨
  
                                                ex) 해체분석기 호출의 결과는 `나는축구선수손흥민`
  
                                                     var 직업 = `축구선수`;
                                                     var 이름 = `손흥민`;
  
                                                     function 해체분석기(문자배열, ...변수들) { 
                                                       console.log(문자들[1] + 변수들); 
                                                     }; 
  
                                                     해체분석기 `안녕하세요 나는 ${직업} ${이름} 입니다` 
  
                   3) boolean
                       : 참/거짓... 
  
                        # Boolean(값)
                           : 해당 함수의 매개변수(paramter)에 대입된 인자(augument)에 해당하는 값의 자료형을 Boolean로 바꿔주는 함수
                             (= 그러니까 Boolean(값)은 어떤 값을 boolean 자료형으로 형변환(type colution)을 시켜주는 함수)
                                 -> BUT! 하지만 Truthiness 개념을 사용하는 JS에서는 굳이 안 그래도 됨
  
                            - Boolean(값)의 연산결과 
  
                               a. Boolean(falsy값) = false
                                   : 0, NaN, null, undefined, '' (빈 문자열)에 해당하는 값이 parameter로 들어가면 false 반환
                                     
                                  ex) Boolean(0)         -> false
                                      Boolean(NaN)       -> false
                                      Boolean(null)      -> false
                                      Boolean(undefined) -> false
                                      Boolean('')        -> false
  
                               b. Boolean(truethy값) = true
                                   : 1번에 해당하지 않는 모든 값들은 다 true 반환
  
                                     ex) String(true)  -> 'true'
  
                        # Truthiness 개념
                           : JS에서의 모든 자료형의 값들은 boolean 맥락(context)적으로 그 값 자체로 참과 거짓을 판별하는 Truthy / Falsy 개념으로 true / false를 판별
                             (= JS에서는 어떤 값의 true / false를 판별할 때, 따로 형변환(type colution)를 하지 않고, 그 자체로 boolean값으로 판별이 가능함)
    
                            a. falsy
                                : 자료형에 따라 false에 대응하는 값들에 해당하는 경우  (= 그 외의 값은 true으로 평가)
                                   -> (중요) 0, null, undefined, NaN, "", false, -0, 0n
             
                                      ex) false에 속하는 값들 equality 예시
                                      
                                          console.log(0 == false);          // true
                                          console.log(0 === false);         // false : 0은 number =/ false는 boolean
                                          console.log('' == false);         // true
                                          console.log('' === false);        // false : ''은 string =/ false는 boolean
                                          console.log(null == undefined);   // true
                                          console.log(null === undefined);  // false : null과 undefined는 다른 자료형
    
                            b. Truthy
                                : 자료형에 따라 true에 대응하는 값들에 해당하는 경우  
                                  (= Falsy에 해당하는 녀석들 이외의 참조자료형(reference type)을 포함한 모든 값들에 해당하며, 이들을 모두 true으로 평가)
                                      -> (중요) {객체}, function, Symbol에 해당하는 것들과 infinity와 같은 특별한 값들도 전부 true에 해당!
                   
                   4) undefined
                       : 값이 그냥 비었을경우에 할당되는 자료형 그 자체
                         (= undefined는 사용자는 개입한거 없이, 의도하지 않았는데 값이 없을 때 등장하며, 그 자체가 undefined 자료형에 해당)
  
                        # undefined 자료형의 특징
                           a. falsy에 해당하는 자료형
                           b. null과는 느슨한 동등 연산자(==)를 통해 비교 연산시 true가 도출
                              (= NaN은 그 자신과도 같은 값이 아니니, 당연히 느슨한 동등 연산자(==)를 통해 비교 연산시 false가 도출)
    
                              ex) null == undefined;  // true
                                  NaN == NaN;         // false
    
                           c. 숫자로 형변환 된다면, NaN으로 변환되어 사용되거나 연산됨
                           
                              ex) undefined + 5;    ->  NaN
                              ex) Number(undefined) ->  NaN
  
                        # undefined 자료형과 null값, NaN값 공통점/차이점 정리
  
                           - 공통점
                              a. 특수한 경우에 해당하는 값이나 자료형에 해당
                                 (= 형변환 or 느슨한 동등 연산자(==) 처리에서 고유의 예외처리가 됨)
  
                              b. Falsy 값으로 평가 
                                 (= boolean으로 형변환시 모두 false)
  
                                 ex) Boolean(null);      ->  false
                                     Boolean(undefined); -> false
                                     Boolean(NaN);       -> false
  
                              c. '문자열'로 형변환시 각각 '자신의 이름'이 문자열 처리됨
  
                                   ex) String(null);      -> "null"
                                       String(undefined); -> "undefined"
                                       String(NaN);       ->  "NaN"       
                  
                           - 차이점
                              a. undefined는 그 자체가 자료형에 해당   <->   null은 {객체}의 특수값, NaN은 Number의 특수값에 해당
                              b. falsy값이지만, 각각 falsy값 그 자체로 느슨한 동등 연산자(==)가 true가 나오는건 null과 undefined만 해당됨
                                 (= NaN은 그 누구와도 ==가 false가 됨)
  
                                   ex) null == undefined;   -> true
                                       NaN == NaN;          -> false
  
                              c. Number로 형변환 시
                                  : null은 0으로 변환되어 산술 연산 가능  <->  undefined와 NaN은 NaN으로 변환되어 산술 연산의 결과로 무조건 NaN이 반환
                                    (= 산술 연산으로 인한 강제 형변환 발생시에도 똑같은 원칙이 적용)
  
                                    ex) Number(null);      ->  0
                                        Number(undefined); -> NaN
                                        Number(NaN);       -> NaN
  
                                    ex) null + 5         ->  5
                                        undefined + 5;   -> NaN
                                        NaN + 5;         -> NaN
                                        null + undefined -> NaN
  
                   5) (ES6 이후) Symbol
                       : 어떤 { Object } 자료형의 값에 공개되지 않은 비밀스런 key값(= 프로퍼티)를 부여할 필요가 있을 때 사용하는 자료형
                         (= 정확히는 Symbol 타입의 값 자체가 어떤 {객체}의 비밀스런 key값(= 프로퍼티)에만 해당하는 값에 포함됨)
                             -> for문이나 for in 같은 방법으로 해당 {객체}의 프로퍼티 순회시 이를 보여주지 않는 개념에 가까움
                                (= 캡슐화와 접근제어자 private를 썼을 때, 해당 프로퍼티에 외부 {객체}에서 접근이 불가능 한 것과는 전혀 다름)
               
                         # 어떤 {객체}에 Symbol에 해당하는 for문에 걸리지 않는 비밀스런 key값을 만들고 사용하는 방법
  
                           A. var, let 변수명 = Symbol('주석내용')
                               : 생성된 Symbol값을 변수에 할당받아서, 이를 어떤 {객체}의 비밀스런 key값(= 프로퍼티)으로서도 바로 할당될 수 있게 준비함
  
                           B. Symbol값이 할당된 '변수명'을 특정 {객체}의 '프러퍼티'에 접근하듯 사용한 뒤, value에 해당하는 값을 할당
  
                              a. 생선된 {객체}의 프로퍼티로서, '객체명[변수명]'으로 접근
  
  
                              b. {객체}를 생성할 때, Symbol값의 value값도 같이 입력
                                   -> {객체} 정의할 때, Symbol값을 프로퍼티로서 같이 입력하고 싶다면, { ... , [변수명] : value값} 이렇게 입력하자
  
                                      ex) var height = Symbol('내 키임');
                                          var person = { name : 'Kim', [height] : 160 };
  
                         # Symbol 타입값 관련 함수
                            : 새로운 Symbol값을 생성하면, 해당 Symbol값은 어떤 {객체}의 비밀스런 key값(= 프로퍼티)으로서도 바로 할당될 수 있음
  
                              a. Symbol('주석내용')
                                  : Symbol 타입에 해당하는 값을 생성하는 생성자에 해당.. 
                                     -> BUT! '주석내용'과 관계없이, 각 Symbol() 생성자를 사용해서 생성된 Symbol값은 별개임
                                        (= class생성자를 사용해서 만든 {객체}와 유사함)
                            
                              b. Symbol.for('주석내용')
                                  : 전역 Symbol 타입에 해당하는 값을 생성하는 생성자에 해당.. 
                                     -> BUT! '주석내용'이 같은 Symbol값은 같은 값으로 인정
                   
                         # Symbol 자료형의 주요 특징
                            a. 고유성
                                : 같은 '주석내용'이라도, 각각 Symbol() 생성자를 통해 생성한 Symbol 타입은 다른 Symbol로 인정
                                    -> obj[Symbol('mySymbol')] 식으로 Symbol() 생성자를 index처럼 직접 쓰지 못하고, 변수에 할당해서 쓰는 이유가 여기에 있음
                   
                                       ex) Symbol('주석내용')을 각각 사용해서 생성된 경우, '주석내용'이랑 상관없이 다른 Symbol값(= 다른 프로퍼티명)으로 인정됨
                                           (= class생성자를 사용해서 만든 {객체}와 유사함)
                   
                                           const symbol1 = Symbol('id');
                                           const symbol2 = Symbol('id');
                                           console.log(symbol1 === symbol2);    // false에 해당
                   
                            b. (중요) 전역 Symbol값의 존재
                                : Symbol.for('주석내용') 메서드를 통해 전역 Symbol을 만들 경우, '주석 내용'이 같을 경우 같은 Symbol값으로 인정됨
                   
                                  ex) Symbol.for()를 통해 만들어진, 2개의 Symbol 타입 값은 같은 주석인 '설명1'을 가졌기에, 같은 Symbol값으로 인정됨
                   
                                      var a = Symbol.for('설명1');
                                      var b = Symbol.for('설명1');
                                      console.log(a === b);                    // true에 해당
                   
                            c. 공개되지 않는 프로퍼티(= 접근자체는 가능)
                                : for문으로 순회시 안 보일 뿐이지, '객체명[심볼명]'으로 접근이 가능하며, '객체명'으로도 볼수 있음
                                   -> 공개되지 않은 비밀스런 key값(= 프로퍼티)이기 때문
                   
                            d. 기본적으로 내장된 Symbol인 'Symbol.내장Symbol명'
                               (= {Object 객체}의 프로퍼티와 유사한 용도이나... 이미 존재하는 {Object 객체}를 손댈수는 없으니.. ES6부터 추가된 기능에 대해 Symbol로 이를 구현한 걸로 추측)
                                : JS에는 기본적으로 정의된 기본적인 Symbol 타입이 존재하며, 'Symbol.내장Symbol명' 형식으로 호출
                   
                                  ex) Symbol.iterator
                                       : ES6에서 {객체}, [배열] 등의 iterable한 특성이 있는 {객체}의 기본 iterator를 정의하어, for of 반복문을 사용할 수 있도록 함
                                       
                                         ex) arr[Symbol.iterator]()로 arr라는 변수에 할당된 이터러블 객체에 해당하는 [배열]의 내장 Symbol로 정의된 iterator에 관련된 기능을 쓸 수 있게 함
                                         
                                             let arr = [1, 2, 3];
                                             let iterator = arr[Symbol.iterator]();
                                             console.log(iterator.next());          // { value: 1, done: false }
  
          [2] 참조 자료형(reference type)
               : [배열], {객체}와 같이 여러 종류의 복수의 값들이 저장된 힙(heap)영역의 메모리 주소를 참조값(reference)으로 저장하여, 이를 통해 자신과 연관된 데이터에 접근하는 형태의 자료형
                 (= 참조 자료형 자체를 직접 조사해봐야 '힙(heap)영역의 메모리 주소'에 해당하는 값 밖에는 존재하지 않음... 포인터가 열려있는 보다 저수준의 C계열 언어는 이를 조작 가능)
                     -> 메모리 주소를 참조값(reference)으로 저장하기에 원시형 같은 값이 대입으로 복사해봐야 주소값만 복사되는 '얕은 복사(shallow copy)'가 일어나 제대로 된 복사가 이뤄지지 않음
                        (= 제대로 된 복사를 위해서는.. 참조하는 주소에 위치한 heap영역의 값들을 하나하나까서 목표하는 heap영역에 위치한 컨테이너 요소들에 대입해주는 '깊은 복사(deep copy)')
  
                # 참조(reference)값에 대한 이해
   
                  1) 참조 자료형(reference type) 그 자체의 값 = 복수의 값들이 저장된 힙(heap)영역의 메모리 주소에 해당
                     (= 단순 =연산자를 통한 대입으로는 그저 해당 변수에 저장된 참조값인 힙(heap)영역의 메모리 주소만 복사하고, 같은 위치의 heap영역의 값들을 볼 수 있을 뿐임)
   
                  2) (중요!) 두 변수가 둘 다 참조 자료형(reference type) 형태의 내용을 저장한다 쳤을 때, 그 저장된 내용이 같아보인다고 '=='로 표현되는 같음은 성립하지 않음
                      -> 참조 자료형(reference type)의 값이 같다는 건 참조하는 힙(heap)영역의 메모리 주소가 같음을 의미함
   
                         ex) 이름2는 이름1의 참조값인 {객체}가 저장된 메모리주소값을 복사해 온 것이기에... 
                              -> 이름1이 참조하는 주소의 {객체}의 프로퍼티값이 바뀌면, 이름2도 마찬가지로 같은것을 봄
                         
                                 var 이름1 = { name : '김' };
                                 var 이름2 = 이름1;
                                 이름1.name = '박';
                                 console.log(이름1);    <- { name : '박' };
                                 console.log(이름2);    <- { name : '박' };
   
                         ex) 이름1이 참조하는 위치의 {객체}의 내용이나 이름2가 참조하는 위치의 {객체}의 내용이나 같기에 둘은 같은 {객체}를 참조하는 것처럼 보이나..
                              -> 그 둘은 각각 다른 메모리 위치에 존재하는 {객체}를 참조함
                                 (= 이름1 != 이름2) 
                         
                                 var 이름1 = { name : '김' };
                                 var 이름2 = { name : '김' };
                                 console.log(이름1 == 이름2);     <- false가 출력... { name : '김' }이라는 {객체}들의 내용은 유사하나, 결국 도플갱어와 같다고 봐야 함
   
                         ex) 이름1이 저장한 {객체}의 heap영역 메모리 주소값이 obj라는 변수에 대입되지만, 결국 { name : 'park' }이라는 새롭게 생성된 객체의 heap영역 메모리 주소값을 저장함
                             (= 변경이라는 함수의 호출로 인해 이름1이라는 변수가 저장한 {객체}의 참조값은 오염되지 않음)
   
                             var 이름1 = { name : '김' };
                             
                             function 변경(obj){
                               obj = { name : 'park' };
                             }
   
                             console.log(이름1);     <- { name : '김' }; 그대로 출력
                             
                             변경(이름1);
                               -> 해당 함수는 parameter변수 obj에 arguments인 이름1이라는 {객체}의 참조값을 가진 변수가 대입된다는 로직으로 동작한다고 판단하면 이해가 빠를 것..
                                  (= 함수 호출시 parameter변수와 argument가 되입되는 과정까지 이해를 해야 함)
                               
                                  function 변경(obj = 이름1){
                                    obj = 이름1;
                                    obj = { name : 'park' };
                                  }
   
                         ex) 이름1이 저장한 {객체}의 heap영역 메모리 주소값이 obj라는 변수에 대입되고, 결국 그 참조값의 heap영역에 저장된 프로퍼티의 값을 직접 변경하니, 이름1의 프로퍼티의 값이 변함
   
                             var 이름1 = { name : '김' };
                             
                             function 변경(obj){
                               obj.name  = 'park';
                             }
   
                             console.log(이름1);     <- { name : 'park' }; 그대로 출력
                             
                             변경(이름1);
                               -> 해당 함수는 parameter변수 obj에 arguments인 이름1이라는 {객체}의 참조값을 가진 변수가 대입된다는 로직으로 동작한다고 판단하면 이해가 빠를 것..
                               
                                  function 변경(obj = 이름1){
                                    obj = 이름1;
                                    obj.name  = 'park';
                                  }
                            
                # 참조 자료형(reference type) 종류
   
                  1) {object(객체)}
                       : 연관된 변수(= 프로퍼티)나 그 변수들을 조작하는 함수(= 메서드)들을 모아놓은 타입을 구현한 key와 value의 집합체인 데이터 구조에 해당하는 JS의 자료형 (!= Json) 
                          -> (참고) 
                               a. JS에서는 함수도 '1급 객체(first-Class Citizen)'에 속하는 {객체}로서, 함수를 변수, return문, 함수의 인자로 할당 가능
                               b. {Map 객체}와 마찬가지로 {object 객체}의 key값(key명) 또한 메모리주소값으로 사용되는 hash값으로 변환되는 seed값임 
                               c. {객체} 내부 {프로퍼티}도 {객체}에 해당
                                  (= {프로퍼티} 마다 숨겨진 속성이 기본적으로 존재 == {객체} 자료형은 무거움)
   
                        - (중요) null
                            : null이라고 사용자가 선언한 경우에 할당되는 {객체} 자료형의 특수값 
                              (= null은 사용자가 null이라고 의도적으로 값이 없음을 명시)
                                  -> null값의 특징
                                      a. falsy에 해당하는 {객체} 자료형의 값
                                      b. undefined 자료형과는 느슨한 동등 연산자(==)를 통해 비교 연산시 true가 도출
                                         (= NaN은 그 자신과도 같은 값이 아니니, 당연히 느슨한 동등 연산자(==)를 통해 비교 연산시 false가 도출)
   
                                         ex) null == undefined;  // true
                                             NaN == NaN;         // false
   
                                      c. 숫자로 형변환 된다면, 0으로 변환
                                         (= null은 근본적으로 산술 연산이 가능함)
   
                        - {객체}를 기반으로 만들어진 JS의 참조 자료형
                            : 까놓고 말해서, 그냥 {객체}는 JS라는 언어 성립에 있어 가장 근간을 이루는 참조 자료형이라고 보면 됨
   
                              a. 배열(Array)
                                  : 숫자 인덱스를 사용하여 데이터의 순서화된 집합
   
                              b. 셋(Set)
                                  : 값의 집합으로, 중복된 값이 허용 X       
                                    (= 중복X인 유사 [배열])
   
                              c. 맵(Map)
                                  : 키-값 쌍의 집합으로, 키의 순서가 유지되고 중복 허용X
                                    (= key영역 중복X인 유사 마이너 {객체})
                              
                              f. 함수(Function)
                                  : 코드의 재사용을 가능하게 하기 위한 블록을 가진 모듈 
                                     -> JS에서는 함수도 {객체}이므로 자신만의 프로퍼티(자신이 선언된 {}정보 등등) 있음 + '1급 객체(first class citizen)'로서 '값'으로서 취급될 수 있음
                              
                              d. 날짜(Date)
                                  : 날짜와 시간을 나타냄
                              
                              e. 정규 표현식(RegExp)
                                  : 문자열 패턴을 나타내며, 정규식을 사용할 수 있게 됨
   
                         - {객체} 자료형 자체의 메서드
   
                             a. Object.hasOwnProperty(프로퍼티명)
                                 : 해당 '프러퍼티명'이 현재 {객체}에 존재하는지 boolean값으로 판별하는 기능
                             
                             b. Object.getOwnPropertyDescriptor({객체명}, '프로퍼티명') 
                                 : 어떤 {객체}의 {내부 프러퍼티명}의 모든(숨겨진 거 포함) 속성과 속성값을 확인하는 기능
   
   
                  2) [Array(배열)]
                       : 숫자 index를 사용하여 메모리 공간을 할당하여, 여러개의 데이터들을 순서화 된 집합으로 나타낸 자료형
   
                        - JS에서 [배열]과 연관된 특수사항  
   
                           a. [배열]도 JS에서는 {객체} 기반
                              (= '배열명[index]'로 요소에 접근하는거 자체가 '객체명[프로퍼티명]'에서 나옴)
                           
                           b. a에서 말하듯 {객체}라서 자신의 프로퍼티와 메서드가 존재
   
                           c. [배열]은 iterable함
   
                           d. 동적 약타입 언어인 JS이기에 타언어와 달리 JS의 [배열]은 특정 자료형에 종속되는 값만 가지지 않음
   
                           e. heap영역에 [배열]의 요소들이 저장되는 구조는 ArrayList와 같은 주소가 물리적으로 연속되지 않고, LinkedList처럼 메모리주소값으로 연결된 구조
                              (= 알고리즘 짜면 많이 불리해짐)
                       
                        - [배열]의 메서드
                           a. from(참조 자료형)
                               : 참조 자료형에 해당하는 {유사 배열(Array-like) 객체}나 {이터러블(iterable) 객체}를 [배열]로 변환해주는 메서드
   
                                 ex) 문자열을 배열로 만드는 예시
   
                                     Array.from("Hello");
                                      -> [ 'H', 'e', 'l', 'l', 'o' ]
   
                                 ex) 유사 배열 객체를 배열로 만드는 예시
   
                                     Array.from({ 0: "찬민", 1: "희진", 2: "태인", length: 3 });
                                      -> [ '찬민', '희진', '태인' ]
   
                                 ex) 함수의 매개변수들을 순서대로 배열로 만드는 예시
   
                                     const funcA = (...arguments) => {
                                         return Array.from(arguments)
                                     }
   
                                     funcA(1,2,3,4,5)
                                       ->  [ 1, 2, 3, 4, 5 ]
   
                           b. foreach(무명콜백함수(개별요소, 인덱스, 배열자체){ 내용부 })
                               : [배열]의 내부요소를 효율적으로 순회할 수 있을 뿐 아니라, '무명콜백함수'를 통해 [배열]의 요소들을 기반으로 내용부를 실행이 가능함
                                 (= [배열] 내부의 요소와 정보를 augument로 넣어 어떤 함수의 내용부를 순회하여 실행시키는 기능에 해당)
                                     -> (중요) [배열] 내부 요소를 활용하고 순회하여 함수 내용부를 순회한다는 컨셉은 '함수형 프로그래밍' 패러다임을 따르는 조건에 맞는 새로운 [배열]을 return 해주는 Filter, Map 메서드가 계승함
                   
                                         ex) [arrNum]의 내부요소를 활용한 forEach() 메서드의 parameter인 무명콜백함수의 1번째 parameter인 num은 각 [arrNum]의 내부요소를 의미
                                               -> 이를 통해, '내부요소 * 2'가 순환되어 실행
                                                   
                                             let arrNum = [1, 2, 3];
                                             
                                             arrNum.forEach(num => {
                                               console.log(`num: ${num * 2}`);
                                             });
                   
                                             -> num : 2 , num : 4 , num : 6가 실행
   
                           c. filter(무명콜백함수(개별요소, 인덱스, 배열자체{ return 조건식 })
                               : [배열]의 내부요소를 효율적으로 순회하여, '무명콜백함수'를 통해 [배열]의 요소들을 기반으로 반환되는 '조건식'에 해당하는 [배열]의 요소들만 취합한 뒤, 원본과 별개의 새로운 [배열]을 제작하여 반환
                                   -> (중요) filter 이용시 주의사항
                                        - 함수형 프로그래밍 패러다임을 사용 = 원본 데이터를 변형시키지 않기에 같은 데이터가 들어가면 같은 결과를 보장함
                                        - 원하는 조건식을 썼으면, 그 앞에 return을 반드시 적어줘야 filter 메서드는 작동하게됨
   
                                          ex) [7,3,5,2,40]에서 4보다 작은 애들만 추출된 [2, 3]라는 새로운 [배열]로 반환하여 '새어레이' 변수에 저장해줌
                                          
                                              var 어레이 = [7,3,5,2,40];
                                              
                                              var 새어레이 = 어레이.filter(function(a){
                                                return 조건식
                                              });  
   
                           d. map(무명콜백함수(개별요소, 인덱스, 배열자체{ return 수식 })
                               : [배열]의 내부요소를 효율적으로 순회하여, '무명콜백함수'의 반환되는 수식을 통해 [배열]의 요소들을 가공하고, 이들을 원본과 별개로 제작된 새로운 [배열]에 넣어서 반환
                                   -> (중요) map 이용시 주의사항
                                        - 함수형 프로그래밍 패러다임을 사용 = 원본 데이터를 변형시키지 않기에 같은 데이터가 들어가면 같은 결과를 보장함
                                        - 원하는 조건식을 썼으면, 그 앞에 return을 반드시 적어줘야 map 메서드는 작동하게됨
   
                                          ex) [7,3,5,2,40] -> [28, 12, 20, 8, 160] 로 가공하여 새로운 [배열]로 반환하여 '새어레이' 변수에 저장해줌
                                          
                                              var 어레이 = [7,3,5,2,40];
                                              
                                              var 새어레이 = 어레이.map(function(a){
                                                return a * 4
                                              }); 

                           f. find(무명콜백함수(개별요소, 인덱스, 배열자체{ return 수식 })
                               : [배열]의 내부요소를 효율적으로 순회하여, '무명콜백함수'의 반환되는 수식 조건을 충족시키는 '첫번째 요소'를 뽑아내어 리턴한다 (없으면 undefined)
                                   -> (중요) find 이용시 주의사항
                                        - 함수형 프로그래밍 패러다임을 사용 = 원본 데이터를 변형시키지 않기에 같은 데이터가 들어가면 같은 결과를 보장함
                                        - 원하는 조건식을 썼으면, 그 앞에 return을 반드시 적어줘야 find 메서드는 작동하게됨
   
                                          ex) [7,3,5,2,40] 중 5 이상인 1번째 요소인 7을 반환
                                          
                                              var 어레이 = [7,3,5,2,40];
                                              
                                              var 새어레이 = 어레이.find(function(a){
                                                return a > 5
                                              }); 

                           g. some(무명콜백함수(개별요소, 인덱스, 배열자체{ return 수식 })
                               : [배열]의 내부요소를 효율적으로 순회하여, '무명콜백함수'의 반환되는 수식 조건을 충족시키는 요소가 하나라도 있는지 여부를 확인하여, boolean값으로 반환한다
                                   -> (중요) some 이용시 주의사항
                                        - 함수형 프로그래밍 패러다임을 사용 = 원본 데이터를 변형시키지 않기에 같은 데이터가 들어가면 같은 결과를 보장함
                                        - 원하는 조건식을 썼으면, 그 앞에 return을 반드시 적어줘야 some 메서드는 작동하게됨
   
                                          ex) [7,3,5,2,40] 중 5 이상인 요소가 있는지 확인하여 true로 반환
                                          
                                              var 어레이 = [7,3,5,2,40];
                                              
                                              var 새어레이 = 어레이.some(function(a){
                                                return a > 5
                                              }); 

                           h. every(무명콜백함수(개별요소, 인덱스, 배열자체{ return 수식 })
                               : [배열]의 내부요소를 효율적으로 순회하여, 모든 요소가 '무명콜백함수'의 반환되는 수식 조건을 충족시키는지 여부를 확인하여, boolean값으로 반환한다
                                   -> (중요) every 이용시 주의사항
                                        - 함수형 프로그래밍 패러다임을 사용 = 원본 데이터를 변형시키지 않기에 같은 데이터가 들어가면 같은 결과를 보장함
                                        - 원하는 조건식을 썼으면, 그 앞에 return을 반드시 적어줘야 every 메서드는 작동하게됨
   
                                          ex) [7,3,5,2,40]의 모든 요소가 5 이상인 요소가 있는지를 확인했는데 2,3이 걸리니 false로 반환
                                          
                                              var 어레이 = [7,3,5,2,40];
                                              
                                              var 새어레이 = 어레이.every(function(a){
                                                return a > 5
                                              }); 

                           i. reduce, reduceRight(무명콜백함수(현재 누적값, 개별요소){ return 수식}, 초기값)
                               : [배열]의 내부요소를 효율적으로 순회하여, 초기값을 시작으로 '무명콜백함수'의 반환되는 수식을 활용하여 모든 요소값을 연산에 활용한 누적된 결과값을 반환받기 위한 함수
                                   -> (중요) reduce, reduceRight 이용시 주의사항
                                        - 함수형 프로그래밍 패러다임을 사용 = 원본 데이터를 변형시키지 않기에 같은 데이터가 들어가면 같은 결과를 보장함
                                        - 원하는 조건식을 썼으면, 그 앞에 return을 반드시 적어줘야 reduce, reduceRight 메서드는 작동하게됨
                                        - 초기값으로 설정된 값은 현재 누적값의 가장 처음 값에 해당함
                                        - (중요) reduce <-> reduceRight 의 차이
                                           : reduce는 시작요소 -> 끝요소로 누적연산, reduceRight는 끝요소 -> 시작요소로 누적연산
   
                                          ex) 0을 초기값으로 하여, [7,3,5,2,40]의 모든 요소를 더한 결과를 계산하여 57반환
                                          
                                              var 어레이 = [7,3,5,2,40];
                                              
                                              var 새어레이 = 어레이.reduce(function(prev, current){
                                                return prev + curr.score
                                              }, 0); 

                           y. sort(무명콜백함수(비교1, 비교2){ return 숫자})
                               : [배열]을 정렬해주는 메서드로, 무명콜백함수를 통해 각 [배열] 요소들을 1:1로 비교하는 로직을 거쳐, 음수(-)가 반환되면 내비두고, 양수(+)가 반환되면 비교1과 비교2의 자리를 바꾸는 방식을 반복함
                                   -> (중요) sort 이용시 주의사항
                                        - sort 메서드를 사용하여, 정렬하면 원본 [배열]의 정렬까지 변하니, 그에 대비해야 함
                                        - 비교의 기준이 되는 무명콜백함수의 정의가 없다면, 무조건 [배열]의 요소들을 '문자열'로 치환해서 정렬함 
                                        - [배열]의 내용이 숫자간 비교라면 return값에 직방으로 사칙연산을 써도 됨
   
                                          ex) [어레이]의 내부 숫자 요소들은 내림차순으로 영구적인 정렬이 됨
   
                                              var 어레이 = [7,3,5,2,40];
                                              
                                              어레이.sort(function(a, b){
                                                return b - a 
                                              }); 
   
                                          ex) {products}라는 {객체}의 정렬도 그 내부 프로퍼티가 숫자라면, 다음과 같이 return문에 직빵으로 적어도 됨
   
                                              products.sort(function(a, b){
                                                return a.price - b.price 
                                              });
                                              
                                              console.log(products); 
   
                                        - [배열]의 내용이 '문자열' 간 비교라면, return값에 직방으로 사칙연산을 쓰면 정렬 기능이 수행되지 않음
                                            -> WHY? '문자열'은 JS에서 비교연산자로 비교는 가능해도, 사칙연산에 대응되는 부호는 +뿐이 없기 때문
   
                                               ex) 문자끼리 부등호비교가 가능한 JS에서는 ㄱ보다 ㅎ 이게 더 크게 인정되어 비교연산자 <, =, > 사용가능
   
                                                   var 어레이 = ['가', '다', '나'];
   
                                                   어레이.sort(function(a, b){
                                                     if (a < b) {
                                                       return 1 
                                                     } else {
                                                       return -1
                                                     }
                                                   });
                                                   
                                                   console.log(어레이)
                                                    -> ['다', '나', '가']

                           z. reverse()
                               : [배열]을 역정렬해주는 메서드
                                   -> (중요) sort 이용시 주의사항
                                        - sort 메서드를 사용하여, 정렬하면 원본 [배열]의 정렬까지 변하니, 그에 대비해야 함
   
                                          ex) [어레이]의 내부 숫자 요소들은 현재 순서가 뒤집힌 순인 [40,2,5,3,7]으로 영구적인 정렬이 됨
   
                                              var 어레이 = [7,3,5,2,40];
                                              
                                              어레이.reverse(); 

                  3) {Set(셋)}
                       : 값이 집합된 {객체}로, 내부 요소로서 중복된 값이 허용 X  
                           -> (용도) 보통 [배열]의 중복 제거를 위해 사용됨     
   
                        - JS에서 {set 객체}과 연관된 특수사항  
   
                           a. 셋(Set)은 내부요소 '값'의 중복을 허용X 하는 {객체}에 해당
                               -> '값'으로는 자료형을 막론하고 뭐든 들어올 수 있음
   
                                   ex) var 출석부2 = new Set([ 'john' , 'tom', 'andy', 'tom' ]);
   
                                       console.log(출석부2);  
                                         -> [ 'john' , 'tom', 'andy', 'tom' ] -> {'john' , 'tom', 'andy'}로 중복제거한 {객체} 형식으로 출력
   
                           b. ES6 이후 등장한 class 기반 {객체}
                              (= 생성자(constructor)가 존재하며, 메서드(method)가 존재) 
   
                           c. iterable 함 (= 반복문 순회 가능)
   
                           d. 생성자를 통해 {set객체}를 생성할 때, parameter변수에 argument로 [배열]을 넣으면, 그 배열을 {set 객체} 형식으로 바꿔줌
   
                           e. {set객체} -> [배열]하는 것은 스프레드 연산자(spread operator) '...'를 쓰면 쉬움
   
                              ex) var 출석부 = [ 'john' , 'tom', 'andy', 'tom' ];
   
                                  var 출석부2 = new Set(출석부);   // Array를 Set으로 바꾸기
                                  출석부 = [...출석부2]            // Set을 Array로 바꾸기1
                                  출석부 = Array.from(출석부2);    // Set을 Array로 바꾸기2
                       
                        - {set 객체}의 생성자 함수와 메서드
   
                           A. {set객체} 생성자 함수 
                               : 생성자를 통해 {set객체}를 생성할 때, new Set([배열]) 형태의 parameter변수에 argument로 [배열]을 넣으면, 그 배열을 {set 객체} 형식으로 바꿔줌
                                 (= argument인 [배열]을 먼저 들어온 순서대로 적용하고, 뒤에 중복으로 들어온 요소는 다 쳐냄)
   
                                  ex) var 출석부2 = new Set([ 'john' , 'tom', 'andy', 'tom' ]);
   
                                      console.log(출석부2);  
                                        -> {'john' , 'tom', 'andy'}로 중복제거한 {객체} 형식으로 출력
   
                           B. {set객체}의 멤버
   
                               - 프로퍼티
                                  a. size
                                      : 해당 {set객체}의 요소가 몇 개인지 저장
                               
                               - 메서드
                                  a. add('요소값')
                                      : 해당 '요소값'에 해당하는 값을 해당 {set 객체}에 추가할 수 있는지 검토하고, 중복이 아니라면 내부 요소로 추가한 뒤 {set 객체} 반환
                                        (= 메서드 체이닝이 쌉가능)
   
                                        ex) set.add(1).add("A").add(true);    // {1, 'A', true}
   
                                  b. clear()
                                      : 해당 {set 객체}의 요소들을 전부 지움
                                  
                                  c. delete('요소값')
                                      : 해당 '요소값'에 해당하는 값을 해당 {set 객체}에 삭제할 수 있는지 검토하고, 삭제했는지 여부를 boolean으로 반환
   
                                        ex) set.delete(1); // true
                                            set.delete(2); // false
                                 
                                  d. has('요소값')
                                      : 해당 '요소값'에 해당하는 값이 현재 해당 {set 객체}에 존재하는지 검토
   
                                        ex) var 출석부 = [ 'john' , 'tom', 'andy', 'tom' ];
                                            var 출석부2 = new Set(출석부);   //Array를 Set으로 바꾸기
   
                                            출석부2.add('sally');     // { 'john' , 'tom', 'andy', 'sally'}
                                            출석부2.add('tom');       // { 'john' , 'andy', 'sally'}                                        
                                            출석부2.has('tom');       // false
                                            출석부2.size;             // 3
   
                                            출석부 = [...출석부2]      //Set을 Array로 바꾸기
   
                                  e. forEach(무명콜백함수(개별요소parameter, 인덱스parameter){ 내용부 });
                                      : 해당 {set 객체}의 모든 내부 요소를 무명콜백함수 내용부에 해당하는 내용으로 순회반복
                                         -> parameter 변수는 전부 필수는 아니나... 목적을 생각하면 1번째는 적어도 넣어야겠지?
   
                                            ex) 0, 4, 4를 차례대로 순회
                                            
                                                const numSet = new Set([4, 4, 2]);
                                                numSet.forEach((num, index) => console.log(num * index));
   
                  4) {Map(맵)}
                       : 순서가 유지되고 중복 허용X인 key - value 쌍의 집합 형태의 {객체}
                          -> JS의 {Map 객체}는 key값을 hash table로 구성해 사용하는 식의 Hash Map으로 구현
   
                         - {Map 객체} 개별 key값이 의미하는 것
                             : 개별 key값(= seed값) -> hash변환 알고리즘 -> hash값 = 메모리주소값 그 자체!
                               (= key값이 중복을 허용하지 않는 이유 = value값이 실제로 저장될 고유한 메모리주소값이기 떄문)
                                   -> (중요) key값을 통해 hash값인 메모리주소 그 자체를 얻을 수 있는지라 '값'에 해당하는 value에 대한 빠른 조회, 추가, 삭제 등이 가능
   
                         - JS에서 {Map 객체}과 연관된 특수사항  
     
                            a. {Map 객체}의 key는 '참조(reference)값'이고 value는 'heap영역의 참조주소값에 실제로 저장된 값'으로서 연결하여, 관계를 짓고 구분할 수 있도록, 설계된 자료형을 구현한 {객체}에 해당
                                 -> {맵(Map) 객체}를 출력하면 { key =>  value, ... , } 형식의 객체로 출력
                                      : '=>' 가 보이는 이유는 key - value의 관계가 '참조 자료형(reference type)'의 '참조값 - 저장내용'과 같은 관계에 있기 때문
   
                                         ex) var person = new Map();
                                             person.set('name', 'Kim');
                                             person.set('age', 20);
         
                                             console.log(person);  
                                               -> {"name" => "kim" , "age" => 20} 형식의 {객체}로 출력
   
                            b. key, value 둘 다 자료형을 막론하고 뭐든 들어올 수 있음
                                -> key의 경우는 메모리주소값으로 변환되는 고유성이 있기에 {set 객체}처럼 중복되지 않기만 하면 됨
                                    -> (주의!) {객체}나 함수도 key값으로 넣기가 가능하지만, get()이나 has()의 parameter값에 {객체} 자체를 넣거나, 무명함수를 key값으로 찾는다치면 참조값 문제로 false가 뜲
   
                                   ex) 모든 자료형이 key값으로 들어올 수 있지만, 참조 자료형 자체는 변수나 함수명으로 저장하지 않는 이상 여기서도 ==의 개념을 조심스럽게 접근해야함
                                   
                                       var person = new Map();
   
                                       person.set([1,2,3], 'Kim');
                                       person.set('age', 20);
                                       person.set({}, 'value associated with an object');
                                       person.set(function() {}, 'value associated with a function');
   
                                       console.log(myMap.get('age'));            // 20 출력
                                       console.log(myMap.get({}));               // undefined (key값의 {}와는 다른 객체이기 때문에)
                                       console.log(myMap.get(function() {}));    // undefined (key값의 무명함수와는 다른 함수이기 때문에)
   
                            c. ES6 이후 등장한 class 기반 {객체}
                               (= 생성자(constructor)가 존재하며, 메서드(method)가 존재) 
   
                            d. iterable 함 (= 반복문 순회 가능)
   
                            f. 생성자를 통해 {Map 객체}를 생성할 때, parameter변수에 argument로 원하는 key - value 쌍을 [key, value] 형식으로 반복해서 넣으면, 그 배열을 {Map 객체}의 내부 요소로 넣어줌
   
                               ex) var person = new Map([
                                      ['age', 20],
                                      ['name', 'Kim']
                                   ]); 
                        
                         - {Map 객체}의 생성자 함수와 메서드
   
                            A. {Map 객체} 생성자 함수 
                                : 생성자를 통해 {Map 객체}를 생성할 때, new Map() 형태나 new Map() parameter변수에 argument로 원하는 key - value 쌍을 [key, value] 형식으로 반복해서 넣으면, 그 배열을 {Map 객체}의 내부 요소로 넣어줌
   
                                  ex) 빈 {Map 객체} 생성
                                      var person = new Map();
   
                                  ex) 내용이 찬 {Map 객체} 생성
                                  
                                      var person = new Map([
                                         ['age', 20],
                                         ['name', 'Kim']
                                      ]); 
   
                            B. {Map 객체}의 멤버
   
                                - 프로퍼티
                                   a. size
                                       : 해당 {Map 객체}의 요소가 몇 개인지 저장
                                
                                - 메서드
                                   a. set('key값', 'value값')
                                       : 'key값'의 hash값인 메모리주소에 'value값'을 저장하고, 해당 {Map 객체}의 key-value 형식으로 저장
   
                                         ex) var person = new Map();
                                             person.set('age', 20);
   
                                             console.log(person);  
                                               -> {"age" => 20} 형식의 {객체}로 출력
   
                                   b. get('key값')
                                       : 해당 {Map 객체}에서 'key값'에 해당하는 위치에 저장된 'value값'을 꺼내서 반환
   
                                         ex) var person = new Map();
                                             person.set('age', 20);
   
                                             console.log(person.get('age'));  
                                               -> 20 반환     
   
                                   c. delete('key값')
                                       : 해당 'key값'에 해당하는 값을 해당 {Map 객체}에 삭제할 수 있는지 검토하고, 삭제했는지 여부를 boolean으로 반환
   
                                         ex) map.delete(1); // true
                                             map.delete(2); // false
                                  
                                   d. has('key값')
                                       : 해당 'key값'에 해당하는 값이 현재 해당 {Map 객체}에 존재하는지 검토
   
                                         ex) var person = new Map();
                                             person.set('age', 20);
   
                                             console.log(person.has('age'));  
                                               -> true 반환     
   
                                   e. clear()
                                      : 해당 {Map 객체}의 내부 요소들을 전부 지움
   
                         - {Map 객체} vs {object 객체}
                             : {object 객체}에서 'key값'을 입력 할 떄 제약이 많음 = {Map 객체}를 쓰는게 더 부담이 없음
                                -> {객체}의 크기가 {object 객체}의 경우 개별 프로퍼티들도 속성을 가지는 {프로퍼티}이고 많은 값들은 숨겨져 있기에 크고 무거움
                                   (= 자유도와 유연성, 단순함 측면에서 {Map 객체}가 더 유리함)
                                       -> Object.getOwnPropertyDescriptor({객체명}, '프로퍼티명')을 통해 enumerable, writable 등등이 숨겨진걸 확인
                                
                                   a. {object 객체}는 개발자가 'key값'을 입력 시, 기본 내장 프로퍼티명과 같으면 충돌 가능성이 존재함
                                        <-> {Map 객체}는 이런 내장 프로퍼티가 없기에 key값 쓰는데 부담이 없음
                                    
                                            ex) hasOwnProperty, toString 같은 기본적으로 이미 존재하는 key값은 {object 객체}의 key값으로 쓸 수 없음
                                   
                                   b. {object 객체}는 개발자가 'key값'을 입력 시, '문자열' 또는 심볼(Symbol)이외 다른 자료형은 전부 '문자열'로 변환
                                        <-> {Map 객체}는 그냥 JS의 모든 자료형을 'key값'으로 입력 가능
   
                # (중요) 해시(Hash)
                   : 임의 크기의 입력 데이터를 seed값으로 하여 어떤 고정된 크기의 출력 데이터(= 해시값(Hash Value))로 변경하는 과정(= 이 과정을 해시함수(Hash function)가 함)에 대한 개념
                     (= 해시함수(seed){ return 해시값 }과 같은 느낌)
                     
                     - 해시와 관련된 개념들
                        a. 해시함수(Hash function)
                            : seed값을 고정된 크기를 가지는 해시값(hash value)으로 변환해 주는 역할을 하는 함수
                               -> parmeter값에 들어가는 argument에 해당하는 원본인 seed값은 어떤 형태의 자료형도 상관없음
   
                        b. 해시값(Hash value)
                           : 해시함수(seed값)이 호출된 고정된 크기를 가지는 return값으로 보통 숫자나 '문자열'로 변환
                              -> 해시값은 주로 [배열] 형태의 해시 테이블(hash table)의 인덱스(index)로서 사용
                                 (= 해시테이블[해시값] = value값에 해당)
   
                        d. 충돌(colution) = 해시값 중복
                            : 같은 해시값(hash value)을 가지는 서로 다른 키가 존재하는 경우를 지칭
                               -> 이렇게 되면, index의 의미가 조금씩 사라지기에 이를 해결할 필요가 존재
                                   -> (방안1) 체이닝
                                        : 같은 해쉬값(index)를 가지는 여러 개의 데이터를 연결 리스트(linked list)로 연결
   
                                          ex) hashTable[fruit의 해쉬값] = [["fruit", "apple"], ["fruit", "apricot"]];
                                               -> 문제가 되는 "fruit"를 ket값으로 가지는 key-value 쌍들을 연결 리스트(linked list)로 연결해서 따로 관리
   
                                   -> (방안2) 오픈 어드레싱
                                        : 충돌이 발생하면, 문제되는 데이터를 다른 빈 인덱스를 찾아서 저장
   
                        d. 해시 테이블(Hash table)
                           : 'key값'을 seed로 해시함수 돌린 해시값(hash value)를 index 삼아 그 안에 key-value 쌍을 내부요소로 저장하는 [배열] 형식의 자료구조 
                              -> 쉽게 말해, key값 -> hash값 -> index로 변환하여 key-value 쌍에 해당하는 데이터들의 순서를 정렬하여 배치한 [배열]로 보면 됨
   
                     - 해시 테이블(hash table)의 성능
                        : 해쉬값의 중복D이 많을 수록 O(1) ~ O(n)으로 수렴
   
                           a. 해쉬값의 중복X(= 충돌X)의 경우 
                               : key값이 중복되지 않아 index를 곧장 찾으면 됨 = 데이터 검색, 삽입, 삭제 작업의 평균적 시간 복잡도 = O(1)
                                 (= 데이터의 크기에 상관없이 거의 일정한 시간만 소요)
                                     -> (중요!) {Map 객체}와 {object 객체}의 key값이 중복을 허용하지 않는 이유
   
                           b. 모든 해쉬값의 중복되는 경우 
                               : 모든 key값이 같아 index를 찾아봐야 의미X, 데이터의 크기만큼 순회해야 함 = 데이터 검색, 삽입, 삭제 작업의 평균적 시간 복잡도 = O(N)
                                 (= 데이터의 크기와 검색 속도가 비례함 = 사실상 list 자료구조처럼 작동함)
                                     -> {Map 객체}와 {object 객체}의 key값이 중복을 허용하지 않는 이유
   
                     - 해시 테이블(casg table) 사용 예시
                     
                       a. 데이터베이스: 
                         : 키-값 쌍으로 이루어진 데이터를 빠르게 검색하고 저장하기 위해 해시 테이블이 사용
                       
                       b. 캐싱
                           : 자주 조회되는 데이터를 캐싱하기 위해 사용
                             (= 해시 테이블을 사용하면, 키를 통해 매우 빠르게 데이터를 검색 가능)
                       
                       c. {Set 객체], {Map 객체}, {object 객체} 구현
                            : 값의 중복을 허용하지 않는 집합(Set)을 구현하는 데 사용
                               -> 해시 테이블을 사용하면, 요소의 존재 여부를 매우 빠르게 확인 가능
   
                # 얕은 복사(shallow copy) VS 깊은 복사(shallow copy)
   
                   - 얕은 복사(shallow copy)
                      : 참조 자료형(reference type)에 해당하는 값을 저장하는 변수의 참조값만 복사하는 것을 '얕은 복사(shallow copy)'라고 함
   
                        ex) 이름1이 저장한 heap영역 참조값 = 이름2이 저장한 heap영역 참조값 = {name : '김'}이 존재하는 heap영역 주소
                            (= 이름1이나 이름2나 특정 heap영역의 메모리주소에 어떤 값이 있는지는 모르겠고 {객체}가 있다고만 앵무새처럼 말하는 중)
                        
                            var 이름1 = { name : '김' };
                            var 이름2 = 이름1;
                            console.log(이름1 == 이름2);     <- ture
   
                   - 깊은 복사(shallow copy)
                      : 참조 자료형(reference type)에 해당하는 값을 저장하는 변수의 참조값이 가르키는 참조 자료형(reference type)의 내용을 다른 heap영역에 똑같은 내용으로 복사하는 것을 '깊은 복사(shallow copy)'라고 함
   
                        ex) 이름2는 이름1과 1도 관계없는 heap영역에 {객체}를 생성하고 그 메모리주소를 참조값으로 저장하며, 단지 프로퍼티인 name의 값만 이름1의 주소값을 참조해서 프로퍼티를 뒤져서 가져옴
                            (= 이름2는 이름1에서 프로퍼티 값만 뽑아온거 뿐, 1도 참조값과 관계가 없음)
                        
                            var 이름1 = { name : '김' };
                            var 이름2 = { name : 이름1.name };
                            console.log(이름1 == 이름2);     <- false
   
                # (ES6 이후) 스프레드(펼침) 연산자 '...' (spread operator)
                    : '원시형'에 해당하는 값만 가지는 참조 자료형에 해당하는 변수에 '...변수명' 붙여서 해당 참조 자료형에 해당하는 다른 {}나 [] 내부에 사용하면, '깊은 복사(deep copy)'하게 됨
                        -> (쉽게 말해) '원시형'값만 가지는 참조 자료형으로 저장된 변수를 {}나 []를 떼서 다른 해당 참조 자료형의 변수 요소로 붙일 때 사용한다고 생각하면 됨
   
                            A. 스프레드 연산자(spread operator) '...' 사용법 및 예시
   
                               a. 기본 사용법 ('병합')
                                   : '원시형'에 해당하는 값만 가지는 [배열], {객체}가 참조하는 내부의 모든 요소값들을 어떤 [배열], {객체}의 일부로 '병합'하는 경우    
                                       -> 병합 과정에서 []와 {}를 까서 넣는다고 생각하면 편함                           
   
                                          ex) '원시형'에 해당하는 값만 가지는 [배열]을 '...' 연산자를 써서 다른 [배열]의 일부로서 '깊은 복사(deep copy)'하는 경우
                                          
                                              var a = [1,2,3];
                                              var b = [4,5];
                                              var c = [...a, ...b]  
                                              a = [a, c]             <-  c라는 변수가 참조하는 [배열]과 무관
                                              console.log(c);        <-  a, b랑 무관하게 [1, 2, 3, 4, 5]가 출력
   
                                          ex) '원시형'에 해당하는 값만 가지는 {객체}를 '...' 연산자를 써서 다른 {객체}의 일부로서 '깊은 복사(deep copy)'하는 경우
                                          
                                              var o1 = { a : 1, b : 2 };
                                              var o2 = { c : 3, ...o1 };
                                              console.log(o2);            <-  { c : 3, a : 1, b : 2 }를 출력
   
                               b. [배열]의 내부값을 함수 호출시 () 내부에 parameter들로 대입할 떄 사용
                                   : '원시형'에 해당하는 값만 가지는 [배열]이 참조하는 내부의 모든 요소값들을 []를 떼고 보고 싶을 경우 사용
   
                                     ex) '원시형'에 해당하는 값만 가지는 [배열]을 '...배열명'을 써서 참조하여 값을 보는 경우
                                           -> 정확히는 함수 선언시 rest parameter 처리가 되어 있기에, 다음과 같은 사용이 가능
   
                                              var 어레이 = ['hello', 'world'];
                                              console.log(어레이);     <- ['hello', 'world']라는 [배열] 그 자체를 보여줌
                                              console.log(...어레이);  <- hello world 라는 내부 요소들을 그 자체로 보여주게 됨
   
                                     ex) (주의) {객체}을 '...객체명'을 써서 참조하여 값을 보면 에러 뜸
   
                                         var 오브젝트 = { a : 1, b : 2 };
                                         console.log(오브젝트);     <- { a : 1, b : 2 }라는 {객체} 그 자체를 보여줌
                                         console.log(...오브젝트);  <- error 발생!
   
                            B. (주의) 스프레드 연산자(spread operator) '...' 사용시 주의사항
   
                               1) '원시형'에 해당하는 값만 가지는 {객체}를 '...'로 '깊은 복사(deep copy)'시 프로퍼티에 중복이 일어난다면?
                                    -> '병합'되던 '대입'되던 프로퍼티의 값은 나중에 들어온 값으로 대입됨
   
                                        ex) '...'를 사용해 복사한 {객체} 프로퍼티가 중첩되는건 걱정하지 않아도 순리대로 돌아감
   
                                            var o1 = { a : 1, b : 2};
                                            var o2 = { a : 3, ...o1 };
                                            console.log(o2);             <-  { a : 1, b : 2 }를 출력 (= 기존 a : 3 -> 1로 변경)
                            
                               2) 스프레드 연산자(spread operator) '...' 는 함수 호출시 (), {객체}의 {}, [배열]의 []안에서만 사용해라
                                   -> 함수 호출시 내부()에서 사용하는 경우는 함수 선언시 'rest parameter'처리가 되어있기 때문
   
   
                               3) (중요!) 함수 호출시 ()에 스프레드 연산자(spread operator) '...'를 사용하여 parameter들로 [배열] 요소들을 대입할 수 있는 이유
                                    : 함수 선언시 ()안의 parameter들 선언 또한 'rest parameter'들을 받을 수 있게 설계했기 때문에 가능함
   
                               3) '문자열'은 원칙적으로는 ['문', '자', '열']과 같은 형식의 [배열]이라는 점을 고려해야함
                                   (= '...문자열'과 같이 스프레드 연산자(spread operator)를 '문자열'에 사용하면, 각 '문', '자'들은 분리됨)
   
                                   ex) (참고) '문자열'도 일종의 [배열]이기에 Spread 연산자를 쓴다면, 개별 '문', '자'로 해체 
   
                                       var a = [1,2,3];
                                       var b = '김밥';
                                       var c = [...b, ...a];
                                       
                                       console.log(c);   //  -> ['김', '밥', 1, 2, 3]
   
                                   ex) ['you', 'are']와 같이 '문자열'이 [배열] 내부의 요소로 들어가 있다면, [[이중배열],[이중배열]]과 같은 형태로 들어간 것
                                         -> ['you', 'are']에 스프레드 연산자(spread operator)를 쓸 때는 [배열] 형태로 되어 있는 1개의 내부 요소에 지나지 않기에 해체되지 않음
   
                                            var a = [1,2,3];
                                            var b = ['you', 'are'];
                                            
                                            var c = function(a,b){
                                              console.log([...b]);
                                              console.log( [[...a], ...[...b]][1] )
                                            }
                                            
                                            c(a,b);   //  -> [[1,2,3], 'you', 'are'][1]을 의미하니, 'you'가 출력
   
                               4) (중요!) 내부 요소값으로 1차적인 '원시값'이 아닌 중첩된 다른 참조 자료형을 가지는 요소는 그 참조값의 heap영역 주소를 참조한 '얕은 복사(shallow copy)'하게 됨
                                  (= '얕은 복사(shallow copy)'이기 때문에 내부에 중첩된 객체나 배열까지 깊이 복사되진 않음)
                                       -> 중첩된 참조 자료형들을 가지는 [배열], {객체}를 완벽하게 '...'를 사용하여 '깊은 복사(deep copy)'하고 싶다? 
                                           -> 'lodash'라는 아주 좋은 라이브러리가 존재!
   
                                               ex) 중첩된 {객체}를 내부 요소값으로 가지는 [배열]에 '...' 연산자를 사용하는 경우, 중첩된 {객체}에 해당하는 값들은 '얕은 복사(shallow copy)'하게 됨
                                                    -> 원본 [객체]인 originalArray 내부의 중첩된 {객체}의 값이 변하면, 그걸 '...'로 '얕은 복사(shallow copy)'한 copiedArray의 내부 요소 {객체}값도 똑같이 변경됨
               
                                                   let originalArray = [{ a: 1 }, { b: 2 }];
                                                   let copiedArray = [...originalArray];
                                                   
                                                   copiedArray[0].a = 99;           <- 여기서 원본 [배열] 중첩된 내부요소의 {객체}로 들어간 프로퍼티 값이 변경되면?
                                                   
                                                   console.log(originalArray[0].a); // 99
                                                   console.log(copiedArray[0].a);   // 99    <- 복사된 [배열]도 똑같이 적용
                                                   
                                               ex) 중첩된 [배열]이 들어가도 똑같음
                                                   
                                                   let originalArray = [1, [2, 3], 4];
                                                   let copiedArray = [...originalArray];
                                                   
                                                   copiedArray[1][0] = 99;           <- 여기서 원본 [배열] 중첩된 내부요소의 [배열]로 들어간 프로퍼티 값이 변경되면?
                                                   
                                                   console.log(originalArray[1][0]); // 99
                                                   console.log(copiedArray[1][0]);   // 99   <- 복사된 [배열]도 똑같이 적용
   
                                               ex) lodash 라이브러리를 사용하면 완전히 중첩된 요소들도 '깊은 복사(deep copy)'가 됨
                                               
                                                   const _ = require('lodash');
   
                                                   let originalArray = [{ a: 1 }, { b: 2 }];
                                                   let copiedArray = _.cloneDeep(originalArray);
                                                   
                                                   copiedArray[0].a = 99;           <- 원본의 중첩 {객체}의 내용이 변해도
                                                   
                                                   console.log(originalArray[0].a); // 1     <- 1도 관계없이 각자 갈 길을 갑니다
                                                   console.log(copiedArray[0].a);   // 99
   
                # (중요) this
                    : 기본적으로 this의 의미는 OOP에서 현재 {} 영역의 주제가 되는 {객체}를 의미
                      (= 함수, 이벤트리스너 등 다른 개념에서의 this 또한 해당 함수가 속한 {}영역의 주인이 되는 {객체}를 참조한다고 보면 쉬움)
   
                     A. 전역스코프{}의 this라는 값 그 자체
                         : 전역 스코프 영역 {}의 주체인 {window 객체}를 참조
                             -> BUT! 엄격 모드(strict mode)에서는 undefined
   
                                ex) 'use strict' 상태의 this가 undefined로 출력되는 예시
                                
                                    <script>
                                      'use strict';
                                    
                                      function 간지나는함수(){
                                        console.log(this)
                                      }
                                      
                                      간지나는함수();
                                      
                                    </script>
   
                     B. {객체}에서의 this들
                         : 해당 {객체} 스코프 {} 영역의 주인이 되는 {객체}를 참조한다고 보면 쉬움
                             -> (중요) {객체} 내부의 프로퍼티나 메서드를 정의할 시, this가 생략되었다 봐도 무방
   
                                 a. (주의) 사용자가 수동으로 작성한 {리터럴 객체} 내부의 내부의 this
                                     : arrow function(화살 함수)의 this와 마찬가지로 자신의 직속 상위 {}에 해당하는 {객체}가 의미하는 this를 정적으로 참조하여 절대 변경X
                                        -> WHY? {리터럴 객체} 자체는 스코프(scope) {} 영역이 존재하지 않기 떄문
                                           (= {리터럴 객체}의 스코프(scope)는 코드상으로는 있는거처럼 보이나, 실제로는 없는 상상 속의 개념 같은 것을 의미)
                     
                                           ex) 사람.sayHi()를 호출하면, sayHi 메서드는 arrow function(화살 함수)를 쓰는지라 상위스코프를 참고하고, {사람}도 {리터럴 객체}라 {}가 없는 관계로 직속 상위 {}에 해당하는 {객체}가 의미하는 this를 찾음
                                                -> 그래서 this = {window 전역객체}를 의미하며, this.name = undefined 가 됨
   
                                               var 사람 = {
                                                   name: '손흥민',
                                                   sayHi : () => {
                                                         console.log(`안녕 나는 ${this.name}`);
                                                   }
                                               }
   
                                           ex) 굳이 arrow function(화살 함수)를 써서, this = {사람}이 되게 하려면, 결국 함수 스코프{}를 써야 함
   
                                               var 사람 = {
                                                   name: '손흥민',
                                               
                                                   sayHi : function (){
                                                       
                                                       return (() => {
                                                           console.log(`안녕 나는 ${this.name}`);
                                                       })();
                                                   }
                                               }
         
                                 b. new 키워드를 사용한 어떤 class {객체}의 생성자(constructor)로서의 함수의 this
                                     : 생성자(constructor) 함수가 생성한 {instance 객체}를 참조
                    
                                       ex) new Person('Bob')의 this = 오브젝트 변수에 할당된 자신이 생성한 {객체 그 자신}
                                       
                                           function Person(name) {
                                               this.name = name;
                                           }
                                           
                                           const 오브젝트  = new Person('Bob');
                                           console.log(오브젝트.name);
                                             -> 'Bob'
   
                     C. 함수(function)에서의 this들
                         : (매우 중요) 함수에서의 this 또한 해당 함수가 속한 {}영역의 주인이 되는 {객체}를 참조한다고 보면 쉬움
                             -> 이 개념을 얼마나 정확하게 이해했냐에 따라... 하단의 function 무명함수 case에 대한 이해도가 달라짐
              
                           a. (중요) 어떤 {객체}의 메서드로서의 함수의 this
                               : 해당 메서드를 소유/호출한 {객체}를 참조
                                 (= 이 녀석의 function에서의 this의 중심이 된다고 봐도 무방)                               
   
                                 ex) 오브젝트2.data.간지함수()의 호출 결과는 {data 객체}라는 {오브젝트2 객체} 내부의 중첩 {객체}
                                       -> {오브젝트2 객체} 내부의 data라는 프로퍼티는 this.data라고 써도 같은 이야기가 됨 
               
                                     var 오브젝트2 = {
                                       data : {
                                         간지함수 : function(){ console.log(this) }
                                       }
                                     }
                                     
                                     오브젝트2.data.간지함수();
   
                           b. 독립된 전역 함수의 this
                               : JS에서 전역이라는 자체가 {window 객체} & {global} 객체를 참조함
                                 (= 전역 함수라는거 자체가 {window 객체} & {global} 객체에 속한 메서드라고 봐도 무방함)
                                     -> BUT! 엄격 모드(strict mode)에서는 undefined
              
                                 ex) 전역함수의 this는 전역 객체(window)를 참조
                                 
                                     function sayHello() {
                                         console.log(this);
                                     }
                                     
                                     sayHello(); 
                                      -> window 객체가 출력됨
   
                           c. function 무명함수 내부의 this
                               : 무명함수가 선언된 위치에 따라 case by case로 달라짐
                                 (= 호출 방식에 따라 this가 동적으로 결정될 수 있음)
   
                                 1) (중요) 콜백함수(callback function)로 사용되는 무명함수 내부의 this
                                     : 콜백함수로 사용되는 무명함수 내부의 this는 {window 객체}를 의미
                                       (= 콜백함수로 사용되는 무명함수 그 자체는 그냥 {window 객체}에 속해있는 전역함수와 다른게 없음)
   
                                      - (참고) 콜백함수로 사용되는 함수 내부의 this의 의미
                                         : 어떤 함수의 호출과정의 parameter로 사용되는 함수도 따지고 보면 원칙적으로는 미리 선언이 되어야 정상이며, 그런 함수도 선언된 위치 {}영역의 주체를 출력함
                                           (= 변수가 받아줘서 함수 표현식(function expression) 형태가 되는 무명함수라면 그 변수가 소속된 {}영역을 this의 기준으로 삼음)
   
                                            ex) 이벤트리스너의 콜백함수에서 this가 쓰였으나, 그 내부 어레이.forEach()의 콜백함수도 무명함수로 제법 구조가 복잡하나.. 
                                                 -> 본질은 어차피 {window 객체}외에는 콜백함수로 들어간 무명함수들을 포함하는 {객체}는 존재하지 않음 
   
                                                    document.getElementById('버튼').addEventListener('click', function(e){
   
                                                      var 어레이 = [1,2,3];
   
                                                      어레이.forEach(function(){
                                                        console.log(this)
                                                      });
                                                    });
   
                                            ex) 함수라는 함수표현식 형식의 {오브젝트 객체}의 메서드의 실행부에는 {오브젝트 객체}의 프로퍼티인 [배열]의 메서드인 forEach()의 콜백함수도 무명함수로 제법 구조가 복잡하나.. 
                                                 -> 본질은 어차피 {window 객체}외에는 콜백함수로 들어간 무명함수들을 포함하는 {객체}는 존재하지 않음 
                                                    (= {오브젝트 객체}의 함수표현식 형식의 메서드를 정의하여 작성 중이나, 콜백함수로 호출되는 함수는 그거랑 1도 관계없다는 것)
   
                                                    var 오브젝트 = {
   
                                                      이름들 : ['김', '이', '박'];
   
                                                      함수 : function(){
                                                          오브젝트.이름들.forEach(function(){
                                                            console.log(this)
                                                          });
                                                      }
                                                    }
   
                                            ex) 이처럼 이벤트리스너 콜백함수 내용부의 다른 콜백함수나 무명함수의 this는 다르기 떄문에, 변수에 this를 정적으로 할당하여 이를 통해 원하는 this를 주기도 함 
   
                                                document.getElementById('버튼').addEventListener('click', function(){
                                                  var 버튼 = this;
                                                  setTimeout(function(){ console.log(버튼.innerHTML) }, 1000); 
                                                });
   
                                 2) 함수 표현식 형식으로 작성된 function 무명함수 내부의 this
                                     : function 무명함수를 대입해서 받아준 변수가 소속된 {}의 소속을 따름
                                        -> 전역 스코프{} 안의 변수가 받는 경우 : {window 객체}
                                        -> 메서드 내부의 지역변수가 받는 경우  : {메서드 소속 객체}
   
                                           ex) 이와 같이 그냥 전역변수가 function 무명함수를 함수표현식으로 그냥 받으면 this = {window 객체}
   
                                               let 함수 = function(){
                                                            console.log(this)
                                                          });
   
                                           ex) sayHi() 메서드 내용부에 함수표현식으로 functionExpression() 함수가 존재하는데, 거기의 this = {사람}
                                                -> function 무명함수를 받은 함수표현식이 함수표현식 형식의 메서드 sayHi() 내부에 있는데, 그 sayHi()를 호출한게 {사람}
   
                                                   var 사람 = {
                                                       name: '손흥민',
                                                   
                                                       sayHi : function (){
                                                           let functionExpression = function () {
                                                               console.log(`안녕 나는 ${this.name}`);
                                                           }
       
                                                           return functionExpression();
                                                       }
                                                   }
   
                                 3) 어떤 {객체}의 메서드가 함수 표현식 형식으로 작성된 function 무명함수 내부의 this
                                     : {메서드 소속 객체}를 의미
                                        -> (주의) arrow function(화살 함수)로 작성된 메서드는 이야기가 전혀 다름
   
                                           ex) 사람.sayHi()를 호출하면, sayHi 메서드는 arrow function(화살 함수)를 쓰는지라 상위스코프를 참고하고, {사람}도 {리터럴 객체}라 {}가 없는 관계로 직속 상위 {}에 해당하는 {객체}가 의미하는 this를 찾음
                                                -> 그래서 this = {window 전역객체}를 의미하며, this.name = undefined 가 됨
   
                                               var 사람 = {
                                                   name: '손흥민',
                                                   sayHi : () => {
                                                         console.log(`안녕 나는 ${this.name}`);
                                                   }
                                               }
   
   
                                           ex) 굳이 arrow function(화살 함수)를 써서, this = {사람}이 되게 하려면, 결국 함수 스코프{}를 써야 함
   
                                               var 사람 = {
                                                   name: '손흥민',
                                               
                                                   sayHi : function (){
                                                         
                                                       return (() => {
                                                           console.log(`안녕 나는 ${this.name}`);
                                                       })();
                                                   }
                                               }
   
                                 4) 어떤 함수의 내부 함수가 함수 표현식 형식으로 작성된 function 무명함수 내부의 this
                                     : 상위 함수가 {객체}에 소속된 메서드인지, 전역 스코프{}에 작성된 함수인지에 따라 다름
                                        -> {객체}에 소속된 메서드  : {메서드 소속 객체}
                                        -> 전역 스코프{} 작성 함수 : {window 객체}
   
                                           ex) (중요) 상위함수()를 호출하면, 상위함수()가 소속된 {window 객체}가 나옴
   
                                               function 상위함수(){
                                                 
                                                 var 하위함수() = function (){
                                                   console.log(this);
                                                 }
                                                 
                                                 return 하위함수();
                                               }
   
   
                           d. arrow function(화살 함수)의 this
                               : arrow function(화살 함수) 자신이 선언된 위치의 직속 상위 {}에 해당하는 {객체}가 의미하는 this를 정적으로 참조하여 절대 변경X
                                 (= arrow function(화살 함수) 자신이 정의된 스코프 {} 영역에서 사용 중인 this를 상속)
                                    -> (중요!) arrow function(화살 함수)가 호출시 문맥상 주체가 누구인지 신경 안 쓴다는 걸 의미
   
                                       ex) sayHi를 호출한 주체는 {학생1}이지만, 작성이 arrow function(화살 함수)로 되어 있기에 호출자는 1도 신경쓰지 않고, 자신의 위치의 직속 스코프{} 영역에서 this의 의미를 그대로 사용
                                            -> Student.prototype.sayHi는 가장 상위 스코프인 {전역 객체} 영역에 생성되었기에 this = {window 객체}를 의미함 
   
                                               function Student(이름, 나이){
                                                   this.name = 이름;
                                                   this.age = 나이;
                                               }
                                               
                                               Student.prototype.sayHi = () => {
                                                   console.log('안녕 나는 ' + this.name + '이야');
                                               }
                                               
                                               var 학생1 = new Student('Kim', 20);
                                               학생1.sayHi();
   
                                - this = 렉시컬 바인딩(lexcial binding)의 결과물
                                   : arrow function(화살 함수)은 자신이 선언된 위치 {}에서 사용 중인 this를 절대 바꿀 수 없는 정적인 값으로 상속받음
                                      -> (중요) 그래서 call, apply, bind 함수로 arrow function(화살 함수)의 this의 값을 변경시킬 수 없음 
                                                (= 일반 함수는 그게 가능!)
   
                                          1) arrow function(화살 함수)가 전역 스코프{}의 함수표현식으로 선언되었시의 this
                                              : this = {window 객체}
   
                                          2) arrow function(화살 함수)가 일반 함수 내부의 함수표현식으로 선언되었시의 this
                                              : this = {해당 함수 소속 객체}
   
                                          3) arrow function(화살 함수)가 객체 스코프{}의 메서드로 선언되었시의 this
                                              : this = {해당 메서드 소속 객체}
   
                                                ex) {obj 객체}의 함수 표현식 메서드 regularFunc의 내부 함수표현식 arrowFunc의 this는 절대적으로 상위 {}의 regularFunc가 가르키는 해당 {}의 주인인 {obj 객체}를 의미
                                                      -> 화살표 함수 내부의 this는 regularFunc의 this를 의미
                   
                                                         const obj = {
                                                           name: 'Alice',
                                                           regularFunc: function() {
                       
                                                             console.log('Regular Function:', this.name);    <- "Alice"
              
                                                             const arrowFunc = () => {
                                                               console.log('Arrow Function:', this.name);    <- "Alice"
                                                             };
                                                         
                                                             arrowFunc();
                                                           }
                                                         };
                                                         
                                                         obj.regularFunc();
                  
                                                ex) {obj 객체}의 getValue 함수 표현식 메서드의 return값이 arrow function(화살 함수)며, this는 절대적으로 상위 {}의 getValue가 가르키는 해당 {}의 주인인 {obj 객체}를 의미
                  
                                                    const obj = {
                                                      value: 42,
                                                      getValue: function() {
                                                        return () => this.value;
                                                      }
                                                    };
                                                    
                                                    const arrowFunc = obj.getValue();
                                                    console.log(obj.getValue());
                                                      -> 42
                                                      
                                          4) arrow function(화살 함수)가 어떤 함수의 콜백함수로 사용되었을 시 그 내부의 this
                                              : this = {window 객체}
   
                                                ex) 함수라는 함수표현식 형식의 {오브젝트 객체}의 메서드의 실행부에는 {오브젝트 객체}의 프로퍼티인 [배열]의 메서드인 forEach()의 콜백함수는 arrow function(화살 함수)
                                                      -> 본질은 어차피 {window 객체}외에는 콜백함수로 들어간 무명함수들을 포함하는 {객체}는 존재하지 않음 
                                                         (= {오브젝트 객체}의 함수표현식 형식의 메서드를 정의하여 작성 중이나, 콜백함수로 호출되는 함수는 그거랑 1도 관계없다는 것)
                  
                                                          var 오브젝트 = {
                        
                                                            이름들 : ['김', '이', '박'];
                        
                                                            함수 : function(){
                                                                오브젝트.이름들.forEach(() => {
                                                                  console.log(this)
                                                                });
                                                            }
                                                          }
   
                                          5) (주의) arrow function(화살 함수)가 어떤 DOM API의 이벤트리스너의 콜백함수로 사용되었을 시 그 내부의 this
                                              : this = {이벤트 객체}.target
   
                                                ex) 이벤트리스너의 무명콜백함수를 arrow function(화살 함수)으로 작성하고 그 내용부에서 this를 쓰면 이는 {이벤트 객체}.target으로 인식
            
                                                        document.getElementById('버튼').addEventListener('click', function(e){
                        
                                                           if(this == e.currentTarget){
                                                              console.log(this)
                                                           }
                                                        });
   
                     D. 이벤트리스너 메서드에서의 콜백함수 내부의 this
                         : 현재 이벤트가 발생하는 대상인 {DOM 객체} 내부의 요소인 <HTML>를 의미하는 e.currentTarget
                            -> e.currentTarget은 이벤트리스너 함수의 콜백함수 1번째 parameter변수에 할당된 {arguments 객체}에 해당하는 {이벤트 객체}의 프로퍼티 중 하나
                                -> (참고) {이벤트 객체}
                                     : DOM API의 메서드인 이벤트리스너 실행시 그에 필요한 모든 정보들이나 조작함수를 멤버들로 가지고 있는 {객체} 
   
                                       ex) '버튼'이란 id를 가진 <HTML> 태그를 클릭하면, 그 이벤트의 내용을 실행하는 무명콜백함수의 this는 '버튼'이란 id를 가진 <HTML> 태그를 의미
   
                                           document.getElementById('버튼').addEventListener('click', function(e){
                                             console.log(this)
                                           });
   
                                       ex) 이벤트리스너의 콜백함수도 무명함수고, 그 내부 어레이.forEach()의 콜백함수도 무명함수로 제법 구조가 복잡하나.. 
                                            -> 본질은 어차피 {window 객체}외에는 콜백함수로 들어간 무명함수들을 포함하는 {객체}는 존재하지 않음 
   
                                               document.getElementById('버튼').addEventListener('click', function(e){
               
                                                 var 어레이 = [1,2,3];
               
                                                 어레이.forEach(function(){
                                                   console.log(this)
                                                 });
                                               });
   
                     F. apply, call, bind 메서드
                         : parameter위치에 argument로 원하는 {객체}를 this로 설정 가능
                    
                           ex) introduce라는 함수의 this를 obj라는 변수에 할당된 {객체}로 임의설정
                    
                               function introduce() {
                                   console.log(this.name);
                               }
                               
                               const obj = { name: 'Charlie' };
                               introduce.call(obj); 
                                 -> Charlie
  
          [3] (참고) JS의 특수한 값 및 자료형(null, undefined, NaN) 정리

             # undefined 자료형과 null값, NaN값 정의
 
                1) undefined
                    : 값이 그냥 비었을경우에 할당되는 자료형 그 자체
                      (= undefined는 사용자는 개입한거 없이, 의도하지 않았는데 값이 없을 때 등장하며, 그 자체가 undefined 자료형에 해당)
           
                     # undefined 자료형의 특징
                        a. falsy에 해당하는 자료형
                        b. null과는 느슨한 동등 연산자(==)를 통해 비교 연산시 true가 도출
                           (= NaN은 그 자신과도 같은 값이 아니니, 당연히 느슨한 동등 연산자(==)를 통해 비교 연산시 false가 도출)
               
                           ex) null == undefined;  // true
                               NaN == NaN;         // false
               
                        c. 숫자로 형변환 된다면, NaN으로 변환되어 사용되거나 연산됨
                        
                           ex) undefined + 5;    ->  NaN
                           ex) Number(undefined) ->  NaN
           
                2) null
                    : null이라고 사용자가 선언한 경우에 할당되는 {객체} 자료형의 특수값 
                      (= null은 사용자가 null이라고 의도적으로 값이 없음을 명시)
           
                     # null값의 특징
                        a. falsy에 해당하는 {객체} 자료형의 값
                        b. undefined 자료형과는 느슨한 동등 연산자(==)를 통해 비교 연산시 true가 도출
                           (= NaN은 그 자신과도 같은 값이 아니니, 당연히 느슨한 동등 연산자(==)를 통해 비교 연산시 false가 도출)
               
                           ex) null == undefined;  // true
                               NaN == NaN;         // false
               
                        c. 숫자로 형변환 된다면, 0으로 변환
                           (= null은 근본적으로 산술 연산이 가능함)
               
                3) NaN (Not A Number : 숫자가 아닌데, 숫자로 출력해야 하는경우 나오는 값)
                    : Not a Number의 의미의 숫자 연산이 유효하지 않을 때 반환되는 숫자(Number) 자료형의 특수값   
           
                     # NaN값의 특징
                        a. falsy에 해당하는 number 자료형의 값
                        b. 어떤 값과 연산을 하더라도 그 결과는 NaN이 반환
                           
                           ex) NaN + 5        -> NaN이 반환
               
                        c. 동등 연산자(==)를 통해서 자신(NaN)과 비교해도 같지 않음
               
                           ex) NaN == NaN;    -> false가 반환
           
             # undefined 자료형과 null값, NaN값 공통점/차이점 정리
           
                1) 공통점
   
                   a. 특수한 경우에 해당하는 값이나 자료형에 해당
                      (= 형변환 or 느슨한 동등 연산자(==) 처리에서 고유의 예외처리가 됨)
           
                   b. Falsy 값으로 평가 
                      (= boolean으로 형변환시 모두 false)
           
                      ex) Boolean(null);      ->  false
                          Boolean(undefined); -> false
                          Boolean(NaN);       -> false
           
                   c. '문자열'로 형변환시 각각 '자신의 이름'이 문자열 처리됨
           
                        ex) String(null);      -> "null"
                            String(undefined); -> "undefined"
                            String(NaN);       ->  "NaN"       
            
                2) 차이점
   
                   a. undefined는 그 자체가 자료형에 해당   <->   null은 {객체}의 특수값, NaN은 Number의 특수값에 해당
                   b. falsy값이지만, 각각 falsy값 그 자체로 느슨한 동등 연산자(==)가 true가 나오는건 null과 undefined만 해당됨
                      (= NaN은 그 누구와도 ==가 false가 됨)
           
                        ex) null == undefined;   -> true
                            NaN == NaN;          -> false
           
                   c. Number로 형변환 시
                       : null은 0으로 변환되어 산술 연산 가능  <->  undefined와 NaN은 NaN으로 변환되어 산술 연산의 결과로 무조건 NaN이 반환
                         (= 산술 연산으로 인한 강제 형변환 발생시에도 똑같은 원칙이 적용)
           
                         ex) Number(null);      ->  0
                             Number(undefined); -> NaN
                             Number(NaN);       -> NaN
           
                         ex) null + 5         ->  5
                             undefined + 5;   -> NaN
                             NaN + 5;         -> NaN
                            null + undefined -> NaN 


        @ (중요) JS의 자료형 변환(Coercion) 정리
           : 자료형이 프로그램이 실행되는 '런타임' 시 결정되는 동적 타입(dynamic type) 언어인 JS의 엔진은 코드를 실행할 시, 연산자를 사용할 시에 따른 형변환 로직과 형변환 함수의 호출에 실행의 결과로 자료형이 변하는 2가지 경우가 존재
        
              1) 연산자를 통한 암묵적 변환 (= 자동 형변환)
                  : JS에서 연산자를 쓰는 코드를 실행시 JS엔진에서는 해당 코드의 변수나 값이 예상된 유형과 맞지 않을 때 자동으로 형변환을 실행하여 코드를 실행함
                     -> (중요) 변환의 순서는 어떻게 결정?
                          : 상황과 연산자에 따라 다름
        
                    A. 산술 연산자 (+, -, *, /, %)
                        : '+' 연산자의 경우만 피연산자가 '문자열'인지를 따지는 특수성을 가짐
                           (= 나머지 산술 연산자들은 무조건 피연산자들을 모두 숫자로 변환한 후 연산함)
                               -> (중요) 특이사항
                                    1. 만약 숫자형으로 변환된 피연산자가 undefined를 포함하여 계산 불가능하거나 무효한 값이 나올 경우 NaN 자료형으로 반환
                                        -> NaN이 산술 연산자의 피연산자가 된다면 그 연산 결과는 무조건 NaN이 됨
                                    2. null -> 0으로 변형
           
                         a. '+' 연산자
                             : 피연산자 중 하나라도 '문자열' 이면? -> 2개의 피연산자를 '문자열'로 변환 뒤에 이를 연결함
                               (= 만약 피연산자 중 '문자열'이 없으면? 2개의 피연산자를 '숫자'로 변환 뒤에 덧셈 기호로서의 역할을 수행)
           
                               ex) '+'기호가 문자열 연결의 기호로 쓰임
                                     : null, NaN, undefined와 같은 falsy값도 예외는 없이 문자열로 변환
                               
                                       '5' + 2             ->  '52'
                                       null + '5'          ->  'null5'
                                       undefined + '가자'  -> 'undefined가자'
                                       NaN + ' 2'          -> 'NaN 2'
           
                               ex) '+'기호가 숫자 덧셈의 기호로 쓰임
                                     : true는 1로 변환되어 숫자로 덧셈
                               
                                       5 + true  -> 6 
        
                         b. '-' , '*' , '/' , '%' 연산자
                             : 무조건 2개의 피연산자를 '숫자'로 변환 뒤에 각각 기호로서 역할을 수행
           
                               ex) '숫자' 형태로 '문자열'이 존재한다면? 그냥 바꿔서 연산
                                     : 문자열 '10'이 숫자 10으로 변환
                               
                                       '10' + 2   ->  8
        
                                ex) null, NaN, undefined가 산출 연산자의 피연산자로 사용될 시
                                    : null은 0으로 변환, undefined는 NaN으로 변환, NaN은 그대로 유지됨 + NaN이 연산에 들어가면 무조건 NaN 반환
        
                                       null + 5          -> 5
                                       undefined - 0     -> NaN
                                       NaN + 2           -> NaN
        
                    B. 비교 연산자 (==, ===, <, >, <=, >=)
                        : 동등 연산자들인 '==', '===' 연산자와 비교 연산자 '<', '>', '<=', '>='의 작동로직이 다름
                            -> (중요) 동등 연산자들은 피연산자가 정말 같은지를 형변환을 단계적으로 하여 따지고, 다른 비교 연산자들은 비교를 목적으로 형변환을 수행항
           
                         a. 동등 연산자(==, ===)
                             : 2개의 피연산자가 같은지 여부를 판별하는 것을 중점으로 형변환 규칙이 적용됨
           
                              [1] ===
                                   : '엄격한 동등 연산자'로 2개의 피연산자의 자료형이 같은지까지 고려하여 같은지 여부를 판별
           
                                     ex) 자료형까지 따져가며 true, false 구분
           
                                         5 === (1 + 4) -> true
                                         '5' === 5     -> false
                                         false === 0   -> false
                                         [1] === 1     -> false 
           
                              [2] ==
                                   : '느슨한 동등 연산자'로 2개의 피연산자가 원래 어떤 자료형인지는 따지지 않고, 2개의 자료형이 다른 경우에 그에 맞는 방식의 형변환 규칙을 적용하여 피연산자들의 값이 같다는 것이 판명되면 true(= 1)로 판명
        
                                     # A == B 연산자의 로직
                                        : A와 B가 같은 자료형이라면 바로 같은지 비교하고.. 아니면 다음의 형변환이 포함된 규칙을 적용하여 값이 같은지를 판별
                                           -> (중요) 사실 숫자가 들어가면 원시형은 숫자로 형변환되고, 참조자료형와 원시값이 피연산자라면 참조자료형이 원시형으로 변환됨.. 그 외에는 falsy의 특수성을 고려함
           
                                          [1] null, undefined가 양 쪽에 보일시 서로 같은 값으로 인정 
           
                                              ex) (null == undefined) -> true
           
                                          [2] NaN은 자신과도 같지 않으므로 항상 false로 평가됨
           
                                              ex) (NaN == NaN) -> false
           
                                          [3] A가 숫자고, B가 '문자열'이면? >> '문자열' - 숫자로 변환해서 비교
                                        
                                              ex) '5' == 5   -> true
           
                                          [4] A가 boolean이고, B가 숫자면? >> boolean - 숫자로 변환해서 비교
                                        
                                              ex) false == 0   -> true
           
                                          [5] A가 참조자료형(reference type)이고, B가 원시형(primitive type)면? >> 참조자료형 - 원시형으로 변환해서 비교
                                               -> 참조자료형(reference type)의 원시형(primitive type)으로의 형변환 기본 값은 valueOf 또는 toString에 의해 결정됨
                                        
                                                  ex) 배열 [1]이 1로 변환
                                                  
                                                      [1] == 1    -> true
                                                         
                         b. '-' , '*' , '/' , '%' 연산자
                             : 피연산자 2개 모두 '문자열' 이면? -> 2개의 피연산자를 '문자열'로 변환 뒤에 사전순서를 기준으로 index가 앞선 게 크다고 인정
                               (= 만약 피연산자 중 1개라도 '문자열'이 아니면? 2개의 피연산자를 '숫자'로 변환 뒤에 숫자 크기를 기준으로 비교)
           
                               ex) 피연산자들 2개가 모두 '문자열' 형태라면? 사전순으로 비교하여 index가 먼저 오는 녀석을 큰 녀석으로 판정
        
                                   'apple' > 'banana'  ->  false
        
                               ex) 피연산자들 중 1개라도 '문자열'이 아니면면? 숫자로 변환한 후 비교
        
                                   '10' < 5   ->  false (문자열 '10'을 숫자 10으로 변환하여 비교)
        
                    C. 논리 연산자 (&&, ||, !)
                        
                       a. &&(AND), ||(OR)
                           : 2개의 피연산자들의 참/거짓(truthy/falsy) 여부를 판별하고, 이를 논리식으로 연산하여 해당하는 피연산자의 값을 반환하는 연성자
                              -> (중요) JS엔진은 Truthiness(각 자료형에 따른 값을 boolean으로 형변환시 true/false의 의미를 가짐) 개념을 사용
                                  : 피연산자를 불리언 값으로 변환 X, 해당 값 자체를 &&(AND), ||(OR)에 넣고 돌려 결과를 도출하고 그에 맞는 '피연산자의 값 그 자체'를 반환
                                  
                              [1] && (AND)
                                   : falsy에 해당하는 피연산자의 값이 보이자마자 해당 피연산자의 값을 반환
                                     (= 모든 피연산자들의 값들이 truthy일 때, 마지막 피연산자의 값을 반환)
          
                                      ex) 'hi'는 truthy지만, 0은 falsy -> 1번쨰 피연산자의 값이 falsy이므로 1번쨰 피연산자들의 값인 0 반환
                                      
                                          0 && 'hi' && true -> 0
           
                                      ex) 'hi'는 truthy지만, 0도 truthy -> 모든 피연산자들의 값들이 truthy에 해당 = 마지막 피연산자의 값인 0 반환
                                      
                                          'hi' && 1  -> 1
        
        
                              [2] || (OR)
                                   : truthy에 해당하는 피연산자의 값이 보이자마자 해당 피연산자의 값을 반환
                                     (= 모든 값들이 false(정확히는 falsy)일 때, 마지막 피연산자의 값을 반환)
          
                                      ex) null == falsy에 해당하나, 'hello'는 truthy에 해당하는 값이기에 'hello' 반환
                                      
                                          null || 'hello'  -> 'hello' 
          
                                    # && (AND)의 특이사항
                                       : 연산 우선순위는 || (OR)보다 높으나... 수학에서 그렇듯 ()가 가장 연산에서 우선시 됨
          
                                          ex) false && false 가 먼저 연산되어 false도출, 그 후 true || false 계산
                  
                                              true || false && false  ==  true || (false && false)  -> true
          
                                          ex) (true || false) 가 먼저 연산되어 true도출, 그 후 true && false 계산
                                          
                                              (true || false) && false  -> false
        
              2) 형변환 함수 및 메서드 호출을 통한 변환 (= 수동 형변환) 
                  : 사용자가 어떤 값의 자료형을 특정 자료형으로의 '형변환'을 목적으로 하는 함수나 메서드의 매개변수(parameter)의 인자(augument)로 넣어서, 직접 형변환을 해주는 경우  
        
                    A. 참조자료형(reference type) - 원시형(primitive type) 형변환시 기본 값을 지정하는 valueOf() 메서드, toString() 메서드
                        : JS의 모든 자료형은 JS객체(Object)기반 = 모든 참조자료형(reference type)은 원시형(primitive type)으로 변환시 특정 메서드들을 호출하여 그 결과값을 반환함
        
                         # 참조자료형(reference type) - 원시형(primitive type) 변환시 메서드 호출 로직
                            1. 변환하는 원시형이 '문자열'이 아니며, valueOf() 메서드를 호출하고 그 반환값이 있다?
                               -> Y : 이를 형변환의 결과값으로 사용
                               -> N : 2번으로 
        
                            2. valueOf() 메서드가 적절한 값을 반환하지 않거나, 변형하는 자료형이 '문자열'에 해당하면 2번쨰로 toString() 메서드를 호출하고 그 반환값이 있다?
                               -> Y : 이를 형변환의 결과값으로 사용
                               -> N : 이러한 규칙이 적용되지 않으면 **TypeError**가 발생
        
                            ex) obj라는 변수가 저장하는 {리터럴 객체}에는 valueOf()의 결과값으로 42가 반환되어, 원시형으로 형변환시 42가 반환되어 사용
        
                                let obj = {
                                  valueOf: () => 42,
                                  toString: () => 'Object'
                                };
                                
                                console.log(obj + 1);   ->  43
        
                            ex) obj라는 변수가 저장하는 {리터럴 객체}에는 valueOf()가 없기에 toString()의 결과값으로 'Object'가 반환되어, 원시형으로 형변환시 'Object'가 반환되어 사용
        
                                let obj = {
                                  toString: () => 'Object'
                                };
                                
                                console.log(obj + 1);   ->  'Object1'
        
                    B. 원시형(primitive type) - 다른 원시형(primitive type) 형변환해주는 함수나 메서드
                        : 각 원시형 값들은 형변환 함수 및 메서드를 통해 다른 자료형의 값으로 변경이 가능!
        
                         a. String(값)
                             : 해당 함수의 매개변수(paramter)에 대입된 인자(augument)에 해당하는 값의 자료형을 '문자열'로 바꿔주는 함수
        
                              # 경우에 따른 String(값)
        
                                 1. String(숫자)
                                     : '숫자' 형식의 문자열로 변경
                                       
                                       ex) String(123)  -> '123'
        
                                 2. String(boolean)
                                     : true는 'true'
                                       false는 'false' 로 변환
        
                                       ex) String(true)  -> 'true'
        
                                 3. String(참조자료형)
                                     : toString() 메서드를 사용하여 문자열로 변환
        
                         b. Number(값)
                             : 해당 함수의 매개변수(paramter)에 대입된 인자(augument)에 해당하는 값의 자료형을 숫자로 바꿔주는 함수
        
                              # 경우에 따른 Number(값)
        
                                 1. Number('문자열')
                                     : 문자열은 숫자 형식이라면 그에 맞게 변환하나, 숫자라고 할 수 있는게 아니면 NaN반환
                                       
                                       ex) Number('123')  -> 123
                                           Number('ABC')  -> NaN
        
                                 2. Number(boolean)
                                     : true = 1, false = 0 로 변환
        
                                       ex) Number(true)  -> 1
        
                                 3. Number(null) = 0
                                 4. Number(undefined) = NaN
        
        
                         c. Boolean(값)
                             : 해당 함수의 매개변수(paramter)에 대입된 인자(augument)에 해당하는 값의 자료형을 Boolean로 바꿔주는 함수
                               (= 그러니까 Boolean(값)은 어떤 값을 boolean 자료형으로 형변환(type colution)을 시켜주는 함수)
                                   -> BUT! 하지만 Truthiness 개념을 사용하는 JS에서는 굳이 안 그래도 됨
        
                              # Boolean(값)의 연산결과 
        
                                 1. Boolean(falsy값) = false
                                     : 0, NaN, null, undefined, '' (빈 문자열)에 해당하는 값이 parameter로 들어가면 false 반환
                                       
                                    ex) Boolean(0)         -> false
                                        Boolean(NaN)       -> false
                                        Boolean(null)      -> false
                                        Boolean(undefined) -> false
                                        Boolean('')        -> false
        
                                 2. Boolean(truethy값) = true
                                     : 1번에 해당하지 않는 모든 값들은 다 true 반환
        
                                       ex) String(true)  -> 'true'


        @ (ES6 이후) 구조분해 문법 (Destructuring)
            : 참조 자료형에 해당하는 [배열], {객체}의 내부 요소 및 프로퍼티들의 값들을 '=' 연산자를 통해서 쉽게 대입하거나 꺼내쓸 수 있게 만든 문법
              (= 이 문법의 존재로 복잡한 방법으로 [배열], {객체} 값을 다른 변수 및 [배열], {객체}에 고대로 대입시키는데 고생을 안해도 됨)

              1) [배열]의 일괄적인 내부요소들 -> 개별 변수들에 대입
                   -> (중요) 반드시 [배열] 앞 var가 붙어 있어야 함

                       A. var ['변수1', ... , '변수N'] = [내부요소1, 내부요소2, ... , 내부요소N]
                           -> 이러면 '변수1' = 내부요소1; , ... , '변수N' = 내부요소N; 으로 대입이 완료
     
     
                              ex) 변수 a, b, c를 각각 [2,3,4]의 내부요소에 대입하는 방법
        
                                   a. 예전방식 사용
                                   
                                      var array = [2,3,4];
                                      var a = array[0]; 
                                      var b = array[1];
        
                                   b. 구조분해 문법 (Destructuring)  사용
                                   
                                      var [a,b,c] = [2,3,4];
     
                       B. var ['변수1', ... , '변수N' = 기본값] = [내부요소1, 내부요소2, ... , 내부요소N-1]
                           -> (참고) 특정 변수에 기본값(default value)을 주는 것 또한 가능함
     
                               ex) 변수 a, b, c를 각각 [2,3]의 값을 대입하되, c는 기본값(default value)를 주는 예시
      
                                   var [a,b,c = 5] = [2,3];

              2) {객체}의 일괄적인 내부 프로퍼티값 -> 개별 변수들에 대입
                   -> (중요) 반드시 {객체} 앞 var가 붙어 있어야 함

                      A. var { 프로퍼티명1 : 변수1 , ... , 프로퍼티명N : 변수N } = { 프로퍼티명1 : '값1' , ... , 프로퍼티명N : '값N' }
                          -> 이러면 '변수1' = '값1'; , ... , '변수N' = '값N'; 으로 대입이 완료
     
                             ex) {객체}의 내부 프로퍼티들의 값을 a, b에 대입하는 방법
        
                                 var { name : a, age : b } = { name : 'Kim', age : 30 };     
     
                      B. var { 프로퍼티명과 같은 변수1 , ... , 프로퍼티명과 같은 변수N } = { 프로퍼티명1 : '값1' , ... , 프로퍼티명N : '값N' }
                          -> 각 '프로퍼티명 = 변수'에 해당하는 경우는 '프로퍼티명1' = '변수1'이 생략되어도 됨
     
                             ex) {객체}의 내부 프로퍼티들의 값을 프로퍼티명과 같은 변수들인 name, age에 대입하는 방법
        
                                 var { name, age } = { name : 'Kim', age : 30 };     
     
     
                     @ {객체} 내부나 [배열] 내부가 중첩되는 경우 -> 개별 변수들에 대입 = 1) 2)의 중첩되는 경우
                         -> {객체}의 내부 프러퍼티 구조가 복잡해도 구조분해 문법 (Destructuring)은 본질적으로 작동함!
                            (= 데이터가 얼마나 복잡하든간에 좌우 형태를 똑같이 맞추시면 destructuring 문법으로 변수를 만들 수 있다)
     
                             ex) {신체정보}에서 height, weight, 상의사이즈, 하의사이즈 정보를 각각 뽑아서 4개의 변수에 넣고 싶으면, 그냥 배운데로 {객체}, [배열]에 변수를 넣어라
                                   -> 
     
                                 let 신체정보 = {
                                   body: {
                                     height: 190,
                                     weight: 70
                                   },
                                   size: ["상의 Large", "바지 30인치"],
                                 };
                                 
                                 let {
                                   body: {
                                     height, 
                                     weight
                                   },
                                   size: [ 상의, 하의 ]
                                 } = 신체정보;

              3) 일괄적인 개별 변수들 -> {객체}의 내부 프로퍼티값에 대입

                  A. var 변수명1 = '값1';  ...  var 변수명N = '값N';
                     var 객체명 = {프로퍼티명1 : 변수명1 , ... , 프로퍼티명N : 변수명N }
                      -> 이러면 '프로퍼티명1' = '변수명1'; , ... , '프로퍼티명N' = '변수명N'; 으로 대입이 완료된 {객체}를 얻을 수 있음

                         ex) {객체}의 내부 프로퍼티들의 값을 var1, var2에 해당하는 값으로 똑같이 대입하는 방법
     
                             var var1 = 'Kim';
                             var var2 = 30;
                             
                             var obj = { name : var1, age : var2 }   

                  B. var 프로퍼티명과 같은 변수1 = '값1';  ...  var 프로퍼티명과 같은 변수N = '값N';
                     var 객체명 = {프로퍼티명과 같은 변수1 , ... , 프로퍼티명과 같은 변수N }
                      -> 이러면 '프로퍼티명1 = ' 부분이 생략이 가능하며, 변수명을 그 자체로 {객체}의 프로퍼티명으로 간편히 정의하여 사용가능

                         ex) {객체}의 내부 프로퍼티명을 변수명인 name, age으로 그대로 정의하고 값 또한 똑같이 대입하는 방법
     
                             var name = 'Kim';
                             var age = 30;
                             
                             var obj = { name, age  }   
  
              4) [배열], {객체}의 내부 요소 -> 함수의 같은 parameter명들에 해당하는 부분에 순차적으로 augument로 대입

                  A. {객체} 내부의 프로퍼티들 -> 특정 함수의 같은 parameter명들에 해당하는 부분에 순차적으로 augument로 대입
                      : 2)의 B부분인 { 프로퍼티명과 같은 변수1 , ... , 프로퍼티명과 같은 변수N } = { 프로퍼티명1 : '값1' , ... , 프로퍼티명N : '값N' }의 응용버전
   
                        ex) 함수라는 함수에 parameter로 {obj}의 내부 프러퍼티인 name과 age의 값을 augument로 넣고 싶은 경우
   
                            a. 예전방식 사용
                                : {객체}.프로퍼티명을 함수 호출시 그대로 parameter변수 자리에 대입하여 넣음
                            
                                  function 함수(name, age){
                                    console.log(name);
                                    console.log(age);
                                  }
                                  
                                  var obj = { name : 'Kim', age : 20 }
                                  함수(obj.name, obj.age);
      
                            b. 구조분해 문법 (Destructuring)  사용
                                : {name, age} = { name : 'Kim', age : 20 }을 응용하여, {obj}의 name과 age부분에 해당하는 프로퍼티와 같은 parameter명에 해당하는 부분에 자동으로 대입됨
                            
                                  function 함수( { name, age }){
                                    console.log(name);
                                    console.log(age);
                                  }
                                  
                                  var obj = { name : 'Kim', age : 20 };
                                  함수(obj);

                  B. [배열] 내부의 요소들 -> 함수의 parameter명들에 해당하는 부분에 순차적으로 augument로 대입
                      : 1)의 A부분의 응용버전
   
                        ex) 함수라는 함수에 parameter로 [array]의 내부 요소들을 순차적으로 augument로 넣고 싶은 경우

                            a. 예전방식 사용
                                : [배열]의 내부 요소들을 [index]를 이용 각각 parameter변수 자리에 대입하여 넣음
                            
                                  function 함수( name, age ){
                                    console.log(name);
                                    console.log(age);
                                  }
                                  
                                  var array = [ 'Kim', 30 ];
                                  함수(array[0], array[1]);
      
                            b. 구조분해 문법 (Destructuring)  사용
                                : 그냥 통째로 [배열]을 parameter자리에 augument로 집어넣으면, 알아서 내부요소들이 parameter변수의 순서에 맞게 순차적으로 대입됨
                            
                                  function 함수( [name, age] ){
                                    console.log(name);
                                    console.log(age);
                                  }
                                  
                                  var array = [ 'Kim', 30 ];
                                  함수( ['Kim', 30] );



  3. {객체}의 확장 (object extend)
      : JS의 {객체}는 OOP언어들의 영향을 받아 객체지향의 4원칙(상속, 다형성, 캡슐화, 추상화) 중 구현 방식은 다르지만 '상속(inheritance)', '캡슐화'을 일부 구현하였음
         -> (중요) '추상화'는 TypeScript 라이브러리를 통해 본격적으로 구현, '캡슐화' 중 '접근제어자'는 ECMA 공식으로도 일부 신 문법으로 등장시킴

       @ {object(객체)}
            : 연관된 변수(= 프로퍼티)나 그 변수들을 조작하는 함수(= 메서드)들을 모아놓은 타입을 구현한 key와 value의 집합체인 데이터 구조에 해당하는 JS의 자료형 
                -> JSON은 참조자료형을 '문자열'로 변환시킨 형태로 나중에 프로그래밍 언어를 통해 '참조자료형' 원형으로 파싱이 가능하게 한 형태이기에 
                   (= {객체} != JSON)

             # {object(객체)} 종류
                 1) { literal type object(리터럴 형식 객체) }
                      : 사용자가 직접 {객체}의 내용부를 작성하여, 특정 변수나 상수에 저장한 {객체}
                         -> (주의) { literal type object(리터럴 형식 객체) }는 자신만의 스코프{} 영역이 실제로는 존재하지 않음 = 자신의 직속 상위 요소의 스코프{} 영역에 속하게 됨 
                            (= arrow function(화살 함수)이 직속 상위 요소의 스코프{} 영역에 속하게 되는 것과 원리가 일치함)

                            ex) var 학생1 = { 
                                     name : 'Kim', 
                                     age : 15 ,
                                     sayHi : function(){
                                         console.log('안녕하세요' + this.name + ' 입니다');
                                     }
                                 };

                 2) new 연산자와 생성자(constructor) 함수를 통해 생성된 {객체}
                     -> 생성자(constructor) 함수 부분에서 설명

             # {object(객체)}의 작성 구조 및 형식
                 a. key = {객체}의 프로퍼티  
                     : 프로퍼티명에 해당하는 명칭을 그냥 작성하면, 그대로 프로퍼티명이 됨
                        -> (참고) EMCA6 부터 {[변수명] : '프로퍼티의 값'} 과 같은 형식으로 특정 변수명에 저장된 값을 key로 삼을 수 있게 됨

                           ex) '변수명'이란 변수에 해당하는 값이 동적으로 변해도 {사람}이라는 {객체} 내부의 프로퍼티명을 그 응답에 맞춰 지을수 있음 가능함

                               let 변수명 = confirm('당신 나라에서 이름에 해당하는 단어를 입력해라');

                               let 사람 = {
                                     [변수명] : 'Kim', 
                                     age : 15 ,
                                     sayHi : function(){
                                         console.log('안녕하세요' + this.name + ' 입니다');
                                     }                  
                               }

                 b. value = {객체}의 개별 프로퍼티의 값
                     : 값에 해당하는 자료형의 형식을 지켜 작성해야 함

             # (참고) {object(객체)} 관련 팁
                 a. JS에서는 함수도 '1급 객체(first-Class Citizen)'에 속하는 {객체}로서, 함수를 변수, return문, 함수의 인자로 할당 가능

                 b. {Map 객체}와 마찬가지로 {object 객체}의 key값(key명) 또한 메모리주소값으로 사용되는 hash값으로 변환되는 seed값임

                 c. {객체} 내부 {프로퍼티}도 {객체}에 해당
                    (= {프로퍼티} 마다 숨겨진 속성이 기본적으로 존재 == {객체} 자료형은 무거움)

                 d. 프로퍼티(property)에 저장된 값이 {객체}인 경우, const를 걸어도 {객체} 내부의 프로퍼티의 변경은 막지 못함

                 e. {객체} 내부의 프로퍼티와 메서드를 선택 및 호출하는 법은 2가지
                      - {객체명}.프로퍼티명
                      - {객체명}[프로퍼티명]
                          -> (중요) [배열] 또한 {객체}이기에 [배열]의 내부 요소 선택 또한 이 방법으로 구현한 것... 'index값' 자체가 일종의 '프로퍼티명'에 해당 

             # JS의 {객체} 구조를 이루는 멤버들
                : {객체} 내부에는 원시값(primitive value), 참조값(reference value)를 저장하는 '멤버변수 = 속성 = 프로퍼티(property)'와 함수표현식(function expression)에 해당하는 함수를 저장하는 '메서드(method)'가 존재함
                    -> (중요) {객체}의 멤버변수나, 메서드나 선택하거나 호출하는 방법은 전부 같음

                        ex) {학생1}이라는 {객체}의 예시... name, age라는 원시값을 가지는 프로퍼티와 sayHi 라는 메서드로 구분되어 있음
                        
                             var 학생1 = { 
                                 name : 'Kim', 
                                 age : 15 ,
                                 sayHi : function(){
                                     console.log('안녕하세요' + this.name + ' 입니다');
                                 }
                             };

                   a. 멤버변수 = 속성 = 프로퍼티(property)
                       : {객체}와 연관되어 {객체}를 이루는 개별 속성들에 대한 값들을 저장하는 {객체} 내부의 변수
                           -> (프로퍼티 선택법)
                                1) 원시값(primitive value)이 저장된 경우
                                    : {객체명}.프로퍼티명 = {객체명}[프로퍼티명]

                                2) 참조값(reference value)이 저장된 경우

                                   - {객체}인 경우
                                       : {객체명}.프로퍼티명.프러퍼티명 = {객체명}[프로퍼티명][프러퍼티명]

                                   - [배열]인 경우
                                       : {객체명}.프로퍼티명[인덱스번호]

                   b. 메서드(method)
                       : {객체} 내부의 프로퍼티(property)의 조작 및 이를 활용한 연산을 하기 위한 목적으로 함수를 {객체} 내부에 저장한 함수표현식(function expression) 형식의 함수
                           -> (메서드 호출법)
                                : {객체명}.메서드명(...auguments) = {객체명}[메서드명](...auguments)

             # {객체}를 기반으로 만들어진 JS의 참조 자료형
                : 까놓고 말해서, 그냥 {객체}는 JS라는 언어 성립에 있어 가장 근간을 이루는 참조 자료형이라고 보면 됨
 
                   a. 배열(Array)
                       : 숫자 인덱스를 사용하여 데이터의 순서화된 집합
 
                   b. 셋(Set)
                       : 값의 집합으로, 중복된 값이 허용 X       
                         (= 중복X인 유사 [배열])
 
                   c. 맵(Map)
                       : 키-값 쌍의 집합으로, 키의 순서가 유지되고 중복 허용X
                         (= key영역 중복X인 유사 마이너 {객체})
                   
                   f. 함수(Function)
                       : 코드의 재사용을 가능하게 하기 위한 블록을 가진 모듈 
                          -> JS에서는 함수도 {객체}이므로 자신만의 프로퍼티(자신이 선언된 {}정보 등등) 있음 + '1급 객체(first class citizen)'로서 '값'으로서 취급될 수 있음
                   
                   d. 날짜(Date)
                       : 날짜와 시간을 나타냄
                   
                   e. 정규 표현식(RegExp)
                       : 문자열 패턴을 나타내며, 정규식을 사용할 수 있게 됨
 
              # {객체} 자신의 메서드

                  a. Object.hasOwnProperty(프로퍼티명)
                      : 해당 '프러퍼티명'이 현재 {객체}에 존재하는지 boolean값으로 판별하는 기능
                  
                  b. Object.getOwnPropertyDescriptor({객체명}, '프로퍼티명') 
                      : 어떤 {객체}의 {내부 프러퍼티명}의 모든(숨겨진 거 포함) 속성과 속성값을 확인하는 기능


       @ 생성자(constructor) 함수
          : JS라는 언어의 근간을 이루는 {객체}를 특정 형태의 {객체}로 빠르고 쉽게 만들어주는 함수는 OOP언어는 아닌 JS에서도 존재함
            (= 새로운 참조값을 가지는 독립된 {객체}를 생성하고, 그 안의 멤버변수(프로퍼티)들의 값을 집어넣는 것의 수고를 덜어줌)
                -> (ES6 이전) function을 통해 만드는 일반함수의 내부에서 {객체} 구조를 만들고, 이를 반환하는 형식으로 구현
                   (ES6 이후) ES6 이후로는 JS에서도 OOP언어와 마찬가지로 class 형식의 문법을 사용가능하게 되었고, 그 내부의 메서드로서 구현됨   

            1) (ES6 이전) 일반함수로서 구현된 생성자 함수
                 : function 생성자함수명(...프로퍼티값){ this.멤버변수명; this.멤버메서드명 }과 같은 식으로 this를 통해 해당 멤버들이 생성된 {객체}의 참조값을 참조한다는 부분을 언급하여 작성
                    -> new 생성자함수명(...프로퍼티값); 형식으로 앞에 새로운 참조값(reference value)를 생성한다는 생성자인 new를 꼭 붙여서 호출

                       ex) 학생라는 생성자함수는 name이라는 프로퍼티의 값을 이름이라는 parameter변수로 받아서 입력하여, 새로운 {학생} 형식의 {객체}를 생성함... 이를 통해 {객체}의 생성을 동적으로 할 수 있음
                       
                           function 학생(이름, 나이){
                             this.name = 이름;
                             this.age = 나이;
                             this.sayHi = function(){
                               console.log('안녕하세요' + this.name + ' 입니다. 저는 현재 ' + this.age + '살 입니다');
                             }
                           }
                           
                           var 학생1 = new 학생('Park', 15);
                           var 학생2 = new 학생('Kim', 20);
                           
                           학생2.sayHi();
                            -> '안녕하세요 Kim 입니다. 저는 현재 20살 입니다' 출력

            2) (ES6 이후) class 내부에 constructor 문법으로 구현된 생성자 함수 
                : class 클래스명 { constructor(...프로퍼티값){ this.멤버변수명; this.멤버메서드명 } }과 같은 식으로 this를 통해 해당 멤버들이 생성된 {객체}의 참조값을 참조한다는 부분을 언급하여 작성하는 부분도 같음
                    -> new 생성자함수명(...프로퍼티값); 형식으로 앞에 새로운 참조값(reference value)를 생성한다는 생성자인 new를 꼭 붙여서 호출

                       ex) 보다시피 외관은 차이가 아주 OOP와 흡사함.. BUT! 기능상 차이 X
                       
                           class 학생 {
                             constructor(이름, 나이){
                               this.name = 이름;
                               this.age = 나이;
                             }
                             sayHi(){
                                console.log('안녕하세요' + this.name + ' 입니다. 저는 현재 ' + this.age + '살 입니다');
                             }
                             sayHello(){
                               console.log('안녕하세요');
                             }
                           }

                           var 학생1 = new 학생('Park', 15);
                           var 학생2 = new 학생('Kim', 20);
                           
                           학생2.sayHi();
                            -> '안녕하세요 Kim 입니다. 저는 현재 20살 입니다' 출력


       @ (중요) {객체} 상속과 [[prototype]] 체인 로직
          : OOP언어가 아닌 JS에서 {객체}의 상속(inheritance)를 다룰 수 있도록 만도록 [[prototype]] 속성을 활용하는데, 이를 {객체} 내부의 속성(프로퍼티, 메서드)를 상속 계보 전체를 대상으로 찾는데 사용할 수 있도록 하는 로직
             -> 쉽게 말해, [[prototype]] 속성으로 '선조 - 후손' 구분 + 어떤 '요소명'을 {자신} TO {부모}가 가지고 있는지 [[prototype]] 속성을 사용해서 검사하는데도 사용함
                (= 이 [[prototype]]를 바탕으로 JS는 OOP도 아니지만, 그 수많은 내부기능들을 {Object}를 최상위 기반으로 한 {객체}로서 구현하고 확장이 가능함)

            # (참고) {객체}에서 '상속'이 가능하다는 이점
               1) 코드 재사용
                   : 상속을 사용하면, 코드의 재사용성이 높아짐 = 유지보수와 확장이 쉬워짐

               2) 성능 최적화 
                   : '상속'이 없다면, 자주 쓰는 프러퍼티나 메서드를 추가하는 노고도 들지만, 메모리에서도 이를 일일히 할당하게 됨...
                       -> 하지만, '상속' 기능을 사용하게 되면, 공통된 부분은 1개의 참조값으로 같이 쓰면 그만임

               3) 확장 가능성
                   : 공통기능 추가가 매우 쉽고, 이를 통해 복잡한 구조를 가진 {객체}라도 체계적으로 생성 및 조작이 체계적으로 가능함

            # 최선조 {Object} 객체
               : JS에서 모든 {객체} 기반 자료형이나 요소들 위에 군림하는 최상위 선조와 같은 요소로.. JS에서 {객체} 자료형이란 이 녀석을 최선조로 하여 생성되고 작동함
                 (= 최상위 선조에 해당하는 {객체}이므로 [[prototype]] 프로퍼티에는 아무것도 존재하지 않음)

                 ex) 모든 [배열]의 [[prototype]]에는 [배열] 생성자 함수인 Array()가 있으며, 그 생성자 함수 Array()의 [[prototype]]에는 Object() 생성자 함수가 존재
                      -> [배열] 자료형에서는 sort, push, toString, map, forEach 등 이런 내장함수들이 [[prototype]]에 존재하기에 사용이 가능함

                         var arr = [1,2,3];
                         console.log( arr.toString() ); 
                          -> [arr]가 [[prototype]]에 참조되는 Array()라는 '생성자 함수'가 자신의 {부모}에 해당하는 [[prototype]] 속성 중 toString()이라는 함수도 포함되어 있으니 사용이 [[prototype]] 체인 로직으로 찾아 사용이 가능 

            # [[prototype]] 프로퍼티
                 : 모든 JS {객체}가 가지고 있는 숨겨진 내부 프로퍼티로 {부모}에 해당하는 {객체}의 참조값을 저장하여 상속 관계 구현 용도에 사용
                   (= 모든 JS {객체}는 어떻게든 생성되는 순간 [[prototype]] 속성 또한 생성되며, {부모 객체}의 참조값을 저장하기에 {부모}의 속성(프로퍼티, 메서드)에 접근할 수 있게 됨으로서 상속관계를 구현함)
                       -> (중요) 'function 생성자 함수'을 통해 생성된 {객체}는 '생성자 함수'의 [[prototype]] 속성을 자신의 [[prototype]] 속성으로 상속받게 되어 있음

                  - (중요) [[prototype]] 속성 특성

                      1) 일반적인 {객체}와 [[prototype]] 속성
                          : 일반적인 {객체}와 [[prototype]] 속성은 '캡슐화'와 '은닉화'가 적용되어 있는 속성이라 접근제어자(getter, setter)를 통해 접근해야 함
                            (= {객체명}.prototype으로 접근하려고 해봐야 아무것도 나오지 않으며, 특별한 접근제어자(getter, setter) 역할을 하는 무언가를 통해 접근해야 함)

                      2) '생성자 함수'와 [[prototype]] 속성

                          A. (중요) 'function 생성자 함수'을 통해 생성된 {객체}는 '생성자 함수'의 [[prototype]] 속성을 자신의 [[prototype]] 속성으로 상속받게 되어 있음
                          B. '생성자 함수'는 {함수 객체}로서 [[prototype]] 속성을 내부적으로 가지고 있지만 그냥 접근이 가능함
                                -> Why? '생성자 함수'에서의 [[prototype]] 속성은 개발자로 하여금 다른 '생성자 함수'와의 상속관계를 설계할 수 있도록 하는 정보를 담는 프로퍼티이기 때문에 '캡슐화'와 '은닉화'는 되어 있지 않음
                                   (= OOP언어에서 class 간의 '상속'과 같은 기능과 유사한 기능을 수행하도록 하기 위한 목적)
  
                                   ex) 그 증거로 [배열]들을 생성하는 Array() 생성자 함수의 [[prototype]]는 접근제어자 안 쓰고도 접근 가능 
         
                                       console.log(Array.prototype);
                                        -> Array() 생성자 함수의 [[prototype]]에 설정해 놓은 프러퍼티, 메서드 그리고 Array()와 상속 관계로 설정된 '생성자 함수'의 정보를 중첩된 [[prototype]] 속성으로 볼 수 있음

                          C. a의 연장으로 '생성자함수명.prototype.속성명'를 통해 {부모}에게 있는 '속성'은 볼 수 있고, 없는 '속성'면 해당 속성에 값이나 함수를 대입하여 새로운 프러퍼티나 메서드로 생성이 가능함
                              -> [[prototype]]이 참조하는 것은 {부모}의 참조값이라... 값을 여러개 부여할 수도 있고, 심지어 함수도 집어넣으실 수 있음

                                 ex) gender라는 속성은 본래 부모에는 없었지만 설정이 가능
           
                                     function 기계(){
                                       this.name = 'Kim';
                                       this.age = 15;
                                     }
                                     
                                     기계.prototype.gender = '남';
   
                                     var 학생1 = new 기계();
                                     
                                     console.log(학생1.__proto__);   // 남
                                     console.log(기계.prototype);    // 남

                          D. 특정 {객체} 형식들의 인스턴스들이 공통적으로 가지고 있다는 점에서 클래스(class)의 정적(static) 멤버변수 개념에 더 가까움
                             (= 생성자 함수의 {prototype} 내부의 프로퍼티가 변하면, 클래스(class)의 정적(static) 멤버변수와 마찬가지로 모든 해당 생성자 함수를 거친 {객체}들에 일괄 적용됨)
       
                              ex) gender가 '남'으로 변하던, '여'로 변하던, {학생1}의 __proto__나 Object.getPrototypeOf(학생1)은 값이 변하는 족족 바로 갱신함
        
                                  console.log(학생1.__proto__);   // 남
                                  console.log(기계.prototype);    // 남
                                  
                                  기계.prototype.gender = '여';
                                  
                                  console.log(학생1.__proto__);   // 여
                                  console.log(기계.prototype);    // 여

                  - (중요) {일반 객체}의 [[prototype]]속성에 접근하기 위한 접근제어자(getter/setter) 역할의 메서드 및 프러퍼티

                     1) (ES5 이전) 모든 {객체}들의 접근제어자 __proto__
                         : 어떤 {객체}의 {부모} 위치에 대한 참조값을 가지는 [[prototype]] 속성에 대한 접근자(getter/setter) 역할을 하는 '비표준' 프로퍼티
                           (= __proto__는 비표준 {Object}를 통한 get/set 메서드는 표준이기에... 성능이나 호환성이나 명확성이나 후자가 압도적으로 권장됨!)
                               -> {객체명}.__proto__를 들여다보면 getter역할, 거기에 {객체}를 참조값으로 대입하면 setter역할이 됨
                               
                                   ex) {객체명}.__proto__ 
                                         : 현재 {객체명}의 [[prototype]]의 참조값을 반환해주는 getter역할을 수행
                                         
                                   ex) {객체명}.__proto__  = {대상 객체명}
                                         : 현재 {객체명}의 [[prototype]]의 값을 다른 객체의 참조값으로 대입해주는 setter역할을 수행
   
                                           ex) {자식}의 {부모 객체}를 {부모}라고 임의적으로 관계를 정립
                                                 -> 자식.__proto__.name =  자식.name 과 같이 사용도 가능
                                           
                                                    var 부모 = { name : 'Kim' };
                                                    var 자식 = {};
                                                    
                                                    자식.__proto__ = 부모;
                                                    console.log(자식.name);   

                     2) (ES5 이후) {Object}의 '표준' 메서드
                         : JS에서 표준으로 인정하는 {객체} 간 상속관계를 규정하는 [[prototype]] 관련 접근제어자를 다루는 일종의 정적 메서드
                            -> (참고) 비표준이 아니라서 유리한점
                                 1) 호환성 : 표준인 쪽은 모든 최신 브라우저에서 동일하게 동작하게끔 명시되어 있어 그렇게 설계됨
                                 2) 성능   : 당연한 이야기지만, 성능적으로도 표준이라 제작시에도 신경써서 검증과 최적화를 거침
                                 3) 명확성 : 명시적으로 알아먹을수 있게 설계가 되기에, 의도치 않은 오류를 줄일 수 있어서, 유지보수와 안정성이 높아짐

                           [1] Object.getPrototypeOf(객체명)
                                : 해당 {객체명}의 [[prototype]]의 참조값을 반환해주는 getter역할을 수행
      
                           [2] Object.setPrototypeOf(객체명, 대상 객체명)
                                : 현재 {객체명}의 [[prototype]]의 값을 다른 객체의 참조값으로 대입해주는 setter역할을 수행

            # [[prototype]] 체인 알고리즘 로직의 진행과정
               : 어떤 {객체}가 자신의 계보를 대상으로 '프로퍼티'나 '메서드'를 검색할 때 사용하는 알고리즘.. 
                  -> 간단하게 적자면, {자신} TO {부모}가 가지고 있는지 [[prototype]] 속성을 사용해서 검사하고, 없으면 자신의 [[prototype]] 내부의 중첩된 [[prototype]]을 통해 재귀식으로 {자신}의 선조들에게도 똑같은 방식으로 대상 '속성'이 있는지를 검색함
                     (= ES6이후 외관이 class 문법으로 변한 상속 문법에서도 똑같은 방식으로 작동하게 되어있음)

                     1) 해당 {객체명} 내부에 '요소명'에 해당하는 '프로퍼티'나 '메서드'가 존재하는지 check하고
                         -> 있으면 쓰고, 없으면 [2]로 ..
     
                     2) 해당 {객체명}의 {부모 객체}가 {prototype 객체} 정보를 담는 내부 프러퍼티 {__proto__}에는 해당 '요소명'이 있는지 check
                         -> 있으면 쓰고, 없으면 [3]로 ..
     
                     3) 해당 {prototype 객체}의 부모의 prototype 정보를 담는 중첩된 {prototype 객체}에는 해당 '요소명'이 있는지 check
                         -> 있으면 쓰고, 없으면 [3]을 계속 반복하여 최선조까지 치고 올라감.. 없으면 [4]로..
                            (= 같은 '요소명'을 {객체명}의 선조들이 가지고 있다쳐도, 자신에게 더 가까운 선조의 '요소명'을 가져다 쓰게 되어 있음 = 일종의 오버라이드(override)의 구현)
     
                     3) 4)을 반복해서 Root인 Object.prototype까지 거슬러 올라서도 해당 '요소명'을 찾을 수 없으면 undefined를 반환

                        ex) 그 두 생성자 함수는 Dog.prototype = Object.create(Animal.prototype) 코드를 통해 '상속 관계' 처리가 되어있음 
                             -> 생성자 함수인 Animal과 Dog은 각각 [[prototype]]으로 speak라는 메서드를 각각 {자식}에 보내는데, [[prototype]] 체인을 통해 {dog}는 자신과 가장 가까운 Dog 함수 객체의 speak() 메서드를 찾아 실행함

                                function Animal(name) {
                                  this.name = name;
                                }
                                
                                Animal.prototype.speak = function() {
                                  console.log(`${this.name} makes a noise.`);
                                };
                                
                                function Dog(name) {
                                  Animal.call(this, name);
                                }
                                
                                Dog.prototype = Object.create(Animal.prototype);
                                Dog.prototype.constructor = Dog;
                                
                                Dog.prototype.speak = function() {
                                  console.log(`${this.name} barks.`);
                                };
                                
                                const dog = new Dog('Rover');
                                dog.speak();  // "Rover barks." 출력

            # (중요) JS에서 구현하는 {객체} 간 '상속'을 생성 단계에서 구현하는 방법
               : 각 {일반 객체}의 [[prototype]]을 일일히 setter 방식으로 조작해도 되지만, 원시적인데다가 애초에 {객체} 생성 단계에서 상속을 규정하는게 더 깔끔

                 1) (ES6 이전) Object.create({부모 객체}) 사용
                     : 해당 Object 메서드를 통해, 원하는 {객체}를 {부모 객체}로서 [[prototype]] 속성에 넣어서 {자식 객체}를 단일로 생성 가능
   
                      - 어떤 {일반 객체}와 '상속 관계'를 규정하고 싶은 경우 
                         : 원하는 {일반 객체명}를 Object.create({일반 객체명})에 넣어서 {객체}를 생성하면 됨
                             -> (단점) 이렇게 해버리면? 단일 {객체}에 밖에 영향을 못 미침... 
   
                           ex) {부모}라는 객체를 기반 {자식}을 만들고, {자식}을 바탕으로 {손자}를 만드니..
                                 -> [[prototype]] 체인 로직으로 자식부터 age가 20으로 변환되서 상속

                                    var 부모 = { name : 'Kim', age : 50 };
                                    var 자식 = Object.create(부모);
                                    자식.age  = 20;
                                    
                                    var 손자 = Object.create(자식);
                                    
                                    console.log(손자.age);
                                     -> 20 출력
   
                      - '생성자 함수'를 통해 '상속' 관계를 규정하고 싶은 경우
                          a. {부모 생성자함수명}.call(...parameters);
                              : {자식 생성자함수명}의 프로퍼티를 규정하는 내용부를 규정 = OOP의 super키워드를 통한 {부모}의 프로퍼티 속성 채우기

                          b. {자식 생성자함수명}.prototype = Object.create({부모 생성자함수명}.prototype);
                              : {자식 생성자함수명}가 어떤 {부모 생성자함수명}를 부모로 삼는지를 [[prototype]]에 지정

                          c. {자식 생성자함수명}.prototype.constructor = {자식 생성자함수명}
                              : {자식 생성자함수명}의 생성자함수가 자신임을 제대로 지정함

                          d. {자식 생성자함수명}.prototype.메서드명 = function() { 내용부 }
                              : {부모 생성자함수명}의 동일 메서드를 override 하거나, 메서드를 신설하여 {손자 생성자함수명}에 물려줄 용도로 메서드를 생성
                                  -> (중요) [[prototype]] 체인 로직으로 가까운 순서대로 메서드 속성이 호출되니 잘 적용됨

                          ex) Dog라는 생성자 함수는 Animal이란 생성자를 {부모 생성자함수}로 삼고, speak라는 메서드를 override함
   
                              function Animal(name) {
                                this.name = name;
                              }
                              
                              Animal.prototype.speak = function() {
                                console.log(`${this.name} makes a noise.`);
                              };
                              
                              function Dog(name) {
                                Animal.call(this, name);
                              }
                              
                              Dog.prototype = Object.create(Animal.prototype);
                              Dog.prototype.constructor = Dog;

                              Dog.prototype.speak = function() {
                                console.log(`${this.name} barks.`);
                              };
   
                              const dog = new Dog('Rover');
                              dog.speak();  // "Rover barks." 출력
   
                 2) (ES6 이후) class 문법의 extends, super 사용
                     : 일반적인 OOP언어의 class문법과 유사한 상속 문법을 JS에서도 사용 가능함
                       (= extends, constructor, super 등 OOP의 그 문법 그대로 사용 가능)
                         -> (중요!) 껍데기가 바뀌었다는거지.. 기존 function부터 시작하던 문법과 마찬가지로 [[prototype]]를 사용하여 기능과 근본적인 구현에는 차이가 없음
                             (= prototype 체인을 통한 내부요소 검색법도 고대로 적용된다는 것)
   
                      - class 문법 용어 정리

                         A. class
                             : 어떤 {객체}에 대한 명세서(= 설계도) 같은 개념... 
                                -> {객체}와 [[prototype]] 속성을 통해 상속을 구현한걸 변경하지 않으니, JS에서는 사실상 그냥 class 형식으로 [[prototype]] 속성을 만지기 위해 위해 쓰는 시작점과 다르게 않음 
   
                         B. extends
                             : 어떤 class와 다른 class를 '부모class - 자식class' 관계로 설정하기 위한 키워드..
                                -> 이 녀석도 사실상 [[prototype]] 속성을 다른 방식으로 작성한 것 = 객체명.prototype = Object.create(부모명.prototype)과 다르지 않음
   
                         C. super
                             : 자식 class에서 부모 class에 대한 참조값을 저장하는 키워드... 사실상 [[prototype]] 속성을 다른말로 쓴거
                               (= 참조값이기에 단독으로는 {부모 class}와 그 내부 속성을 불러오는데 쓰거나, 함수 형태의 super()는 {부모 class}의 생성자를 호출함)
                                   -> (중요) super()는 {부모 class}의 생성자이기에, {자식 class}의 '생성자 함수'의 내용부에 꼭 써줘야 자식 class '생성자 함수'가 정상적으로 작동함 
   
                      - class로 구현한 {객체}간 상속 관계 문법
                         : class 자식클래스명 extends 부모클래스명 { constructor(...프로퍼티){ super(); ... ; } 자식의메서드(){} } 이런식으로 작성
   
                           ex) 할아버지 - 아버지 라는 상속관계가 존재
                                -> prototype 체인을 통한 내부요소 검색법도 고대로 적용되기에, 메서드 override도 자연스럽게 성립하여 만수.sayHi()는 자식class의 메서드을 호출항
   
                                   class 할아버지{
                                     constructor(name){
                                       this.성 = 'Kim';
                                       this.이름 = name;
                                     }
                                     sayHi(){
                                       console.log('안녕 나는 할아버지 ' + name + '이다');
                                     }
                                   }
                                   
                                   class 아버지 extends 할아버지{
                                     constructor(name, age){
                                       super(name);
                                       this.나이 = age;
                                     }
                                     sayHi(){
                                       console.log('안녕 나는 아버지 ' + name + '이다');
                                     }
                                     sayHi2(){
                                       console.log('나는 아버지되는 사람이니 할아버지를 소개하며');
                                       super.sayHi();
                                     }
                                   }
                                   
                                   var 만수 = new 아버지('만수', 40);
                                   만수.sayHi2();


       @ (ES6 이후) {객체} 내부의 get, set 키워드를 통한 getter, setter 메서드 기능
           : JS에서 {객체} 내부의 프로퍼티 속성들의 원본값들의 무결성(immutable)을 유지하기 위하여, 데이터들을 데이터를 수정하거나 출력할 때 직접 {객체} 내부의 원본 프로퍼티 속성값에 접근하지 않고, 개별 프로퍼티별 getter와 setter 메서드의 내용부에 적힌 로직을 따라가 값을 받아오거나 및 수정하는 일종의 방법론
              -> 개발자 입장에서 {객체} 내부의 프러퍼티들의 무결성(immutable)을 보장하고  예측 불가능한 수정이나 의도치 않는 자료형 입력 등의 사태로부터 보호하기 위해 인터페이스화 시켜놓은 {객체} 내부의 프로퍼티 출력/수정 기능

             # (중요) {객체} 내부의 프로퍼티 속성값을 직접 변경이 아니라, 메서드를 사용해야 하는 이유 
                 : getter, setter 메서드의 필요성 또한 여기서 시작됨

                   1) 메서드를 통해 간접적으로 {객체} 내부의 프로퍼티 속성값에 접근/수정이 가능
                        -> {객체} 내부의 프로퍼티 속성값을 직접적으로 건들지 않아서, 개발자 개인의 실수를 방지 가능
                             -> (중요) 보통 OOP를 정식으로 지원하는 언어는 여기에 접근제어자를 private로 놓아서, {객체} 내부의 프로퍼티 속성값에 접근하는 것 자체를 컴파일 단계에서 감지할 수 있도록 안전장치를 더 걸어둠

                   2) 1)과 같이 사전에 내용부를 통한 검증된 로직을 작성하는 쪽이 구조가 복잡한 {객체} 내부의 프로퍼티들을 꺼낼때도 유리함 
                   3) 메서드의 내용부를 통해, {객체} 내부의 프로퍼티 속성값을 가공하여, 원하는 자료형으로만 가공되도록 할 수도 있음

                      ex) 매년 {사람}의 나이인 age 프러퍼티 속성값을 +1해주는 메서드 nextAge(), 나이를 변경해주는 setAge(나이)를 만들어 사용
                           -> 이렇게 age 프러퍼티 속성을 직접 건들지 않아도 수정이 간편하고, 나이를 입력시 문자열로 입력해도 parseInt() 함수가 이를 변환해주기에 안전함도 보장함 

                              var 사람 = {
                                name : 'Kim',
                                age : 30,
                                setAge(나이){
                                  this.age = parseInt(나이)
                                },
                                nextAge(){
                                  return this.age + 1
                                }
                              }

                              사람.setAge('200');   // 문자 넣었는데도 숫자 200으로 저장됨
                              사람.nextAge();       // 문자 넣었는데도 숫자 200으로 저장됨

             # (ES6 이후) JS에서의 get, set 메서드 지정 및 사용법
                 : ES6 이전부터 get, set 메서드는 기존 OOP 스타일대로 잘 만들어 쓰고 있었지만, ES6부터 대충 어떤게 get, set인지 지정 및 공인이 가능해지고 해당 메서드의 내용부가 그에 부합하는지 검사해주는 로직이 생김
                    -> (중요) class 문법에서도 예외없이 사용이 가능함

                   1) get 키워드를 통한 메서드
                       
                       a. get 메서드 선언
                           : 원하는 {객체}의 메서드 앞에 'get' 키워드를 작성하면, 메서드 선언 완료
                           
                            - (중요) get 메서드 선언시 꼭 지켜야 할 점 = 안 지킴? 에러를 유발 
                              (= 사실상 ES6의 get, set 키워드의 용도라고 할 수 있음)

                               [1] get 메서드는 선언부에 parameter 변수를 가지고 있으면 안 됨
                               [2] get 메서드는 해당되는 {객체}의 프로퍼티 속성의 현재값을 가져와야 하므로, return을 적어서 이를 내보내줄 수 있어야 함
                                    -> (주의) return 이후 어떤 프로퍼티를 가져올지까지는 컴파일러가 잡아주진 않음

                       b. get 메서드 호출
                           : 원하는 {객체}.get메서드명 방식으로 프로퍼티 호출하듯 호출하면 간편하게 사용 가능
                             (= {객체}.get메서드명(); 이런식으로 안 해도 된다는 건데... 불편하면 굳이 안 써도 됨)

                   2) set 키워드를 통한 메서드
                       
                       a. set 메서드 선언
                           : 원하는 {객체}의 메서드 앞에 'set' 키워드를 작성하면, 메서드 선언 완료
                           
                            - (중요) set 메서드 선언시 꼭 지켜야 할 점 = 안 지킴? 에러를 유발 
                                [1] 선언부에 parameter 변수를 1개 이상 꼭 가지고 있어야함 
                                [2] 파라미터가 2개 이상이면? set 키워드를 쓸 수 없음

                       b. set 메서드 호출
                           : 원하는 {객체}.set메서드명 = 값, 이런 식으로 프로퍼티에 값을 대입하듯 간편하게 사용 가능
                             (= {객체}.get메서드명(값); 이런식으로 안 해도 된다는 건데... 불편하면 굳이 안 써도 됨)

             # (ES6 이후) JS에서의 get, set 메서드 사용 예시

                ex1) {일반 객체}에 사용하는 get, set 키워드를 통한 메서드
                       -> 이렇게 set, get 키워드로 해당 getter, setter 역할의 메서드를 프로퍼티처럼 쓸 수 있음
 
                          var 사람 = {
                            name : 'Kim',
                            age : 30,
                            set setAge(나이){
                              this.age = parseInt(나이)
                            },
                            get nextAge(){
                              return  this.age + 1  
                            }
                          }
                          
                          사람.setAge = 40;            // set 키워드를 추가하면 이렇게 프로퍼티처럼 메서드를 사용가능
                          console.log( 사람.nextAge )  // get 키워드를 추가하면 이렇게 프로퍼티처럼 메서드를 사용가능
                          
                ex2) class 문법에 사용하는 get, set 키워드를 통한 메서드
                       -> 똑같은데, class를 통해 탄생한 {객체}의 해당 getter, setter 역할의 메서드를 프로퍼티처럼 쓸 수 있음
 
                          class 사람 {
                            constructor(){
                              this.name = 'Park';
                              this.age = 20;
                            }
                            get nextAge(){
                              return this.age + 1
                            }
                            set setAge(나이){
                              this.age = 나이;
                            }
                          }
                          
                          var 사람1 = new 사람();
                           
                          사람1.setAge = 40;            // set 키워드를 추가하면 이렇게 프로퍼티처럼 메서드를 사용가능
                          console.log( 사람1.nextAge )  // get 키워드를 추가하면 이렇게 프로퍼티처럼 메서드를 사용가능



  4. 함수(function)
      : 특정 기능에 해당하는 입력(input), 출력(output) 코드 묶음을 쉽게 불러와서 재사용하기 위해 스코프{}를 지정해놓고 모아서 모듈화해놓은 코드
         -> 엄밀하게 JS에서 함수는 {객체}에 해당하며, 심지어 '1급 객체'임

       @ (중요) 1급 시민 객체(First-Class Citizen)
          : JS에서 함수(fuction)는 '1급 객체(first-class object)'이기에 그에 따른 특성과 이점이 존재

             1) JS 언어 내부에서 '값'으로 표현되고 전달될 수 있는 자료형 중 하나로 취급되기에, 변수의 '값'으로서도 받을 수 있음
                  -> 이같은 특성을 기반으로 '다른 함수의 paramter(= 콜백함수)'로 사용하거나 return문에서 반환할 수 있는 '고차 함수(first-class object)'를 JS에서 사용 가능
            
             2) 엄연히 {객체}라는 점에서, 프로퍼티와 메서드를 가질 수 있음
                  -> 함수 {객체}의 프로퍼티에는 '지역변수', {}, 'closer 변수' 등등에 대한 정보가 모두 포함됨
                     (= 함수 {객체}를 변수에 할당하면 '함수 표현식' 형태가 되며, 그 변수는 해당 함수{객체}의 모든 정보를 가지고 있음)


       @ 전통적인 함수(function) 문법 사용법 
         (= 1급 시민 객체(First-Class Citizen) 개념이 없는 함수 선언식과 호출만 사용하는 패턴)
          : 프로시저 프로그래밍 패러다임에 따른 고전적인 함수 사용 방식
            (= JS에 1급 객체 함수적 특성은 1도 반영하지 않았을 경우의 함수 사용 패턴이라고 봐도 무방함)

             1) 함수 선언문(function declaration)
                 : 재사용 하길 원하는 코드들을 모으고 {}안에 묶은 뒤, 이를 어떤 이름으로 호출할 것인지에 대한 '함수명'을 명명하고, 그 앞에 해당 {}는 함수임을 알리는 function이란 예약어를 작성
                    -> 해당 함수(function)를 입력값에 동적으로 내용이 변화하고 출력값을 반환하도록 하고 싶다면, 함수 선언 시 '입력값'에 해당하는 인자(augument) 부분을 매개변수(parameter)가 받을 수 수 있도록 ()안에 parameter 변수를 정의하고, 내용부에서 사용 
                 
                       ex) '함수명'이란 함수 선언 예시
                       
                           function 함수명(... parmeter들){
                           
                             재사용을 하길 원하는 코드..
                             parameter에 해당하는 변수도 사용해도 됨
                           
                             return 영역  <- (생략해도 됨)
                           }
   
                  # 함수 선언(function declaration)과 호출만 존재하는 경우의 단점
                    a. 무조건 '함수명'이 필요함
                    b. 함수를 선언한 코드가 위치에 상관없이 무조건 최상단으로 호이스팅이 일어남
                        -> 작성 의도와는 다른 결과가 나올 수 있음
                        -> 그렇게 호이스팅 된 함수는 무조건 먼저 읽기 때문에, 함수 종류가 많아지면 성능에 문제 생김

                  # (중요) (ES6 이후) 함수 정의 시 사용 가능한 기능 정리
       
                    A. 기본 매개변수(default parameter)
                        : 함수를 선언할 떄 parameter의 기본값을 지정 가능
                          (= 함수를 호출 시, parameter 위치에 argument를 넣지 않으면, 그 기본값이 자동으로 해당 parameter 변수에 argument로 대입)
                              -> (참고) 기본 매개변수(default parameter)의 값으로는 '원시값' 말고, [배열], {객체] 같은 '참조형'도 들어갈 수 있고, 심지어 함수를 넣어도 논리만 맞으면 그만임

                                  ex) 기본적인 기본 매개변수(default parameter) 사용방식 

                                      function 더하기 (a, b = 10){
                                        console.log(a + b)
                                      }
                                      
                                      더하기(3);         <- 13 출력

                                  ex) 다른 parameter와 연산자를 통해 기본 매개변수(default parameter)의 기본값을 지정해도 전혀 문제 없음

                                      function 더하기 (a, b = 2 * a){
                                        console.log(a + b)
                                      }
                                      
                                      더하기(3);        <- 9 출력

                                  ex) 함수를 호출해서 채워도 기본 매개변수(default parameter)의 함수는 문제없이 작동함

                                      function 임시함수(){
                                        return 10 
                                      }
                                      
                                      function 더하기 (a, b = 임시함수() ){
                                        console.log(a + b)
                                      }
                                      
                                      더하기(3);        <- 13 출력

                    B. [인자](arguments array)
                        : 함수 선언시 내용부에 해당하는 함수의 {}안에 arguments라는 키워드(미리 함수라는 {객체}에 정의된 프로퍼티에 해당)에 해당 함수의 모든 parameter변수가 전부 [배열]의 요소로 들어가 있음
                            -> [arguments]를 통해, parameter변수에 들어간 각 argument들을 배열의 요소처럼 index로 접근이 가능함... 
                               (= 불특정한 개수의 나머지 매개변수(rest parameter)가 상정된 함수와 시너지가 유익함)

                               ex) arguments[index]값으로 a,b,c라는 parameter변수를 언급하지 않아도 접근에 문제없음

                                   function 함수(a,b,c){
                                     console.log(arguments[0])
                                     console.log(arguments[1])
                                     console.log(arguments[2])
                                   }
                                  
                                  함수(2,3,4);

                               ex) 나머지 매개변수(rest parameter)와 병행해서 사용도 가능은 함... 사실 굳이 이렇게 안해도 그냥 [나머지 매개변수명]도 똑같이 [배열] 형식이니 굳이 이렇게 안 써도 됨
                                     -> (중요!) [arguments]가 함수의 전체 parameter변수들의 [배열]이면, [나머지 매개변수(rest parameter)]는 따로 정의된 parmeter변수들을 제외한 parameter변수들의 [배열]에 해당함

                                   function 함수2(a, b, ...파라미터들){
                                     for (var i = 0; i < arguments.length; i++){
                                       console.log(arguments[i]);                <- [3,4,5,6,7,11,22,33,44] 출력
                                     }
                                   }

                                   var 스프레드연산자 = [11, 22, 33, 44]; 
                                   
                                   함수2(1,2,3,4,5,6,7, ...스프레드연산자);  <- 스프레드연산자 '...'를 사용하여 나머지 매개변수를 사용한 함수호출에 유용하게 사용
       
                    C. 나머지 매개변수(rest parameter)
                        : 함수 선언시 parameter를 입력하는 () 영역의 '가장 뒷쪽'에 '...parameter명' 형식으로 '...' 연산자를 붙여서 작성가능
                           -> (중요) 그렇게 하면.. 
                                - 함수 호출시 앞선에 미리 정의된 parameter들 이외의 다른 불특정한 갯수의 parameter들이 더 들어온다고 가정하고 함수의 내용부를 {} 작성이 가능함
                                - 앞선에 미리 정의된 parameter들 순서 이후에 들어올 모든 parameter들에 해당하는 변수들을 parameter명이란 변수를 통해 [배열] 형식으로 통제가 가능함
                                  (= 미리 정의된 parameter들 순서 이후에 들어오는 모든 나머지 parameter들 자리의 argument들을 [] 중괄호로 감싸줘 [배열]화 시킨 변수가 rest parameter)

                                  ex) 미리 정의된 a, b라는 parameter의 순서 자리를 제외한, 3번째 이후의 모든 argument에 해당하는 값은 [파라미터들]이라는 나머지 파라미터(rest parameter) 변수가 저장하여 함수의 내용부 {}에서 통제함

                                      function 함수2(a, b, ...파라미터들){
                                        console.log(파라미터들)               <- [3,4,5,6,7] 출력
                                      }
                                      
                                      함수2(1,2,3,4,5,6,7);

                                  ex) (참고) 나머지 파라미터(rest parameter)를 사용하여 선언한 함수를 호출할 떄 ()안에 인자(argument) 입력시 '스프레드 연산자'인 '...'의 연계가 아주 좋음

                                      function 함수2(a, b, ...파라미터들){
                                        console.log(파라미터들)                <- [3,4,5,6,7,11,22,33,44] 출력
                                      }

                                      var 스프레드연산자 = [11, 22, 33, 44]; 
                                      
                                      함수2(1,2,3,4,5,6,7, ...스프레드연산자);  <- 스프레드연산자 '...'를 사용하여 나머지 매개변수를 사용한 함수호출에 유용하게 사용

                                  ex) (주의1) 함수는 선언시 나머지 파라미터(rest parameter)를 가장 나중에 사용해야 에러가 안 남
                                        ->  나머지 파라미터(rest parameter)는 불특정 다수의 parameter를 포괄하는 [배열]에 해당하기에.. 이걸 앞쪽에 써버리면, 미리 선언한 parameter가 호출시 몇 번째에 해당하는 녀석인지 알 방법이 없음

                                            function 함수2(a, ...파라미터들, b){          <- 이렇게 쓰지 말라는거...
                                              console.log(파라미터들)
                                            }

                                  ex) (주의2) 나머지 파라미터(rest parameter)는 가장 끝에 1개만 사용해야 에러가 안 남

                                       function 함수2(a, ...파라미터들, ...파라미터들2){   <- 이렇게 쓰지 말라는거...
                                         console.log(파라미터들)
                                       }

             2) 함수(function) 호출
                 : 선언했던 함수의 '함수명'의 선언부에 해당하는 형식대로 '함수명(...argument들)'을 작성하면, 런타임 상황에서 해당 함수명의 내용부를 실행
                   (= 사용을 원하는 위치에 '함수명(...argument들)'을 작성하면 간단하게 원하는 코드를 재사용이 가능함)
                 
                   ex) '함수명'이란 함수 or 표현식 호출하기 + 결과값을 변수에 할당
                   
                        const result = 함수명(... argument들);
   
                  # (중요) 함수 선언(function declaration)과 호출만 존재하는 경우의 단점 (= 함수 표현식(fuction expression)의 이점)
                     : 함수가 호출(function call)되는 타이밍이 단순하면 상관없지만, 다른 함수들과 연계되어 타 함수들을 로직의 일부로서 사용하려고 들 때 상황에 맞게 동적으로 쓰기 힘들어짐
                       (= 함수 자체를 값으로 취급해서, 변수에 저장하거나 parameter의 argument로 사용하거나 return 할 수 있다면? 좀 더 유연하고 다양한 코딩 패턴의 가능성을 열어줄 수 있음)
                           -> 함수 표현식(function expression)의 사용 이유

                               ex) 함수를 동적으로 순차적 호출이 가능, 콜백함수를 동적으로 구성이 가능, 클로저 패턴을 사용 가능


       @ (중요) 함수 표현식(function expression) 
          : JS에서 함수(function)가 변수에 할당 가능한 값을 가진 {객체} 자료형에 해당하는 '1급 객체'라는 특성을 이용, 함수(function)을 변수에 할당하여 표현하는 광범위한 방식을 통칭
            (= 변수에 할당되는 함수는 기존에 선언된 함수일 수도 있고, 실행 타이밍이 되서야 알게되는 무명함수일 수도 있음!)

            a. 기존 선언된 함수를 변수에 할당하는 방식의 함수 표현식(function expression) 
               
               ex) 상단의 '함수명'이란 함수가 선언되고, 이를 변수명이 표현식으로 할당한 경우, 변수명(...parameters);는 그 함수를 호출하는 구문이 됨
               
                   var 변수명 = 함수명;

                   변수명(...argument);
            
            b. 무명함수를 변수에 할당하는 방식의 함수 표현식(function expression) 
                : 재사용 하길 원하는 코드들을 모으고 {}안에 묶고 그 앞에 해당 {}는 함수임을 알리는 function이란 예약어를 작성하는 것까지는 같지만, '함수명'을 명명하지 않는 무명함수 방식으로 변수에 할당하여 작성     
                   -> 마찬가지로 parameter를 넣을 수 있도록 ()안에 parameter 변수를 정의하고, 내용부에서 사용하면 해당 함수를 상황에 따라 유연하게 적용 가능            
            
                      ex) greet라는 변수에 무명함수가 할당된 '함수 표현식' 형식 예시
           
                          const 함수명 = function(... parmeter들){
           
                            재사용을 하길 원하는 코드..
                            parameter에 해당하는 변수도 사용해도 됨
                          
                            return 영역  <- (생략해도 됨)
                          };

            # 함수 표현식(function expression)을 사용하는 이유 및 이점?
               : 단순히 선언된 함수만 변수에 대입하는 것으로는 별 쓸모 없지만... 
                  -> {객체} 값으로서 활용가능한 '1급 객체'로서, '고차함수'로서 사용이 가능한 JS 함수의 특성에 따른 유연성 및 확장성에 대한 포텐셜을 극강으로 끌어올릴 수가 있음
                      (= 그 자체로도 '1급 객체'로서의 함수의 특성이 있기에 존속이 가능하나, = 함수를 argument값이나 return값으로 사용하는 '고차함수' 개념까지 연계되면 활용도와 유연성이 정말 높아짐)
    
                      ex) 함수를 동적으로 순차적 호출이 가능, 콜백함수를 동적으로 구성이 가능, 클로저 패턴을 사용 가능


       @ 함수 선언(function declare) VS  함수 표현식(function expression)
          : 함수 표현식(function expression) 개념은 함수 선언(function declare)과 양립 불가능하지 않음!
            (= 오히려 '1급 객체'로서 함수의 특성을 극한으로 이용하여, 선언된 함수를 더 유연하게 쓰이게 하거나, 더 고차원적인 패턴으로 활용할 수 있음을 의미함)
          
             1. 호이스팅(Hoisting) 여부
                 : 함수의 선언 및 작성 위치와 상관없이, 프로그램이 코드 실행전 무조건 코드의 가장 최상위로 올려두는지 여부
                   (= 대충 var와 let의 관계와 유사)
                    -> 원본 코드의 실행 순서대로의 전개가 전혀 달라질 수 있는 사안이 될 수 있음
   
                  a. 함수 선언 (Function Declaration)
                      : 코드 실행 전에 최상단에 호이스팅 됨
                        (= 무조건 함수 호출부에서 함수를 발견하지 못하는 문제가 생기지 않도록 만듦)
   
                  b. 함수 표현식 (Function expression)
                      : 호이스팅과 전혀 관계가 X
                        (= 어떤 변수에 함수를 할당하는 함수 표현식의 형태의 경우 코드가 실행되는 시점에 함수가 정의되기에, 함수의 호출은 함수의 변수 할당 이후에만 호출이 가능)
   
                    # (중요) 만약 'var 변수'로 '함수 표현식'에 해당하는 할당을 받는다면?
                        : var변수의 호이스팅 원칙이 먼저 적용되어서, var 변수명; 상태로 호이스팅 되고, 함수가 할당되기 전까지는 undefine 값으로 출력되게 됨
   
                          ex) var변수의 호이스팅 결과로 var sayHello = ''; 코드가 최상단에 위치하는 효과를 낳게 됨
   
                              console.log(sayHello);  // Output: undefined
                              sayHello();             // TypeError: sayHello is not a function
                              
                              var sayHello = function() {
                                  console.log("Hello!");
                              };
                              
                              sayHello();             // Output: "Hello!"
   
             2. 무명 함수(anomyous function) 사용 가능 여부
   
                  a. 함수 선언 (Function Declaration)
                      : '함수명'은 무조건 설정되어야 함
                         (= 같은 {} 단계에서는 무명함수와 양립이 불가능)
   
                  b. 함수 표현식 (Function expression)
                      : '기존 선언 함수' 말고도 '무명 함수' 또한 변수에 할당이 가능함
                        (= 변수를 통해 단순히 선언된 함수를 받아주는 수준이 아니라, 그 변수 자체가 할당된 무명함수를 통해 선언된 함수처럼 기능하면서 더 유연한 사용이 가능)


       @ (중요) 함수 호출(function call) VS {객체}값으로서의 함수
           : 작성에 있어.. 아주 약간의 차이가 있지만 그 의미는 어마무시하게 차이가 남
             (= 별 차이 없어 보이기에 작성하는 입장에서도 햇갈리고, 경우에 따라서는 코드를 읽는 입장에서도 해석을 잘못할 위험이 존재함)

             1) 함수 호출(function call)
                 : 어떤 함수를 정의된대로 argument를 넣고 실행하라는 명령어.. 반드시 '함수명(...argument)'와 같이 ()가 들어가며, 결과값은 호출된 함수의 {}의 return값을 가져옴
                    -> (중요) {}내에 window객체에 선언된 전역 변수를 변경하는 내용이 있다면, 이는 함수의 스택 프레임(stack frame)이 끝나도 반영되어 있음

                       ex) const result = 함수명(... argument들);
                            -> result는 함수명(... argument들)을 실행한 return값을 가짐
                                -> (중요) JS에서는 함수의 return값은 또 다른 함수도 가능하니.. '함수 호출 != return 함수' 라고 생각하면 안됨!
           
             2) '{객체}값'으로서의 함수 (!= 함수 포인터)
                  : 말 그대로 어떤 변수에 대입가능하고, 함수의 return값으로 반환도 가능한 선언된 스코프와 클로저와 같은 모든 맥락(context)를 가지고 있는 값으로서의 함수... '함수명'과 같이 ()를 쓰지 않고 사용함
                     -> (주의) '함수 포인터'와 유사한 개념이나 메모리 주소만을 저장하는 함수 포인터와는 다르게, {객체}값으로서의 함수는 맥락(context)에 해당하는 정보를 프로퍼티로 가지고 메서드 또한 가질 수 있음

                  # '{객체}값'으로서의 함수를 사용하는 경우의 이점?
                      a. 함수(function)을 변수에 할당하여 표현하는 '함수 표현식(function expression)'에 사용시 이점
                          : 단순히 선언된 함수만 변수에 대입하는 것으로는 별 쓸모 없음
                              -> if 대입되는 함수가 무명함수라던지... 
                              -> if 대입되는 함수의 return값이 또 다른 함수인 '고차 함수'라던지 하는 경우가 있다면?
                                  -> 변수에 대입되는 함수를 동적으로 변환이 가능하기에, 같은 변수명으로도 동적으로 함수를 호출하는 것이 가능
                                     (= 함수를 argument값이나 return값으로 사용하는 경우와 시너지를 이룸)

                                     ex) const itself = 함수명;
                                          -> itself는 '함수명'이란 선언된 맥락(context)에 대한 모든 정보와 프로퍼티 메서드를 가지는 함수 {객체}를 저장

                                     ex) 무명함수를 변수에 대입하면, 사실상 함수 선언을 대체 가능
                                     
                                         const itself =  function(x) {
                                           return x*x
                                         }

                      b. 다른 함수 호출시 parameter자리에 argument값으로 함수를 넣어 '고차 함수'인 '콜백함수(callback fucntion)'으로 사용시 이점
                          : 호출한 함수의 {}에서 argument값으로 보낸 함수를 parameter 변수에 넣어 동적으로 호출할 수 있도록 해줌
                             -> 함수{} 안에서 호출을 하던, 다른 함수를 호출시 parameter자리에 argument값으로 또 보내던, return값으로 보내던 다양하게 응용이 가능하게 함

                            ex) executeFunction의 parameter는 함수에 해당하고, 그 함수를 콜백함수로서 사용... 
                                 -> executeFunction(createFunction)의 경우 parameter에 해당하는 createFunction값 자체는 함수{} 안으로 해당 함수를 사용할 수 있게 함수 {객체}를 전달하며, 함수{} 안에서 createFunction()의 형태로 호출시킴 
                            
                                    function createFunction() {
                                       return function() {
                                           console.log("Hello, World!");
                                       };
                                    }
            
                                    function executeFunction(func) {
                                      func();
                                    }
            
                                    executeFunction(createFunction);

                      c. return값에 '고차 함수'로서 사용
                          : 함수의 결과로 어떤 함수를 반환하며, 이를 변수에 할당하면 함수 표현식(function expression)이 됨
                             -> 어떤 함수의 return값이 함수이고, 그 함수의 내용부가 해당 함수 {객체}가 저장하는 맥락(context)에서 자신을 호출한 함수{}의 프로퍼티와 연관이 되어 있다면?
                                 -> return된 함수를 받아주는 변수를 통해 함수 표현식이 완성되고, 그 표현식을 통해 함수가 호출되어 프로퍼티가 변동한다면, 상위 함수 호출이 끝나도 그 내부 프로퍼티는 계속 메모리에 할당된 일종의 {객체}의 캡슐화된 프로퍼티로서 메모리에 남아있게 하는 패턴을 사용 가능함
                                    (= 클로저(closer) 패턴)


                  # 클로저(closer) 패턴
                     : {객체}개념은 존재해도 이를 통제하는데 있어 캡슐화나 접근 제어자 개념이 없던 JS의 문제점을 극복하기 위하여.. 함수의 '1급 객체'로서의 특성을 활용하여 이를 구현함
                        -> 함수{} 내부의 변수를 프로퍼티로 return되는 함수를 메서드로서 활용할 수 있도록 설계하여, 캡슐화된 {객체}의 프로퍼티와 일종의 setter기능을 유사하게 구현한 패턴 
                           (= 본격 접근제어자가 ES6 이후 등장하기 전까지, 개발자들은 접근제어자 개념이 JS에서 필요할 시 이를 사용함)
                     

                           ex) 클로저(closer) 패턴 예시
                                -> createCounter라는 변수는 무명함수를 할당받는 표현식에 해당하는 함수를 할당받으면, return값은 그 내부 프러퍼티 count의 값을 증가시키는 함수 {객체}를 반환함
                                   (= createCounter 변수는 해당 무명함수의 {객체}가 가진 {}나 프로퍼티 정보를 모두 저장하게 됨)

                                -> 그 createCounter라는 함수 표현식을 호출하여 그 반환되는 함수를 counter라는 변수가 받으면, createCounter에 할당된 무명함수의 프로퍼티 count는 호출이 끝나도 계속 남아있음
                                   (= counter라는 변수는 createCounter에 할당된 해당 무명함수가 return한 다른 무명함수의 {객체}가 가진 {}나 프로퍼티 정보를 모두 저장하게 되기 떄문)

                                -> createCounter라는 함수 표현식이 호출될 때마다 count의 값은 1씩 증가함
                                   (= 애초에 createCounter, counter라는 변수들에 각자 할당된 함수 {객체}의 정보들을 기억하고 있어서 가능한 일)
                           
                                   const createCounter = function() {
                                       let count = 0;
                                   
                                       return function() {
                                           count++;
                                           return count;
                                       };
                                   };
                                   
                                   const counter = createCounter();
                                   
                                   // counter()는 createCounter에 할당된 무명함수의 return되는 무명함수를 호출하여 실행함 
                                   console.log(counter());  // Output: 1
                                   console.log(counter());  // Output: 2
                                   console.log(counter());  // Output: 3


       @ (중요) parameter(매개변수)와 argument(인자) 개념의 차이
          : 둘 다 함수의 내용부에 전달되는 '입력 데이터'와 연관된 해당되는 개념들이지만, 함수를 '정의' 혹은 '호출' 하는지 여부에 따라 개념이 나뉨

           # parameter와 argument 공통점/차이점 
              1) 공통점
                  : 함수의 내용부에 전달되는 '인자'에 해당되는 개념 

              2) 차이점
                  a. parameter
                      : 함수를 '선언(declare)'할 때 내용부에 입력받을 값을 '전달하는 역할의 변수'에 해당
                         -> (참고) ES6 이후 함수 선언시 ()안의 parameter 변수에 호출시 값이 들어오지 않으면, 자동으로 값을 넣어주는 'default parameter' 개념이 존재

                  b. argument
                      : 함수를 '호출(call)'할 때 parameter자리에 입력되어, 함수의 내용부에 parameter 변수를 통해 전달될 '값' 그 자체를 의미
                         -> (참고) 그래서 ES6 이후 함수 선언시 {}안의 내용부에 'arguments'라는 함수 {객체}의 프로퍼티를 통해 parameter에 전달된 값들을 [배열] 형식으로 볼수 있음

                            ex) greet란 함수 정의시 ()의 name이라는 parameter 변수가 존재하고, greet를 호출시 Alice와 Bob이 name이라는 parameter 변수에 전달되는 argument
    
                                function greet(name) {
                                    console.log("Hello, " + name);
                                }
    
                                greet("Alice"); 
                                greet("Bob");   

           # parameter를 통해 argument가 함수에 전달되는 과점
              : 함수를 호출 시, parameter 변수에 argument가 할당되고, 그렇게 값을 할당받은 parameter는 이를 함수의 내용부에 전달하는 구조라고 보면 됨

                ex) 다음의 showDetails(x, y)라는 함수가 showDetails(10, 20)로 호출되면, 내용부에 'parameter = argument값' 이런식으로 정의되고 사용된다 생각하면 편함

                    function showDetails(x = 10, y = 20) {

                        let x = 10;
                        let y = 20;

                        console.log("x before assignment: ", x); // 10
                        console.log("y before assignment: ", y); // 20
                    }                


       @ (중요) 콜백 함수(callback function)
          : 어떤 함수의 parameter자리에 '1급 객체'인 {함수 객체}가 '고차 함수'로서 argument로서 할당되는 함수로, 함수의 내용부에서 특정 작업이 완료된 후 호출되는 용도
            (= 어떤 함수가 호출 시 내용부에서 정적(static)으로 정해진 특정 함수가 아니라 parameter의 argument로서 동적(dynamic)하게 입력된 함수를 모듈로서 포용이 가능함)
                -> why 사용할 함수들을 단순히 나열하여 호출 않고, 콜백함수를 쓰는가? 
                    : 비동기 코드가 껴버리면, 나열한 순서대로 실행을 보장할 수 없기 때문...

           # 콜백 함수(callback function)를 사용하는 JS의 주요 기능
              : 해당 기능들에 해당하는 함수는 선언할 때 parameter 중 콜백함수(callback function)으로 함수가 들어갈 것이 상정됨

               1) DOM API 중 이벤트리스너

                  ex) document.getElementById('myButton').addEventListener('click', function() {
                          alert('버튼이 클릭되었습니다!');
                      });

               2) 비동기 작업 처리 함수

                  ex) promise, async/await, setTimeout 등이 여기 포함
                  
                      setTimeout(() => {
                          console.log('1초 후에 실행됩니다.');
                      }, 1000);

               3) [배열] 메서드

                  ex) let numbers = [1, 2, 3, 4, 5];
                      
                      numbers.forEach(function(number) {
                          console.log(number * 2);
                      });

           # 콜백 함수(callback function)의 장/단점
              : (결론) 이 녀석의 장점은 살리고, 단점은 최소화하기 위해 고안된 결과물이.. ES6의 'Promise'를 이용한 디자인 패턴인 'then, catch, finally', ES8의 'async/await'
           
              (장점)
                1) 비동기 처리(async)
                    : 비동기 작업의 실행 순서를 효과적으로 통제하고, 처리할 수 있음
                      (= 일반적인 순서대로 함수호출을 나열할 시, 거기에 비동기 코드가 끼어있으면 의도가 계산이 힘듦)
                    
                      ex) AJAX 요청이 완료된 것이 감지되면, 데이터를 어떤 함수를 통해 처리하라는 식의 코드를 작성할 수 있음
           
                2) 코드 구조화
                    : 해당 코드가 더 구조화되고 모듈화되어 유연해짐 재사용성이 증가
                    
                      ex) 특정 작업을 별도의 함수로 정의 후, 필요한 곳에서 재사용 가능
           
                3) 유연성
                    : 상황에 따라 함수 호출시 다른 콜백 함수를 전달하면, 함수의 동작을 유연하게 조정가능
                      (= 2)의 코드 구조화의 부산물이라고 보면 됨) 
           
              (단점)   
                1) 콜백 지옥(callback hell)
                    : 중첩(nested)된 콜백 함수가 많아져서, 함수{}들이 2중 3중으로 중첩되어 있으면 코드가 복잡해지고 가독성이 떨어질 수 있음
                       -> 이를 개선하기 위한 시작점으로 ES6의 {promise 객체} 개념을 도입한 디자인 패턴인 'then, catch, finally', ES8의 'async/await'

                          ex) 전형적인 콜백지옥으로, 엄청나게 많은 함수{}가 중첩되어 있음
                                -> 코드가 실행은 되지만, 이거 인간의 시선에서 함수가 어떻게 작동하는지와 디버깅이 참 답도 없음
                          
                                   첫째함수(function(){
                                     둘째함수(function(){
                                       셋째함수(function(){
                                         어쩌구..
                                       });
                                     });
                                   }):
           
                2) 비동기 작업 에러 처리
                    : 비동기 작업에서 발생하는 에러를 처리하기 어려울 수 있음


       @ 무명 함수(anomyous function)
          : 주로 '특정 상황'에서 '일회성'으로 사용되거나 즉시 실행되기 위해 정의되기에 함수명도 주기 귀찮아서 '함수명'이 형태로 사용이 가능한 함수
            (= 요컨데 재사용율이나 용도가 특정 용도나 함수와의 연계에 몰려있어, '함수명'을 써가면서 사전에 로딩할 필요도 없는 경우 사용하는 이름없는 함수)
                -> (중요) SO.. 특정 변수에 할당되는 '함수 표현식(expression)'과 다른 함수의 parameter자리에 argument로 전달되거나 return값으로 반환되는 '고차함수'로서 별 다른 절차 없이 간편하게 사용 가능

           # 무명 함수(anomyous function)가 주로 쓰이는 방식?
              : 함수 표현식(expression)에서 변수에 할당되거나, 타 함수를 호출시 parameter위치에 '콜백함수(callback function)' 역할의 argument로 할당되는 사용할 때 신속 간편하게 쓰임
                 -> 암튼, 선언하지 않고 사용이 가능하다는 이점에 집중

           # 즉시 실행 표현식 (IIFE)
              : {window 객체}에 해당하는 전역 {} 범위를 오염시키지 않는 무명 함수를 선언하자마자 즉시 실행되는 함수를 만드는 방법
                  -> 원래 단독으로 무명함수를 선언하는 경우에는 그것을 받아줘서 함수 표현식 형태로 유지해주는 변수가 있어야 호출이 가능하나... 
                      -> BUT! IIFE가 있으면 그냥 무명함수를 실행할 수도 있다는 말씀
                  
                         ex) IIFE 형식은 다음과 같은 형식으로 선언과 동시에 호출이 되는 구조
                           
                             ( function(){ 내용 } )(); 

                         ex) 직접적인 IIFE 예시
                         
                            (function() {
                                console.log("This IIFE executes immediately and encapsulates the code.");
                            })();
    

       @ arrow function(화살 함수)
          : ES6에서부터 함수를 보다 단순하게 표현하는 방법론에 해당하는 '람다 대수' 개념을 받아들여, '람다 표현식'에 해당하는 화살표(=>)를 이용해서 무명함수를 더 단순하게 작성할 수 있도록 개선한 문법
             -> (중요) arrow function(화살 함수) = '람다 표현식' = 무명함수를 작성하는 새로운 방식이나 다름없음 
                       (= 변수에 함수를 대입하는 '함수 표현식'과 아주 밀접한 관계를 이룸)
    
                # 기존 무명함수 선언식 -> arrow function(화살 함수) 작성법
                   1) function 예약어 대신 화살표(=>)를 함수의 몸체로 사용
                   2) 함수의 내용부가 1줄이면(= 단일 실행문) 괄호{}를 생략 가능
                       -> (주의) return문으로만 내용이 구성되어 있는 경우 {}는 생략 불가
                   
                           ex) function(...parameter){ 내용 }   ->   (...parameter) => { 내용 }

                # 즉시 실행 표현식 (IIFE)과 arrow function(화살 함수)
                   : arrow function(화살 함수)도 무명 함수이기도 하다보니, 거기에 ()로 감싸서 호출하면 그냥 무명함수 그 자체임

                     ex) arrow function(화살 함수)를 콜백함수로서 arrow function(화살 함수) 형식의 즉시 실행 표현식 (IIFE)의 parameter로 전달한 case 

                         (() => {
                              let message = "This is an IIFE using an arrow function";
                              console.log(message);
                         })();

                # arrow function(화살 함수) vs 무명 함수
                   1) function 대신 '->'를 사용한 간결하고 짧은 문법
                   2) (중요) this를 arrow function(화살 함수)의 내용부에 썼을 경우, 자신의 직속 상위 {}에 해당하는 {객체}를 의미하게 됨
                        -> arrow function(화살 함수)과 function을 쓰던 함수나 무명함수의 this는 의미가 달라짐


       @ (중요!) 모든 종류의 function에서의 this의 의미 정리
           : 기본적으로 this의 의미는 OOP에서 현재 {} 영역의 주제가 되는 {객체}를 의미
             (= 함수에서의 this 또한 해당 함수가 속한 {}영역의 주인이 되는 {객체}를 참조한다고 보면 쉬움)

             1) (중요) 어떤 {객체}의 메서드로서의 함수의 this
                 : 해당 메서드를 소유한 {객체}를 참조
                   (= 이 녀석의 function에서의 this의 중심이 된다고 봐도 무방)                               

             2) 독립된 전역 함수의 this
                 : JS에서 전역이라는 자체가 {window 객체} & {global} 객체를 참조함
                   (= 전역 함수라는거 자체가 {window 객체} & {global} 객체에 속한 메서드라고 봐도 무방함)
                       -> BUT! 엄격 모드(strict mode)에서는 undefined

                   ex) 전역함수의 this는 전역 객체(window)를 참조
                   
                       function sayHello() {
                           console.log(this);
                       }
                       
                       sayHello(); 
                        -> window 객체가 출력됨

             3) new 키워드를 사용한 어떤 class {객체}의 생성자(constructor)로서의 함수의 this
                 : 생성자가 생성한 {instance 객체}를 참조

                   ex) new Person('Bob')의 this = 오브젝트 변수에 할당된 자신이 생성한 {객체 그 자신}
                   
                       function Person(name) {
                           this.name = name;
                       }
                       
                       const 오브젝트  = new Person('Bob');
                       console.log(오브젝트 .name);
                         -> 'Bob'
   
             4) apply, call, bind 메서드
                 : parameter위치에 argument로 원하는 {객체}를 this로 설정 가능

                   ex) introduce라는 함수의 this를 obj라는 변수에 할당된 {객체}로 임의설정

                       function introduce() {
                           console.log(this.name);
                       }
                       
                       const obj = { name: 'Charlie' };
                       introduce.call(obj); 
                         -> Charlie

             5) function 무명함수의 this
                 : 무명함수가 선언된 위치에 따라 case by case로 달라짐
                   (= 호출 방식에 따라 this가 동적으로 결정될 수 있음)

             6) arrow function(화살 함수)의 this
                 : arrow function(화살 함수) 자신이 선언된 위치의 직속 상위 {}에 해당하는 {객체}를 정적으로 참조허고 절대 변경X
                   (= arrow function(화살 함수) 자신이 정의된 스코프에서의 this를 사용)


       @ 함수(function) 사용시 특이사항
          1) 함수명을 영어로 작명한다면? camelCase로 작명하는게 관습 
             (= kebab-case로 작성해도 기능에는 문제가 없음)

          2) return문에 도달하면, 해당 함수는 그 위치에서 종료되고 메모리 stack들도 차례차례 해제됨
             (= return문 뒤에 존재하는 코드들은 실행대상에서 배제됨)

          3) 함수 선언시 내용부를 마무리 시 return 문은 생략해도 상관은 없고, 함수{}의 끝을 향해 달림
              -> 물론 생략한다고 해도, 프로그램은 내부적으로 return 0;과 같은 형태의 return문을 임의로 작성함

          4) JS에서 함수(fuction)는 '1급 객체(first-class object)'로서 또한 언어 내부에서 '값'으로 표현되고 전달될 수 있는 자료형 중 하나로 취급
              -> 함수(fuction)의 parameter에는 어떤 함수 그 자체가 parameter로 들어가거나 return 값이 되기도 하는 '고차 함수(first-class object)'로서 사용이 가능
                 (= parameter로 함수가 들어가 콜백함수나 return 값으로 사용될 수 있다는 건, 함수가 변수에 대입될 수 있다는 것)

          5) (중요) '함수명()'과 '함수명'은 명확히 다른 의미를 지님
               -> '함수명()'
                    : function인 함수명()을 호출하여, 그 내용부를 parameter 자리에 들어온 값을 대입해 실행하라는 의미
                      (= 함수를 호출해서 실행하도록 하고 싶으면, '함수명()'와 같이 반드시 ()까지 같이 입력해 줌)

               -> '함수명'  
                    : function인 함수명()의 해당 함수 그 자체를 {객체}값으로 사용하는 방식 
                      (해당 함수가 어떤 함수의 콜백함수로서 parameter나 return값으로 쓰이는 '고차함수'나 변수에 할당하는 '함수 표현식'에 사용)

          6) (중요) this라는 키워드를 통해, 함수가 속한 {}를 관장하는 {객체}를 끌어다 쓸 수 있음
          7) (중요) {}내에 window객체에 선언된 전역 변수를 변경하는 내용이 있다면, 이는 함수의 스택 프레임(stack frame)이 끝나도 반영되어 있음
               -> 그래서, 전역변수 어지간하면 쓰지 말라는거


       @ apply, call, bind 메서드
          : 어떤 함수를 실행시, this로 설정할 {객체}를 다르게 설정(binding)하고, 함수 실행 방식에 영향을 주기 위해 사용하는 {함수 객체} 내부에 존재하는 메서드
              -> 3개의 메서드는 비슷하지만, 세부 기능이 조금씩 다름

                # apply, call, bind 메서드 설명

                   1) call 메서드
                       : 어떤 함수를 실행시, this로 설정할 {객체}를 다르게 설정(binding)하기 위해 사용하는 메서드
  
                        - call 메서드 문법
                           : 호출함수명.call({대입 객체명}, augument1 , ... , augumentN);
                              -> 1번쨰 parameter변수가 해당 호출함수명의 내용부의 this를 받을 {객체}에 해당되며, 그 나머지 parameter변수들은 해당 함수의 parameter 변수들의 역할을 순차적으로 맡음
  
                                 ex) greet.call(person, 'Hello', '!')의 의미
                                      : greet 함수의 this의 주체를 {person 객체}로 하고, parameter변수에는 인수(augument)로 'Hello'와 '!'가 전달하여 호출하라는 것
       
                                        function greet(greeting, punctuation) {
                                            console.log(greeting + ', ' + this.name + punctuation);
                                        }
                                        
                                        const person = { name: 'Alice' };
                                        
                                        greet.call(person, 'Hello', '!');
  
                        - call 메서드 주의점(= 단점)
                           : 나머지 매개변수(rest parameter)들은 이후 쉼표로 하나하나 구분해 직접 전달해야만 함!
                             (= 나머지 매개변수(rest parameter)들을 [배열]로 넣는건 불가능 함)
                                 -> apply 메서드의 등장 이유
  
                   2) apply 메서드
                       : call과 마찬가지로 사용되나, parameter변수에 대입하여 쓸 인수(augument)들을 [배열]로 넘긴다는 점에서 압도적인 편의성이 존재
                          -> 호출할 함수에 전달할 인수(augument)가 많거나 동적으로 설정될 때 사용하면 좋다는 점에서, 스프레드 연산자 '...'의 그것과 용도가 유사
                             (= ES6 이전 '스프레드 연산자'의 등장 이전에는 '참조자료형'의 '깊은 복사'에 이 녀석들이 간간히 활용됨)
  
                        - call 메서드 문법
                           : 호출함수명.call({대입 객체명}, augument1 , ... , augumentN);
                              -> 1번쨰 parameter변수가 해당 호출함수명의 내용부의 this를 받을 {객체}에 해당되며, 그 나머지 parameter변수들은 해당 함수의 parameter 변수들의 역할을 순차적으로 맡음
  
                                 ex) greet.apply(person, args)의 의미
                                      : greet 함수의 this의 주체를 {person 객체}로 하고, parameter변수에는 인수(augument)로 [args]가 가진 내부 요소들을 전달하여 호출하라는 것
       
                                        function greet(greeting, punctuation) {
                                            console.log(greeting + ', ' + this.name + punctuation);
                                        }
                                        
                                        const person = { name: 'Alice' };
                                        const args = ['Hello', '!'];
                                        
                                        greet.apply(person, args);
  
                   3) bind 메서드
                       : 어떤 함수를 기반으로 this로 설정할 {객체}를 다르게 설정(binding)만 변환한 새로운 함수를 반환하기 위해 사용하는 메서드
                         (= bind 메서드로 반환된 함수는 나중에 호출할 수 있음)
                             -> 기존 함수를 기반으로 this의 주체만 변한 함수를 손쉽게 생성해서 사용가능하다는 이점이 존재

                                ex) boundGreet라는 함수는 greet 함수에서 this에 대한 참조값만 변환한 새로운 함수

                                    function greet(greeting, punctuation) {
                                      console.log(greeting + ', ' + this.name + punctuation);
                                    }
                                    
                                    const person = { name: 'Alice' };
                                    
                                    const boundGreet = greet.bind(person);
                                    boundGreet('Hello', '!');

                # apply, call, bind 공통점/차이점

                  (공통점)
                    : 모두 어떤 함수 내용부의 this 값을 {특정 객체}로 설정하는 기능을 제공
                        -> 함수의 맥락(this)을 명시적으로 변경하고, 그 변경된 맥락에서 함수를 호출하는 편의성을 제공

                  (차이점)

                    1) 함수 호출 시점
                      - call, apply 함수를 즉시 호출
                      - bind는 새로운 함수(바인딩된 함수)를 반환함
                        (= 호출 시점은 원하는데로 조절)

                    2) 사용법과 함수 선언부의 구조가 제각각



  5. 조건문
      : ()안의 어떤 조건식의 결과가 true, falue이냐에 따라서, 코드 {}를 실행할지 말지를 정할 수 있게 만든 구문에 대한 문법

       @ 조건식
          : 참(True) 또는 거짓(False)의 boolean 값으로 환산될 수 있는 변수나 연산자로 or 함수 호출로 구성된 표현식.. 
            (= 조건문은 ()안의 내용을 연산한 뒤 참(True) 또는 거짓(False)을 판별하고, 어떤 {}의 코드를 실행할 지 말지를 결정함) 

           # Truthiness 개념
              : JS에서의 모든 자료형의 값들은 boolean 맥락(context)적으로 그 값 자체로 참과 거짓을 판별하는 Truthy / Falsy 개념으로 true / false를 판별
                (= JS에서는 어떤 값의 true / false를 판별할 때, 따로 형변환(type colution)를 하지 않고, 그 자체로 boolean값으로 판별이 가능함)

               1) falsy
                   : 자료형에 따라 false에 대응하는 값들에 해당하는 경우  (= 그 외의 값은 true으로 평가)
                      -> (중요) 0, null, undefined, NaN, "", false, -0, 0n
        
                         ex) false에 속하는 값들 equality 예시
                         
                             console.log(0 == false);          // true
                             console.log(0 === false);         // false : 0은 number =/ false는 boolean
                             console.log('' == false);         // true
                             console.log('' === false);        // false : ''은 string =/ false는 boolean
                             console.log(null == undefined);   // true
                             console.log(null === undefined);  // false : null과 undefined는 다른 자료형

               2) Truthy
                   : 자료형에 따라 true에 대응하는 값들에 해당하는 경우  
                     (= Falsy에 해당하는 녀석들 이외의 참조자료형(reference type)을 포함한 모든 값들에 해당하며, 이들을 모두 true으로 평가)
                         -> (중요) {객체}, function, Symbol에 해당하는 것들과 infinity와 같은 특별한 값들도 전부 true에 해당!


       @ 연산자(manipulator)의 종류

          1) 비교 연산자
              : 두 변수의 값을 비교하여 조건식을 만들 때 사용하는 연산자로, 실제 그 두 변수의 비교 관계가 연산자가 나타내는 범위에 해당됨에 따라 참 또는 거짓을 반환하는 연산자
                
                a. == (동등 연산자)
                    : (자료형이 다르면 형변환을 한 뒤) 2개의 변수의 값이 같은지 비교

                b. === (일치 연산자)
                    : 2개의 변수의 값과 '자료형'이 모두 같은지 비교
                        -> (중요) ==, === 둘의 차이는 일치여부 기준이 단순 내용만 같은지 보냐(==)? 아니면 자료형까지 같아야 하나(===)? 에 있다
                c. != 
                    : (자료형이 다르면 형변환을 한 뒤) 2개의 변수의 값이  다른지 비교

                d. !==
                    : 2개의 변수의 값과 '자료형'이 모두 다른지 비교
                        -> (중요) !=, !== 둘의 차이는 일치여부 기준이 단순 내용만 다른지 보냐(!=)? 아니면 자료형까지 달라야 하나(!==)? 에 있다

                e. >   : 왼쪽의 변수가 오른쪽의 변수보다 크기가 큰 지 비교
                f. <   : 왼쪽의 변수가 오른쪽의 변수보다 크기가 작은지 비교
                g. >=  : 왼쪽의 변수가 오른쪽의 변수보다 크거나 같은지 비교
                h. <=  : 왼쪽의 변수가 오른쪽의 변수보다 작거나 같은지 비교
          
          2) 논리 연산자
              : 어떤 조건문의 true/false 결과를 toogle 시키는 여집합을 의미하는 NOT의 의미를 걸거나, 2개 이상의 조건문에 AND, OR 관계를 부여하여 '복합 조건문'을 만들기 위해 사용하는 연산자
                  -> (참고) 조건문의 실행을 효율적으로 하기 위해 || &&를 사용하기도 한다

                a. && (AND)
                    : 2개의 조건문에 AND조건을 부여할 떄 사용

                     # (참고) && 연산자를 사용하는 경우, 무거운 연산의 논리변수 및 함수는 가급적 뒤에다 두는게 효율적임
                         -> why? AND 논리연산상 둘 중 하나라도 FALSE면 무조건 TRUE
                            (= JS엔진도 복합 조건문을 판별할 떄, &&가 보일 때 FALSE가 앞쪽에 감지되면, 그 뒤는 오류가 나던 말던 조건문을 보지 않음)

                b. || (OR)
                    : 2개의 조건문에 OR조건을 부여할 떄 사용

                     # (참고) || 연산자를 사용하는 경우, 무거운 연산의 논리변수 및 함수는 가급적 뒤에다 두는게 효율적임
                         -> why? OR 논리연산상 둘 중 하나라도 TRUE면 무조건 TRUE
                            (= JS엔진도 복합 조건문을 판별할 떄, ||가 보일 때 TRUE가 앞쪽에 감지되면, 그 뒤는 오류가 나던 말던 조건문을 보지 않음)

                c. ! (NOT)
                    : 여떤 조건문의 여집합에 해당하는 boolean값을 출력하는 NOT의 의미를 부여할 떄 사용

        3) 삼항 연산자(ternary operator) '?'
            : 어떤 조건문의 결과가 '참(True)' 또는 '거짓(False)'인지를 판별하고, 그에 따라 '?' 연산자 뒤에 존재하는 :를 기준으로 나뉜 값을 다르게 반환하라는 용도의 연산자
                -> (문법)
                     : 조건식 ? value1 : value2;

                       ex) name이라는 변수의 값과 자료형이 'ellie'라는 string 값과 같으면, 'yes' 다르면 'no'를 반환 
                       
                           console.log(name === 'ellie' ? 'yes' : 'no');


     @ JS에서 null 처리 관련 사용 가능한 조건 연산자
        : ES2020 ~ 21에 등장한 신기능으로 변수나 {객체}의 값이 null, NAN, undefined인 경우 일어날 수 있는 같은 에러를 피해서, 안전하게 데이터를 꺼내기 위해 사용하는 변수와 사용하는 연산자들
          (= 쉽게 말해, 복잡한 양식이나 경우에 따라 null문제로 에러가 생길 수 있는 {객체}에 대한  null, NAN, undefined 처리를 하기 싫어서 사용하는 3항 연산자의 null 여부 처리 응용버전이라 생각하면 편함)

          1) 옵셔널 체이닝 연산자 '?' (optional chaining operator)
              : 어떤 {객체}나 그 내부의 {객체 프로퍼티}가 null, NAN, undefined로 들어올 위험이 있는 경우 '?'를 붙이는데, 해당 {객체}에 해당하는 요소가 null 혹은 undefined로 밝히지면, 더 내부로 파고들지 말고 undefined로 남겨달라는 의미의 연산자
                -> (참고) '?'는 에러를 해결해주는 문법이 아니라 에러나지 않게 감추는 문법일 뿐
  
                   ex) {user} 내부에 {age1}라는 객체가 존재하지 않는데, 이 경우 '?'를 써주면 {age1}라는 프로퍼티가 없는걸 판별하고 undefined를 출력함 
                   
                       var user = {
                           name : 'kim',
                           age : { value : 20 }
                       }
       
                       console.log(user.age1.value1);    <- 에러나는 코드... null처리를 해주면 된다지만 귀찮..
                       console.log(user.age1?.value1);   <- null 에러시, 여차하면 undefined가 출력함
  

          2) 널리쉬 콜레싱 연산자 '??' (nullish coalescing operator)
              : 옵셔널 체이닝 연산자와 유사하지만, 이 연산자가 붙여진 변수가 null인 경우 오른쪽에 미리 지정한 '문자열'을 보여주라는 의미의 '??' 연산자
                (= 옵셔널 체이닝 연산자의 발전형으로 보통 프론트엔드 라이브러리나 프레임워크를 사용한 웹서비스에서 ajax 요청이 늦게 도착할 경우, 유저에게 undefined 안 보여주기 위하여 사용됨)
                    -> (문법)
                         : 변수명 ?? '해당 변수명이 null에 해당하는 경우 보여줄 문자열';

                           ex) {user} 내부에 {age1}라는 객체가 존재하지 않는데, 이 경우 '?'를 써주면 {age1}라는 프로퍼티가 없는걸 판별하고 undefined를 출력함 
                           
                               var user = {
                                   name : 'kim',
                                   age : { value : 20 }
                               }
                  
                               console.log(user.age1?.value1?? '좀만 기다려라');    <- '좀만 기다려라' 라는 문구로 모든 null처리 가능


     @ JS에서 사용 가능한 기본 조건문의 종류 
     
        1) if ~ else if ~ else 구문
            : if를 시작으로 else if까지는 상단에 놓인 구문의 ()안의 조건식을 실행하여, true로 판명되면 해당 {}를 실행하고 나머지는 다 무시함... 아무것도 해당하지 않으면 else {}로 실행
               -> 조건문 중에 우선순위를 정하고, 그만한 순위를 상단에 올리면 됨

                  ex) name이란 변수가 무엇이냐에 따라 분기가 결정되며, 일단 상단부터 true에 해당하는 조건문이 발견되면, 해당 {}를 실행하고 조건문을 빠져나옴
                  
                      const name = 'df';
                      
                      if (name === 'ellie') {
                        console.log('Welcome, Ellie!');
                      } else if (name === 'coder') {
                        console.log('You are amazing coder');
                      } else {
                        console.log('unkwnon');
                      }

        2) Switch case 구문
            : ()안의 값에 따라 분기가 결정.. 없으면 'default'로..
               -> (주의) break; 구문을 빼먹으면, 그 밑의 case들도 실행됨

                  ex) browser 변수의 값에 따라 case 분기 결정
                      
                      const browser = 'IE';
                      
                      switch (browser) {
                        case 'IE':
                          console.log('go away!');
                          break;
                        case 'Chrome':
                        case 'Firefox':
                          console.log('love you!');
                          break;
                        default:
                          console.log('same all!');
                          break;
                      }



  6. 반복문

     @ JS에서 사용 가능한 기본적 반복문의 종류 
        1) for문
            : 가장 유명한 반복문에 해당하는 구문으로 ;을 기준을 1번째는 index시작값 2번째는 종료조건에 해당하는 조건문 3번째는 index의 증감수준을 연산자로 지정함
               -> (문법)
                    : for(시작값; 조건문; 증감식)
                       -> 2번째의 조건문과 3번째의 증감 수준 지정은 창의력을 발휘하면 기상천외한 물건도 나옴 

                          ex) 가장 단순한 구조의 for문
                          
                              for (i = 3; i > 0; i--) {
                                console.log(`for: ${i}`);
                              }


             # nested loops (중첩 for문)
                : 말 그대로 for문 안에 또 for문에 해당하는 {}가 존재하는 내용

                  ex) ''가 아닌 ``으로 문자 템플릿(literal template)을 사용하여 2중 for문으로 문자열 찍는 코드
                  
                      for (let i = 0; i < 10; i++) {
                        for (let j = 0; j < 10; j++) {
                          console.log(`i: ${i}, j:${j}`);
                        }
                      }

        2) while문
            : 내용이 조건에 true값이 나올때까지 반복함

              ex) let i = 3;
                  
                  while (i > 0) {
                    console.log(`while: ${i}`);
                    i--;
                  }


        3) do ~ while문
            : while과 같지만, do안의 내용을 먼저 시작하고, while구문 진행

              ex) 일단 console.log(`do while: ${i}`)를 시작하고, i변수의 증감 연산자를 통한 연산도 1번은 실행한 뒤, while문에 진입

                  do {
                    console.log(`do while: ${i}`);
                    i--;
                  } while (i > 0);


        4) Array.forEach( 무명콜백함수(요소, 인덱스, 배열자신) )
            : [배열]에 해당하는 {객체} 내부의 메서드로 [배열]의 내부요소를 효율적으로 순회할 수 있을 뿐 아니라, '무명콜백함수'를 통해 [배열]의 요소들을 기반으로 내용부를 실행이 가능함
              (= [배열] 내부의 요소와 정보를 augument로 넣어 어떤 함수의 내용부를 순회하여 실행시키는 기능에 해당)
                  -> (중요) [배열] 내부 요소를 활용하고 순회하여 함수 내용부를 순회한다는 컨셉은 '함수형 프로그래밍' 패러다임을 따르는 조건에 맞는 새로운 [배열]을 return 해주는 Filter, Map 메서드가 계승함

                      ex) [arrNum]의 내부요소를 활용한 forEach() 메서드의 parameter인 무명콜백함수의 1번째 parameter인 num은 각 [arrNum]의 내부요소를 의미
                            -> 이를 통해, '내부요소 * 2'가 순환되어 실행
                                
                          let arrNum = [1, 2, 3];
                          
                          arrNum.forEach(num => {
                            console.log(`num: ${num * 2}`);
                          });

                          -> num : 2 , num : 4 , num : 6가 실행


     @ (ES6 이후) 사용 가능한 반복문 종류 
        : 근본적인 문법은 for (var 내부요소 operator 참조자료명)에 해당하며, 비슷해보이지만 각각 enumerable(셀수 있는), iterables(반복 가능) 여부를 참고하여 어떤 {객체}의 자료들을 순회를 함
          (= [배열] 또한 JS에서는 {객체}이기에 역시 사용이 가능함)
              -> (중요) for in과 for of의 차이점
                   - for in
                       : {객체} 내부의 개별 {프로퍼티}들이 enumerable(셀수 있는) 속성이 true에 해당하는지가 반복의 조건

                   - for of
                       : {객체} 자체에 iterables(반복 가능) 속성이 true에 해당하는지가 반복의 조건
                           -> (중요) iterables(반복 가능) 속성은 Symbol.iterator() 이라는 Symbol 자료형의 내장Symbol명에 해당되는 일종의 Symbol 자료형의 메소드를 통해 알 수 있도록 구현
                           
        1) (ES6 이후) for in 반복문
            : 각 {프로퍼티명} 내부의 enumerable 속성값이 true인 경우에 해당하는 녀석들만 순회 대상에 두고, {객체}의 내부 프로퍼티를 순차적으로 순회가능한 반복문

             # for in 반복문 문법
                : for (var 개별프로퍼티 in {객체명}) { 내용부 }

                  ex) {오브젝트}의 개별 프로퍼티는 key라는 변수에 각각 담김
                  
                      var 오브젝트 = { name : 'Kim', age : 30 };

                      for (var key in 오브젝트) {
                        console.log(오브젝트[key]);
                      }

             # for in 반복문 사용 조건

                a. for in 반복문은 사용대상이 {객체}
                    -> (중요) [배열] 또한 JS에서는 {객체}이기에 역시 사용이 가능함!
                         -> (주의!) [배열]도 {객체}기는 하지만, index 또한 알고보면 {객체}가 베이스인 [배열]의 프로퍼티에 해당하니.. 절대 두 개념을 혼용하지 말길 바람

                b. {객체}의 내부 각 {프로퍼티명} 내부의 enumerable 속성값이 true인 경우에 해당하는 녀석들만 순회해 줌
                    -> 해당 프러퍼티가 이에 해당하는지 보고 싶다면, Object.getOwnPropertyDescriptor( {객체명} , '프로퍼티명')라는 {객체}의 메서드를 사용해서 확인
                       (= {객체} 내부 {프로퍼티}도 {객체}에 해당하고 저장하는 값이 많기에, {객체} 자료형은 무거움 == Map 자료형을 쓰는 이유)

                       ex) {오브젝트} 내부의 name이라는 프러퍼티도 알고보면 {name}에 해당하는 {객체}... 
                             -> Object.getOwnPropertyDescriptor(오브젝트, 'name') 메서드를 통해 확인 가능

                                var 오브젝트 = { name : 'Kim', age : 30 };
                                console.log( Object.getOwnPropertyDescriptor(오브젝트, 'name') ); 
                                  -> {value: "Kim", writable: true, enumerable: true, configurable: true} 

             # for in 반복문의 특성
                 
                a. {객체} 자료형 각각의 {프로퍼티명}의 비밀 내부 프러퍼티 enumerable(셀수 있는) 속성의 boolean값을 확인
                   (= 성능이 어떤 참조자료명 자체가 iterable(반복 가능)한지만 확인하는 for of 구문보다 느릴 수 밖에 없음)
                        -> (참고) {객체} 자체가 무거운 이유가 곧 성능이 낮은 이유!

                b. {객체} 자료형 각각의 {프로퍼티명}의 비밀 내부 프러퍼티 enumerable(셀수 있는) 속성의 boolean값을 확인하기에, 성능이 느릴 수 밖에 없음 
                     -> (참고) {객체} 자체가 무거운 이유가 곧 성능이 낮은 이유!

                c. [배열] 또한 {객체} = {객체}.생성프로퍼티명 을 통해 '값' 대입 가능
                     ->  BUT! [배열]도 {객체}기는 하지만, index 또한 알고보면 {객체}가 베이스인 [배열]의 프로퍼티에 해당함 = 런타임 에러 보고 싶으면 써라..

                          ex) arrJobs[인덱스]로 접근 가능한 [arrJobs]에도 {객체}에 프로퍼티 추가하는 식으로 추가되고, arrJobs[프로퍼티명]으로도 접근이 됨
                              (= [배열]의 인덱스 숫자도 일종의 {객체}의 프로퍼티명에 해당함)

                              let arrJobs = ['Hunter', 'Knight'];
                              arrJobs.job = 'Wizard';
                              
                              for (let element in arrJobs) {
                                console.log(`${element} is ${arrJobs[element]}`);
                              }

                d. 대상 {객체}의 {prototype 객체}에 속해 {부모 객체}로 부터 상속받은 {상속된 프로퍼티}들도 반복대상에 포함됨
                   (= {부모 객체}로 부터 상속받은 {상속된 프로퍼티}들의 enumerable 속성값이 true)
                       -> Object.hasOwnProperty(프로퍼티명)을 통한 조건문으로 대상 {객체} 자신에게 속한 프로퍼티명 출력되게 할 수 있음 

                          ex) 부모라는 클래스를 기반으로 {오브젝트}를 생성하고, 이를 for in 반복문을 통해, 내부 순회를 하되 {prototype}에 속하는 {프러퍼티}들은 거르도록 함
                               -> Object.hasOwnProperty(프로퍼티명) 메서드를 통해 확인 가능

                                  class 부모 {
                                   
                                  }
   
                                  부모.prototype.name = 'Park';
                                  
                                  var 오브젝트 = new 부모();
                                  
                                  for (var key in 오브젝트) {
                                    if (오브젝트.hasOwnProperty(key)) {
                                      console.log(오브젝트[key]);
                                    }
                                  }

        2) (ES6 이후) for of 반복문
            : 어떤 {객체}가 'iterables(반복 가능)'한 특성이 있기만 한다면, {객체}의 내부 프로퍼티를 순차적으로 순회 가능한 반복문 문법
              (= 반복문 조건의 기준이 {객체}의 내부요소가 아닌 {객체} 그 자신에게 있음 == for in 반복문보다 성능에 유리)

             # for of 반복문 문법
                : for (var 개별요소 of {iterables한 객체명}) { 내용부 }

                  ex) [어레이]는 [배열]로 iterables한 속성을 가진 {Iterator 객체}이기에 순환이 가능
                        -> 2 3 4 5 출력

                           var 어레이 = [2,3,4,5];
                           
                           for (var 자료 of 어레이) {
                             console.log(자료);
                           }

             # for of 반복문 사용 조건
                : 어떤 {객체}의 Symbol.iterator() 이라는 Symbol 자료형에 해당되는 {객체}의 메서드가 존재하여 어떤 종류의 {iterator 객체}인지 출력되면 됨
                  (= iterables한 {객체}의 속성에 대한 정보를 Symbol 자료형으로 구현함)
                      -> (주의!) 이게 없는 {객체}에 for of 반복문을 쓰면 TypeError가 발생 

                  ex) [어레이]의 내부 메서드 Symbol.iterator를 실행하니, {배열 Iterator 객체}에 해당한다고 출력해줌

                      var 어레이 = [2,3,4,5];
                      console.log( 어레이[Symbol.iterator]() );
                       -> Array Iterator {}

             # (중요) 반복 가능한(iterables) {객체} 목록
                 a. [배열]
                 b. '문자열'
                 c. {Set 객체}
                 d. {Map 객체}
                 e. {NodeList 객체}

             # for of 반복문의 특성

                a. 반복문 조건의 기준이 {객체}의 내부요소가 아닌 {객체} 그 자신에게 있움
                   (= for in 반복문보다 성능에 유리)

                b. 해당 변수가 저장 중인 {객체}의 자료형에만 신경쓰면 되는데, 대부분의 {컨테이너 객체}들은 이미 iterables한 속성을 부여받은 상태임
                    -> (참고) {DOM 객체} 검색시 가장 최선조 요소인 {NodeList 객체}도 여기 포함되서, getElementBy 시리즈건 querySelectorAll이건 변한 DOM API를 써도 순환이 쉬움

                c. [배열] 또한 {객체} = {객체}.생성프로퍼티명 을 통해 '값' 대입 가능
                    ->  BUT! [배열]도 {객체}기는 하지만, index 또한 알고보면 {객체}가 베이스인 [배열]의 프로퍼티에 해당함 = 런타임 에러 보고 싶으면 써라..


     @ 반복문과 조건문이 같이 쓰일 경우 사용하는 break, continue
        : 반복문과 조건문이 같이 쓰일 경우, 조건문의 결과에 따라.. 해당 루프의 {}를 빠져나올지, 반복문 전체의 {}를 빠져나올지를 정하는 예약어

           1) break   
               : 그 자리에서 반복문을 멈추도록 하는 예약어

                 ex) index에 해당하는 값이 9이상이 되는 순간 반복문 전체를 중단하고 반복문의 {}를 빠져나와 코드를 진행

                     for (let i = 0; i < 11; i++) {
                       if (i > 8) {
                         break;
                       }
                       console.log(`q2. ${i}`);
                     }

            2) continue 
                : 현재의 반복 싸이클을 skip하고, 다음 반복 싸이클로 넘어가서 반복문을 계속 수행하라고 하는 예약어

                  ex) index에 해당하는 값의 2로 나눈 나머지가 0이면 해당 반복문 루프를 전체를 중단하고, 다음 반복 싸이클을 진행

                      for (let i = 0; i < 11; i++) {
                        if (i % 2 === 0) {
                          continue;
                        }
                        console.log(`q1. ${i}`);
                      }



  7. (ES6 이후) {Promise 객체}를 활용한 콜백함수 대체 디자인 패턴
       : ES6 이전 비동기함수들의 순차적 처리에 있어 무수한 중첩된 콜백지옥(nested callback hell)로 인한 문제를 해결하기 위해 고안된 어떤 함수의 내용을 성공, 실패 판정해주는 {객체}와 메서드를 사용한 디자인 패턴
          -> (참고) 보통 어디에 사용하냐면, 비동기 로직인 ajax를 통한 api 호출의 성공/실패를 조건으로 업무 코드들을 구간별로 묶어서 처리하기 위해 콜백함수를 써왔는데, 이에 대한 제어를 상대적으로 단순하고 직관적으로 할 수 있게 만들어 줌
               -> 대충 콜백함수로 처리되던 코드들의 debug가 쉬워지는 효과도 존재 

     @ (참고) 기존 콜백 함수(callback function)의 단점
        : (결론) 이 녀석의 장점은 살리고, 단점은 최소화하기 위해 고안된 결과물이.. ES6의 'Promise'를 이용한 디자인 패턴인 'then, catch, finally', ES8의 'async/await'
     
          1) 콜백 지옥(callback hell)
              : 중첩(nested)된 콜백 함수가 많아져서, 함수{}들이 2중 3중으로 중첩되어 있으면 코드가 복잡해지고 가독성이 떨어질 수 있음
                 -> 이를 개선하기 위한 시작점으로 ES6의 {promise 객체} 개념을 도입한 디자인 패턴인 'then, catch, finally', ES8의 'async/await'

                    ex) 전형적인 콜백지옥으로, 엄청나게 많은 함수{}가 중첩되어 있음
                          -> 코드가 실행은 되지만, 이거 인간의 시선에서 함수가 어떻게 작동하는지와 디버깅이 참 답도 없음
                    
                             첫째함수(function(){
                               둘째함수(function(){
                                 셋째함수(function(){
                                   어쩌구..
                                 });
                               });
                             }):
     
          2) 비동기 작업 에러 처리
              : 비동기 작업에서 발생하는 에러를 처리하기 어려울 수 있음

          3) 어떤 작업이 실패했을 경우 코드 처리가 어려움..
             (= 따로 조건문 만들어서 처리해야 하는데, 이러면 코드가 더 개판나고 콜백지옥이 더 심해짐)


     @ (ES6 이후) {Promise 객체}
         : parameter 변수에 augument로 들어오는 실행자(executor)라고 불리는 parameter가 2개 존재하는 함수를 실행한 뒤, 그에 대한 성공/실패의 여부를 판별한 뒤, 그에 따라 자신의 상태(state)값을 변환하고 그에 맞는 후속처리를 순차적으로 해주는 역할의 {객체}

           # {Promise 객체}를 구성하는 요소들

               1) 실행자(executor) 함수
                   : {Promise 객체}의 생성자(constructor) 함수의 parameter 자리에 들어가는 augument로서 들어가는 함수로, {promise 객체}가 생성시 자동으로 실행..
                       -> (중요) 그 결과가 성공/실패를 판별하는 기준이 되어서, 그에 따라 반환되는 {promise 객체}에 상태(state)값을 포함한 프로퍼티가 갱신되어 후속 메서드의 호출의 트리거가 되어주는 1번째 업무 구간의 함수

                    - 실행자(executor) 함수의 특성
                       a. 실행자(executor) 함수는 {promise 객체}가 생성시 자동으로 바로 실행되는 내용부에 해당하는 함수
                          (= 자동으로 바로 실행되는 함수라는 건, 이 녀석이 {promise 객체}를 통해 수행되는 업무로직의 1번째 구간에 해당하는 내용임을 의미)
                          
                       b. 보통 resolve와 reject로 불리는 콜백함수들을 parameter 변수에 augument로 보냄
                           -> (중요) 무엇(정확히는 몇번째 콜백함수)이 호출되느냐에 따라 추후 반환되는 {promise 객체}의 상태(state)값과 호출하는 메서드가 변함
                           
                       c. 보통 resolve와 reject 둘 중 하나가 호출되면, 실행자(executor) 함수는 거기서 종료되고, 반환되는 {promise 객체}의 프로퍼티가 변하고, 후속 메서드가 상태(state)값에 따라 연계(chaining) 됨
                           -> 아무것도 호출 안하면, 실행자(executor) 함수의 종료는 곧 {promise 객체} 연계(chaining) 로직의 종료를 의미함.. 
                              (= 근데 애초에 의도가 콜백함수를 통한 동적인 작동순서 확보임을 생각하면 이따위로 써봤자 의미가 없음)

                       d. 결과값으로 내부 상태값이 갱신된 {promise 객체}를 return 함
                          (= return값으로 다른 {promise 객체}를 선언하고 던져놓는다면, 사실상 메서드 연계(chaining)의 주자를 바톤터치가 가능 = 사용자의 코드 설계에 따라서는 콜백함수의 기능을 교묘히 깔끔하게 대체가 가능)
                              -> 이거 then 메서드도 마찬가지의 특성을 가지므로, 비동기 코드의 실행순서를 설계할 때 유용하게 사용 가능
                                 (= 특히 웹서버에 비동기로 요청보내는 fetch API는 그 결과값으로 {promise 객체}를 반환한다는 점에서, 서버와의 요청(request) & 응답(response)를 다루는데에 아주 유용하게 응용이 가능함)

                    - 실행자(executor) 함수의 parameter로 들어가는 콜백함수(callback function)의 종류와 용도
                       : 보통 resolve와 reject로 불리는 2가지의 JS에서 자체 제공한 콜백함수가 augument로 들어갈 수 있음
                          -> (중요) BUT! resolve와 reject라고 augument명을 고정할 필요도 없는게, 왜냐하면 JS에서 실행자(executor) 함수의 성공/실패 여부를 규정하는 건 몇번째로 적혀있는 콜백함수인지 여부를 따지기 떄문

                             a. resolve(성공시 value값) = 1번째 augument인 callback함수(성공시 value값)
                                (= 1번째 augument인 callback함수가 호출되었음 = resolve 호출 = 실행자(executor) 함수의 성공 = then을 연계(chaining) 메서드로 호출)
                                    : 호출 자체가 실행자(executor) 함수의 '성공'을 의미하는 콜백함수로 1번째 augument인 callback함수가 호출되어도 같은 의미를 지니며, {promise 객체} 내부 프로퍼티 속성( 상태(state), 결과(result) )들을 변환하고, 현재 코드기준 가장 위에 있는 then을 연계(chaining) 메서드로 호출
                                        -> resolve(성공시 value값) 호출 시, 변환되는 {promise 객체} 내부의 프러퍼티 속성과 값
                                            [1] 상태(state)
                                                 : 보류(pending) -> 이행(fulfilled)
                                            
                                            [2] 결과(result)
                                                 : undefined -> 성공시 value값 (= resolve 콜백함수 호출에 사용한 augument값)
                                                    -> 결과(result) 값은 다음 {promise 객체}의 연계(chaining) 된 then의 1번째 콜백함수의 parameter변수에 augument로 전달됨
                                    
    
                             b. reject({Error 객체}) = 2번째 augument인 callback함수({Error 객체})
                                (= 2번째 augument인 callback함수가 호출되었음 = reject 호출 = 실행자(executor) 함수의 실패)
                                    : 호출 자체가 실행자(executor) 함수의 '실패'을 의미하는 콜백함수로 2번째 augument인 callback함수가 호출되어도 같은 의미를 지니며, {promise 객체} 내부 프로퍼티 속성( 상태(state), 결과(result) )들을 변환하고, 현재 코드기준 가장 위에 있는 then(2번째 콜백함수가 있는 경우)이나 catch을 연계(chaining) 메서드로 호출
                                        -> reject({Error 객체}) 호출 시, 변환되는 {promise 객체} 내부의 프러퍼티 속성과 값
                                            [1] 상태(state)
                                                 : 보류(pending) -> 거부됨(rejected)
                                            
                                            [2] 결과(result)
                                                 : undefined -> {Error객체} (= reject 콜백함수 호출에 사용한 augument값)
                                                    -> (중요) 결과(result) 값은 다음 {promise 객체}의 연계(chaining) 된 then의 2번째 콜백함수 or catch의 1번째 콜백함수의 parameter변수에 augument로 전달됨
                                                    -> (참고) 실패시 value값도 뭐든 상관없지만, 그래도 {Error객체}를 추천

               2) {promise 객체}의 프로퍼티들
               
                  A. 상태(state)값
                      : {promise 객체}가 수행하고 있는 함수 로직의 흐름이 현재 성공인지 실패인지 여부를 기록하기 위해 존재하는 {promise 객체} 내부의 캡슐화 되어 접근이 제한된 프로퍼티 속성으로 초기값은 'pending(보류)'
                          -> 이후 실행자(executor) 함수가 어떤 콜백함수를 수행하냐에 따라 속성값이 변화하고, 그에 따라 호출하는 메서드도 변화함
                       
                        - 상태(state)값의 종류
                        
                           a. pending(보류)
                               : {promise 객체}가 처음 생성되었을 때 초기화된 상태(state)값으로
                                   -> 이후 실행자(executor) 함수의 실행으로 인한 결과로 몇 번쨰 콜백함수를 호출했냐에 따라 해당 속성값이 변화
                               
                           b. fulfuilled(이행)
                               : 실행자(executor) 함수의 실행의 결과가 1번째 augument인 callback함수(= resolve)인 경우에 변환되는 속성값
                                   -> 이후 {promise 객체}의 then(1번째 콜백함수, 2번째 콜백함수) 메서드를 연계(chaining) + 상태(state)가 이행(fulfilled)시 실행되는 무명 함수인 1번째 콜백함수를 실행함
                                       -> 상태(state)가 이행(fulfilled)시 실행되는 무명 함수인 1번째 콜백함수를 실행의 결과로 또 해당 값은 변화의 가능성을 맞으며, 다시 fulfuilled(이행)이냐 rejected(거부됨)에 따라 호출하는 연계(chaining) 메서드가 달라짐

                           c. rejected(거부됨)
                               : 실행자(executor) 함수의 실행의 결과가 2번째 augument인 callback함수(= reject)인 경우에 변환되는 속성값
                                   -> 이후 {promise 객체}의 2번째 콜백함수가 있는 then(1번째 콜백함수, 2번째 콜백함수) 메서드의 상태(state)가 거부됨(rejected)시 실행되는 무명 함수인 2번째 콜백함수를 실행함 or catch(콜백함수)를 호출하여 해당 콜백함수를 실행함
                                       -> 상태(state)가 거부됨(rejected)으로 끝났으면, 더 이상 변화의 가능성은 없으며, 이후 finally 연계(chaining) 메서드가 해당 코드 하단에 존재하지 않으면 거기서 {promise 객체}의 메서드 연계(chaining) 종료됨

               3) {promise 객체}의 메서드들
                    : 주로 실행자(executor) 함수의 결과에 따른 콜백함수의 종류에 따라 연계(chaining) 메서드로서 실행되는 녀석들
                      (= 실행자(executor) 함수의 결과에 따라 연계(chaining) 된다는 것 = {promise 객체}를 통해 수행되는 업무로직의 n번째 구간을 담당함)
                           -> (중요) {promise 객체}가 상태(state)값에 따라 업무로직을 구간별로 순차적으로 수행하기 위해 존재하는 {객체}라는 사실을 시사
                  
                       a. then( 상태(state)가 fulfilled 시 실행되는 무명콜백함수, 상태가 rejected 시 실행되는 무명콜백함수 )
                           : {promise 객체}의 상태(state)가...

                               - 이행(fulfilled) 시에는 무조건 호출되고 그 실행되는 결과값으로 반드시 {promise 객체}를 반환하며, 그 내부의 상태(state)값에 따라 다음 연계(chaining) 메서드를 찾아 실행시킴
                                   -> 상태(state)가 이행(fulfilled) 시 호출되었다면, 이행(fulfilled)시 실행되는 무명콜백함수의 결과에 따라 또 해당 값은 변화의 가능성을 맞음
                                      (= 그렇게 then()메서드의 무명콜백함수의 결과로 반드시 반환되는 {promise 객체}의 상태값이 다시 fulfuilled(이행)이냐 rejected(거부됨)에 따라 호출하는 연계(chaining) 메서드가 달라짐)
 
                               - 거부됨(rejected)시에는 상태가 rejected 시 실행되는 무명함수인 2번쨰 무명함수가 존재할 시에만 연계(chaining) 호출되는 {promise 객체}의 메서드

     
                       b. catch( 상태가 rejected 시 실행되는 무명콜백함수 )
                           : 상태(state)가 rejected(거부됨) 시에 연계(chaining) 호출되어, 자신의 parameter가 받는 무명콜백함수를 실행하는 {promise 객체}의 메서드 
     
                       c. finally( 상태(state)값 여부랑 상관없이 실행되는 무명콜백함수 )
                           : 상태(state)값과 상관없이 자기 차례가 오면 무조건 연계(chaining) 호출되어, 자신의 parameter가 받는 무명콜백함수를 실행하는 {promise 객체}의 메서드

           # Promise API
              : Promise 객체에는 5가지 정적 멤버함수들이 존재하며, 프로세스 안의 여러개의 비동기 작업 코드들에 대한 통제를 더 의도(semantic)를 가지고 정확하게 할 수 있음
         
                 1) Promise.all( iterable 객체 ) 
                     : (중요) promise 객체들이 여러개 있고, 그들의 작업을 동시성을 가지고 진행시키고, 이들이 끝나기 전까지 다음 작업을 처리하지 않고 기다려야 하는 경우 사용하는 함수
                         -> 쉽게 말해, 각 업무를 기준으로 구분한 비동기 작업 코드로 이뤄진 컨텍스트(context) 집단들 여러개를 더 큰 틀에서 일괄적으로 동시성(concurrency)을 가지고 동작하도록 통제하기 위한 방법
         
                         ex) Promise.all( [promise 객체1, ... promise 객체n])
                              : (중요) 함수의 결과값은 안에 존재하는 promise 객체들의 처리가 '전부 성공' or '하나라도 실패'의 경우로 나뉨
         
                                  - iterable 객체 안의 promise 객체의 비동기 작업 전부 성공시?
                                      : 각 promise 객체가 가진 작업처리 성공에 대한 결과값의 배열형식으로 변환되어, 새로운 promise 객체의 상태값으로 반환
         
                                        ex) Promise.all의 성공 결과값 예시
                                        
                                            [promise 객체1 성공상태값, ... , promise 객체n 성공상태값]
                                              -> (주의) 해당 배열의 순서는 parameter로 들어간 iterable 내부의 index 그대로임
         
                                        ex) 모든 비동기 처리 성공한 Promise.all 예시
         
                                            // 1, 2, 3이 새로운 promise 객체의 상태값으로 반환
                                            Promise.all([
                                              new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
                                              new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
                                              new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
                                            ]).then(alert); 
         
         
                                  - iterable 객체 안의 promise 객체의 비동기 작업 하나라도 실패시?
                                      : 그 즉시 Promise.all 전체가 거부 처리 되어서 .catch 구문이 실행됨...
                                         -> (주의) 그렇다고 다른 promise 객체를 통한 비동기 작업까지 중지되진 않음.. 단지 다른 비동기 처리결과에 따른 promise 객체의 상태값이 그 뒤 어쩄든 상관없이 완전히 무시됨
         
                                        ex) 비동기 처리 중 하나라도 작업처리 실패가 나는 Promise.all 예시
         
                                            // Error: 에러 발생!
                                            Promise.all([
                                              new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
                                              new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
                                              new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
                                            ]).catch(alert); 
         
         
                     # Promise.all( iterable 객체 ) 특징
                        a. parameter로 들어간 iterable 객체 안의 promise 객체들은 일괄적인 타이밍에 비동기로 실행됨
                        b. (중요) Promise.all() 함수의 결과값은 안에 존재하는 promise 객체들의 처리에 따라 all or nothing같은 개념
                        c. Promise.all() 함수의 결과값이 성공처리 되었는데, iterable 객체에 일반값이 있는경우.. 성공값에 해당하는 배열에 그 일반값이 들어감
         
                           ex) Promise.all([ new Promise((resolve, reject) => { setTimeout(() => resolve(1), 1000) }), 2, 3 ]).then(alert); 
                                -> 결과값 : [1, 2, 3]
         
                        d. parameter는 iterable 객체면 뭐든 ㅇㅋ임
                           (= promise 객체가 아닌 일반값도 넣을 수 있음)
                               -> 물론 대개는 promise 객체 배열이 들어감
         
                        e. Promise 객체에는 '취소’라는 개념이 없어서, Promise.all도 프라미스를 취소하지 않움
                           (= catch() 뜨는걸 원하지 않아서, 해당 Promise 객체에 속한 작업을 취소할 수 없다는 말)
                              -> 만약 각 비동기 작업의 실패/성공 응답을 받고 싶으면 Promise.allSettled을 쓰자
         
         
                 2) Promise.allSettled( [promise 객체1, ... promise 객체n])
                     : Promise.all과 비슷하나... all or nothing 개념이 아니라.. 각 promise의 처리에 대한 결과값을 응답으로 각각 반환해줌
         
                       ex) let urls = [
                             'https://api.github.com/users/iliakan',
                             'https://api.github.com/users/Violet-Bora-Lee',
                             'https://no-such-url'
                           ];
                           
                           Promise.allSettled(urls.map(url => fetch(url)))
                             .then(results => { 
                               results.forEach((result, num) => {
                                 if (result.status == "fulfilled") {
                                   alert(`${urls[num]}: ${result.value.status}`);
                                 }
                                 if (result.status == "rejected") {
                                   alert(`${urls[num]}: ${result.reason}`);
                                 }
                               });
                             });
         
                           ------------------------------------------------------------------
                           [ {status: 'fulfilled', value: ...응답...},
                             {status: 'fulfilled', value: ...응답...},
                             {status: 'rejected', reason: ...에러 객체...} ] 형식으로 반환
                           ------------------------------------------------------------------
         
                       - 응답이 성공할 경우 : {status:"fulfilled", value:result} 형식으로 해당 promise 결과값 리턴
                       - 에러가 발생한 경우 : {status:"rejected", reason:error} 형식으로 해당 promise 결과값 리턴
         
                 3) Promise.race( [promise 객체1, ... promise 객체n])
                     : Promise.all과 비슷하나, 다만 가장 먼저 처리되는 프라미스의 결과(혹은 에러)만을 반환
         
                        ex) 다음 작업은 1번쨰 promise 객체의 비동기 작업이 가장 빨리 나왔기에, 1번쨰 promise의 결과값만 출력
         
                            Promise.race([
                              new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
                              new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
                              new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
                            ]).then(alert); // 1
         
                 4) Promise.resolve( value )
                     : (async/await 등장 이후 사장) value 에 해당하는 parameter 값으로 작업 상태값이 성공 상태인 promise 객체를 생성
                       -> (중요!) 상단 promise객체 생성과 하단 then() 구문에서 지겹게 보는 무명함수의 1번쨰 parameter인 callback함수명이 이 녀석
         
                 5) Promise.reject( error )
                     : (async/await 등장 이후 사장) error에 해당하는 parameter 값으로 작업 상태값이 실패 상태인 promise 객체를 생성
                       -> (중요!) 상단 promise객체 생성과 하단 then() 구문에서 지겹게 보는 무명함수의 2번쨰 parameter인 callback함수명이 이 녀석
         
                        ex) const promise = new Promise((resolve, reject) => {
         
                              if (isResolved == true) {
                                resolve("Success");   <- 성공적으로 처리될 경우 무명함수의 parameter 중 resolve를 callback함수로 호출
                              } else {
                                reject("Error");      <- 거부될 경우 무명함수의 parameter 중 reject를 callback함수로 호출
                              }
                              
                            });
         
                            promise.then(
                 
                              (result) => {
                                console.log("Resolved:", result);
                              },
                              (error) => {
                                console.error("Rejected:", error);
                              }
                            )

           # {Promise 객체} 이해에 필요한 주의사항들
               1) {Promise 객체}는 과거의 콜백함수의 단점들을 보완하기 위해 제작된 {객체}로 이를 이용한 디자인 패턴이 과거의 콜백함수의 단점들을 보완하여 작동됨
                  (= {Promise 객체}는 동기/비동기와는 전혀 상관없고, 단지 업무 로직들을 구간별로 구분하고 조건에 따라 실행되게 만드는 기능을 담당하는 {객체}라는 것)
                       -> (참고) 비동기로 작동하는 함수를 사용하고 싶다면, ES8 이전에는 queueMicrotask(함수명)을 통해 억지로 비동기적으로 함수를 실행되게 하거나, ES8부터 지원되는 {promise 객체} 기반 async/await를 쓰도록 하자

               2) {Promise 객체}를 통해, 콜백함수가 중첩될 경우 디버깅(debug)을 통해, 내부 프로퍼티인 state, result를 통한 현재 진행상활을 쉽게 판단이 가능함

               3) 어떤 코드가 실패로 끝났을 때, 상태(state)값 변화로 인한 조건문 처리가 쉬움... 
                   -> then()의 2번째 콜백함수나, catch() 구분으로 처리하면 됨

               4) {Promise 객체}의 메서드 연계(chaining)은 현재 위치를 기준으로 '상단 -> 하단'으로 switch문 처럼 순차적으로 진행되며, 해당 코드에 진입했을 때 실행조건이 맞으면 호출되는 식으로 연쇄적으로 진행됨
                    -> 그렇게 쭉 가다가 가장 끝까지 도래하고 실행할 코드가 없으면, 연계(chaining)가 끝나게 됨


     @ (ES6 이후) {Promise 객체}와 then, catch, finally 메서드 연계(chaining)을 활용한 디자인 패턴
         : {Promise 객체}의 특성을 이용하여, 업무로직을 순차적으로 구간을 기준으로 수행하고 조건에 따라 분기처리를 쉽게 하는 콜백함수를 대체하는 디자인 패턴  
             -> 중요한건 이미 {Promise 객체}에서 다 설명했으니 예시로 바로 들어가도록 하자

           # then, catch, finally 메서드 연계(chaining)을 활용한 디자인 패턴을 사용하는 케이스

              1) 시간이 오래걸리는 비동기 작업(side effect)가 실행되어 성공/실패가 판별되고 난 뒤 특정 코드를 실행하려는 경우
                  : 현재 작업 완료 후 순차적으로 코드 호출하는 동기적 작업 + 싱글 쓰레드(thread) 환경의 JS에서는 비동기 코드 및 작업들을 순차적으로 시키려 들 때, 이들의 업무로직을 구간을 기준으로 순차적인 실행을 보장할 수 없음
                     -> BUT! 상태(state)값과 결과(result)값을 바탕으로, 다음 구간에 해당하는 연계(chaining) 메서드인 then, catch, finally로 구분가능한 {promise 객체}로는 이러한 로직을 수행 가능  

                        ex) 프로미스라는 {promise 객체}의 실행자(executor) 함수가 비동기적으로 마무리 되면, 그에 따른 후속 작업을 경우에 맞게 수행 가능 
       
                            var 프로미스 = new Promise(function(성공, 실패){
                              var 어려운연산 = 1 + 1;
                              성공(어려운연산);
                            });
                            
                            프로미스.then(function(결과){
                              console.log('연산이 성공했습니다' + 결과)
                            }).catch(function(){
                              console.log('실패했습니다')
                            });

              2) 비동기적으로 작동되는 스케쥴링 기능에 해당되는 WEB API에 해당하는 settimeout을 활용하여, 특정 시간동안 코드 실행을 지연한 뒤 비동기적인 특정 코드들을 순차적으로 실행하려는 경우
                  : 스케쥴링 기능에 해당되는 WEB API는 현재의 콜스택(call stack)과 별개로 주요업무 대기열(macro task quete)에 들어기기에, 기존 동기적 작업 + 싱글 쓰레드(thread) 환경의 JS에서는 그 이후의 조건적 진행을 순차적으로 보장 불가능함
                     -> BUT! 상태(state)값과 결과(result)값을 바탕으로, 다음 구간에 해당하는 연계(chaining) 메서드인 then, catch, finally로 구분가능한 {promise 객체}로는 이러한 로직을 수행 가능  

                        ex) 모든 콜스택(call stack)의 업무가 끝나고 비동기적으로 1초 대기 후에, 그의 후속코드에 해당하는 코드구간들을 then, catch, finally로 지정가능

                            var 프로미스 = new Promise(function(성공, 실패){
                              setTimeout(function(){
                                성공();
                              }, 1000);
                            });
                            
                            프로미스.then(function(){
                              console.log('1초 대기 성공했습니다')
                            }).catch(function(){
                              console.log('실패했습니다')
                            });


     @ (ES8 이후) async/await 패턴
         : 내부적으로는 {Promise 객체} 기반의 디자인 패턴으로 작동하지만, 비동기 함수 제작의 형태로 더 쉽고 직관적으로 콜백함수 로직을 대체하는 {Promise 객체} 기반의 디자인 패턴을 보완하는 새로운 디자인 패턴
           (= {Promise 객체} 기반의 디자인 패턴 = async/await 패턴은 try ~ catch ~ finally와 혼용 및 연계가 가능함..)
                -> 비동기적으로 동작하는 함수를 async라는 키워드 하나를 함수에 붙여서 쉽게 작성하게 하고, 해당 함수 내부의 비동기 코드들의 흐름을 순차적으로 통제할 업무구간 로직을 await 키워드로 관리할 수 있도록 함

           # async/await 키워드 개념
              : 함수명을 선언하고, 그 앞에 async 키워드를 붙이면, 비동기적으로 작동하는 함수가 선언되며, 그 내용부에 await 키워드를 배치하면 기존의 then에 해당되는 부분을 대체하여 비동기로 작동하는 코드들을 업무 구간을 기준으로 이정표를 세움으로서 실행흐름을 통제함  

                1) async 키워드
                    : '함수명'이 존재하는 함수 앞에 해당 async 키워드를 붙이면, '비동기 함수' 형태로 동작하는 {Promise 객체}를 생성해 주며, 결과값으로도 {Promise 객체}를 반환함
                        -> (중요) async를 함수에 붙이면 {비동기 함수 객체}를 생성할 수 있도록 {Promise 객체}객체로 변환하는 키워드로 봐도 무방하기에, {함수 객체}에 {Promise 객체} 기능할 수 있는 프로퍼티와 메서드 또한 가지고 있는 형태로 보면 됨
                                 (= 정확히는 async가 붙은 그 함수는 이제부터 {Promise 객체}가 되고, {Promise 객체}를 반환도 가능한 {Promise 객체} 기반의 함수가 되어버림)
                          
                      - async 키워드 사용시 주의 및 특이사항
                      
                         a. (중요) async 키워드로 만들어진 비동기 함수의 결과값은 무조건 {이행(fulfilled) 상태의 promise 객체}를 반환함
                              -> then, catch, finally 메서드를 통한 패턴을 사용가능

                                 ex) fetchData 라는 비동기함수의 결과값 또한 {promise 객체}로 반환되기에, then catch finally 패턴으로 연결이 가능함
     
                                      async function fetchData() {
                                          let response = await fetch('https://example.com');
                                          let data = await response.json();
                                          return data;
                                      }
     
                                      fetchData().then(function(결과){
                                        console.log(결과)
                                      })catch(function(실패원인){
                                        console.log(실패원인)
                                      })
   
                         b. (중요) 반드시 해당 키워드를 쓰기 위해서는 '함수명'이 존재해야 하며, 그것만 존재한다면 함수 표현식(expression)이던 선언(declaration)이던 상관이 없음
                              -> class 문법과도 연계가 가능함

                                 ex1) 함수 선언(Function Declaration)에서의 async 사용 예시
             
                                      async function fetchData() {
                                          let response = await fetch('https://example.com');
                                          let data = await response.json();
                                          return data;
                                      }
             
                                 ex2) 함수 표현식(Function Expression)에서의 async 사용 예시
             
                                      const fetchData = async function() {
                                          let response = await fetch('https://example.com');
                                          let data = await response.json();
                                          return data;
                                      }
             
                                 ex3) 화살표 함수(Arrow Function)에서의 async 사용 예시
             
                                      const fetchData = async () => {
                                          let response = await fetch('https://example.com');
                                          let data = await response.json();
                                          return data;
                                      }
             
                                 ex4) 객체 메서드(Object Method)에서의 async 사용 예시
             
                                      const obj = {
                                          async fetchData() {
                                              let response = await fetch('https://example.com');
                                              let data = await response.json();
                                              return data;
                                          }
                                      };
       
                                 ex5) 클래스 메서드(Class Method)에서의 async 사용 예시
             
                                      class MyClass {
                                          async fetchData() {
                                              let response = await fetch('https://example.com');
                                              let data = await response.json();
                                              return data;
                                          }
                                      };

                         c. (중요) 예외적으로 즉시 실행 무명함수(IIFE)와 사용이 가능함..
                              -> 이를 통해, 해당 async 함수는 실행 순서가 되면 바로 실행되고, {promise 객체}의 실행자(executor) 함수로 연결되서 실햄됨
                                 
                                 ex) async 키워드를 사용한 즉시 실행 무명함수(IIFE)로 감싸면, async 함수 안에서 실행되기에 실행이 가능함
                                 
                                     (async () => {
                                       let response = await fetch('/article/promise-chaining/user.json');
                                       let user = await response.json();
                                       ...
                                     })();

                2) await 키워드
                    : async 키워드를 쓴 함수 내용부에서만 동작하는 키워드로, 해당 async 함수 내부에 중첩하여 존재하는 {promise 객체}에 대해 then 메서드 역할을 대체할 수 있는 키워드
                       -> 정확히는 {promise 객체}의 실행자(executor) 함수가 처리되어 상태(state)값이 변경될 때까지 기다리는(await) 의미를 가짐 
                           -> (중요) await 앞에 놓은 {promise 객체}의 실행자(executor) 함수나 현재 콜백함수의 처리가 완료되면 반환되는 내용은 상태(state)와 result(결과)값이 포함된 {promise 객체}
                                -> BUT! 어차피 상태(state)값이 이행(fulfilled)인 경우에 한해서만, await 키워드는 에러없이 후속동작 되므로, 사실상 await 앞에 놓은 {promise 객체}가 전달하는  상태(state)와 result(결과)값은 실행자(executor) 함수나 현재 콜백함수가 성공했을 경우에 해당하는 값임
                                   (= then() 메서드랑 정확히 하는 일이 겹치진 않음.. 하지만 결국 연계(chaining) 호출로 {}가 중첩되는 일이 생기지 않고, 비동기 코드를 await를 기점으로 순차적으로 진행할 수 있다는게 의의)  
                       
                                    ex) 어려운연산이라는 {promise 객체}의 실행자(executor) 함수의 결과가 1번째 콜백함수 '성공(결과)'를 호출함에 따라, 상태(state)와 결과(result)값은 각각 이행(fulfilled)와 2로 바뀌고
                                         -> '결과'라는 변수는 어려운연산이란 {promise 객체}의 result 프로퍼티에 해당하는 2를 대입받게 됨

                                             async function 더하기(){
                                               var 어려운연산 = new Promise((성공, 실패)=>{
                                                 var 결과 = 1 + 1;
                                                 성공(결과);
                                               });
                                               var 결과 = await 어려운연산;       <- 어려운연산.then( 결과 -> console.log(결과) ); 을 대체하는 await를 이용한 코드
                                               console.log(결과);                <- async/await 덕분에 {}를 중첩하지 않아도 후속코드를 이어 쓸수 있음(물론 state가 fulfilled 일때만 가정하니까 쓸 수 있는 코드이긴 함)
                                             }
                                             더하기();

                      - (중요!) await 키워드 사용시 주의 및 특이사항    
                         a. 반드시 async 키워드가 쓰인 함수 내부에 쓰여야 함
                            (= 일반함수에는 사용할 수 없음)
                            
                         b. 태생이 {promise 객체}와 호환이 되는 모든 {객체} 앞에 await 사용이 가능함
                             -> (중요) 정확히는 메서드로 then을 가지고 있어서, {promise 객체}와 호환이 가능한 {객체}에 await를 사용 가능함
                                  -> {promise 객체}와 호환이 가능한 {객체}를 await이 받을 시, 그 {객체} 내부의 then 메서드를 즉시 실행하여 실행자(executor) 함수로서 호출함

                                      ex) await는 {thenable 객체}(= then 메서드가 있는 호출 가능한 {객체}로 {promise 객체}와 호환 가능) 앞에 사용이 가능함
                                           -> Thenable 클래스의 then 메서드가 실행자(executor) 함수로서 호출됨
          
                                              class Thenable {
                                                constructor(num) {
                                                  this.num = num;
                                                }
                                                then(resolve, reject) {
                                                  alert(resolve);
                                                  setTimeout(() => resolve(this.num * 2), 1000); 
                                                }
                                              };
                                              
                                              async function f() {
                                                let result = await new Thenable(1);
                                                alert(result);
                                              }
               
                                              f();

                         c. await의 결과값을 받아줄 변수가 반드시 필요하지는 않음

                            ex) await new Promise((resolve, reject) => setTimeout(resolve, 3000)) 형식의 코드도 3초대기 후 잘 작동함.. 단지 결과값을 아무도 안 받아줄 뿐
                                async function showAvatar() {
                                
                                  let img = document.createElement('img');
                                  img.src = githubUser.avatar_url;
                                  img.className = "promise-avatar-example";
                                  document.body.append(img);
                                
                                  await new Promise((resolve, reject) => setTimeout(resolve, 3000));
                                  
                                  img.remove();
                                  return githubUser;
                                }
                                
                                showAvatar();

                         d. (중요) await는 async가 동반되지 않은 스코프 {}인 전역 스코프 {} 레벨에서 작동하지 않음
                              -> BUT! async 키워드를 사용한 즉시 실행 무명함수(IIFE)로 감싸면, await는 전역 스코프 {} 레벨에서 작동하지 않음

                                 ex) 최상위 레벨 코드에선 await 문법 에러가 발생함
                                 
                                     let response = await fetch('/article/promise-chaining/user.json');
                                     let user = await response.json();
                                 
                                 ex) async 키워드를 사용한 즉시 실행 무명함수(IIFE)로 감싸면, async 함수 안에서 실행되기에 실행이 가능함
                                 
                                     (async () => {
                                       let response = await fetch('/article/promise-chaining/user.json');
                                       let user = await response.json();
                                       ...
                                     })();

                         e. (중요) await는 Promise.all과도 함께 쓸 수 있음
                              -> 여러 개의 프라미스가 모두 처리되길 기다려야 하는 상황이라면 이들을 Promise.all로 감싸고 여기에 await를 붙여 사용할 수 있음

                                 ex) {promise 객체}인 fetch 처리 결과가 담긴 [배열]을 기다림
                                 
                                     let results = await Promise.all([
                                       fetch(url1),
                                       fetch(url2),
                                       ...
                                     ]);
                                     
                         f. 사실상 해당 {promise 객체}의 상태(state)값이 이행(fulfilled)이 되었을 때, 연계(chaining) 호출되는 then()만을 대체 가능함
                            (= await 키워드로는 해당 {promise 객체}의 상태(state)값이 rejected(거부됨)인 상태를 처리할 수 없음)
                                -> (중요) 그래서 {promise 객체}의 실행자(executor) 함수 및 후속 then 메서드의 1번째 콜백함수가 실패하는 경우가 예상되면 try ~ catch 문법이 보통 같이 쓰이거나, then, catch finally가 쓰임

                                    ex) 더하기라는 async 키워드를 붙인 {promise 객체} 기반 비동기 함수 내부에 어려운연산이라는 {promise 객체}가 중첩되어 있고 실행자(executor) 함수의 결과가 나올떄까지 기다림
                                         -> 결과가 실패하여, 상태(state)값이 rejected(거부됨)이라면, 이는 catch로 나가 떨아지게 됨

                                            async function 더하기(){
                                              var 어려운연산 = new Promise((성공, 실패)=>{
                                                실패();
                                              });
                                              try {  var 결과 = await 어려운연산 }
                                              catch { 어려운연산 Promise가 실패할 경우 실행할 코드 }
                                            }



  8. (ES6 이후) js 모듈러 시스템
     : HTML의 script 태그에서 다른 스크립트 파일들을 src속성을 통해 불러올 때, 해당 script 코드들이 1개의 단일영역에 적혀있는 것처럼 작동하는 것을 막고, js 모듈을 기준으로 '블럭 스코프'(block scope)와 같은 판정이 생겨서, 그 안에서 선언한 변수는 그 안에서만 사용이 가능하게 하는 시스템
         -> 다시 말해, Class 내 변수를 쓰려고 할 때 이들을 불러오는 문법이 있듯, 모듈 내의 변수들을 구분해서 불러오는 구문이 따로 필요하다는 것 의미
             -> 이렇게 js의 모듈을 불러오는 방식을 '모듈 시스템(module system)'으로 명칭함

      @ 블럭 스코프(block scope)
        : js(es6 이후로 추정)에서 지역변수적 요소를 구현하고자 쓰는 결계로 그 안에 쓰는 변수 let 혹은 const는 그 안에서만 통용되는 지역변수처럼 적용됨
           -> {}를 통해 결계를 치고, 그 안에 쓴 변수 let 혹은 const는 그 안에서만 통용되는 지역변수화가 됨 (반대로, 안에서는 전역변수들을 만나는게 가능한 함수에서의 {}와 같음)
              (단! var는 그런거 적용 안 되니 쓰지 않도록 한다)


      @ 자주 사용되는 2가지의 모듈 시스템
         1) ES Module (사실상의 승자)
             : JS ES6(ES2015)에 도입된 자바스크립트 자체의 모듈 시스템 방식 (과거 제작된 react에서 많이 보이는 녀석)
                -> (중요) NodeJS 13.2부터 ES모듈 시스템에 대한 정식 지원이 시작 = node.js에서도 babel같은거 없이 사용 가능 
                      -> package.json에서 type = "module" 선언화면 바로 사용 가능하게 조치 
                         (= package.json와 연관있는 react 또한 이를 사용함을 유추 가능...)
                             ->  정확히는 함수 component를 쓸 때, 해당 기능을 강화시키는 hooks 모듈을 불러올 때 사용)

              # ES Module 사용법
                : (from 사용할 모듈) export 구문을 입력 -> (to 가져오는 파일) import구문을 통해 불러옴

                  A. ES Module 내보내기 : export 구문
  
                      a. export 내보내고 싶은 변수명;
                          : 모듈에서 변수 하나만 내보내는 방법
  
                      b. export { 내보내고 싶은 변수명(여러개도 가능) };
                          : 모듈에서 여러개의 변수들을 내보내는 방법

                      c. export * 
                          : 모듈에서 모든 변수들을 내보내는 방법

                      d. export let(const, class 등 다 허용) 내보내고 싶은 변수명;
                          : 어떤 변수를 선언하자 마자 export시키고 싶을 때 사용하는 방법
                              -> 그나마 가장 범용성이 좋은 방법 

                    - (중요) export와 함께 사용이 가능한 키워드

                       a. export default
                           : import시 특별한 변수명을 없다면, default를 붙인 export문에서 지명한 변수를 가져오게 하는 역할 수행
                              -> (참고사항)
                                   1) export 사용 횟수에는 제약이 없는데, default가 붙은 경우는 오직! 단! 한번 사용 가능함
                                   2) 보통 import 구문을 사용시에는 가져올 변수를 직접 기입함
                                   3) (중요) 해당 파일에 변수가 1개 뿐이면, 반드시 default까지 써야함
                           
                       b. export 내보내고 싶은 변수명 as 대체변수명
                           : 다른 모듈에서 import시 대체변수명이란 이름으로 가져오게 하는 역할 수행

                  B. ES Module 불러오기 : import 구문
  
                      a. import 지은 변수명 from '불러오는 모듈 경로'
                          : 모듈에서 변수 하나만 가져오는 방법  
                              -> export default {여려변수들} 을 사용한다면, b구문처럼 '지은 변수명'을 객체명처럼 사용 가능 
  
                      b. import * as 지은 변수명 from '불러오는 모듈 경로';
                          : 모듈에서 모든 변수를 가져오는 방법 
                            (*의 의미 : SQL에서 모든 변수 가져오는것 의미.. -> 이걸 '지은 변수명'으로 통칭해 객체명화 하는 것)
                              -> '별칭.프로퍼티' or '별칭.메서드명(파라미터....)'' 를 통해 값을 지칭해서 불러옴
  
                      c. import { 가져올 변수명(여러개도 가능) } from '불러오는 모듈 경로';
                          : 모듈에서 1개 ~ 여러개 변수를 가져오는 방법
                              -> 그나마 가장 범용성이 좋은 방법 

                  C. ES Module 불러오기와 동시에 다른 모듈로 내보내기 : export 변수명 from "module" 구문을
                      : 어떤 모듈을 import 하자마자, 그 모듈의 특정 변수를 다른 모듈로 보낼때 사용

                        ex) import {login, logout} from './helpers.js';    ==    export {login, logout} from './helpers.js';
                            export {login, logout};

                            a. export 내보내고 싶은 변수명 from "대상 모듈 위치경로";
                                : 모듈에서 변수 하나만 가져오자 마자 다른 모듈로 내보내는 방법
        
                            b. export { 내보내고 싶은 변수명(여러개도 가능) } from "대상 모듈 위치경로";
                                : 모듈에서 여러개의 변수들을 가져오자 마자 다른 모듈로 내보내는 방법
    
                            c. export *  from "대상 모듈 위치경로";
                                : 모듈에서 default로 지정된 변수를 제외하고 모든 변수들을 다른 모듈로 내보내는 방법
    
                            d. export { default }  from "대상 모듈 위치경로";
                                : 모듈에서 default로 지정된 변수들을 다른 모듈로 내보내는 방법

         2) CommonJs
             : NodeJS 환경에서 자바스크립트 모듈을 사용하기 위해 만들어진 모듈 시스템 
                -> 일부 내용은 ES Module과 기능상 호환되는 부분이 존재함

              # CommonJs 사용법
                 : (from 사용할 모듈) 사용할 변수 앞에 export.변수명 입력 or module.export { } 구문 입력- > (to 가져오는 파일) require('파일경로'); 구문을 통해 불러옴

                   A. CommonJs 모듈 내보내기 : export.변수명 및 module.export 구문
  
                       a. export.내보내고 싶은 변수명;
                           : 내보내고 싶은 js 변수 앞에 'export.' 를 일일히 붙여서 모듈의 변수로서 블록 스코프에 넣는 것으로 판정 
  
                       b. module.export { 내보내고 싶은 변수명(여러개도 가능) };
                           : 이를 통해 여러개의 변수들을 직관적으로 지명 가능
                               -> 그나마 가장 범용성이 좋은 방법 
  
                   B. CommonJs 모듈 불러오기 : require 구문
  
                       a. let or const { 불러오고 싶은 변수명(여러개도 가능) } = require('파일경로');
                           : 모듈에서 1개 ~ 여러개 변수를 가져오는 방법
                               -> 그나마 가장 범용성이 좋은 방법 
  
                       b. let or const 지은 변수명(= 별칭) = require('파일경로');
                           : 모듈에서 모든 변수를 '지은 변수명'으로 통칭해 객체명화 하여 가져오는 방법 
                               -> '별칭.프로퍼티' or '별칭.메서드명(파라미터....)'' 를 통해 값을 지칭해서 불러옴  

                       ex) export 하는 js파일           ->  import 하는 js파일
                           module.exports.a = 10 ;         var 가져온거 = require('/library.js'); 

 

  9. JSON 전역 객체
      : JS에서 JavaScript Object Notation(JSON)을 분석하거나 값을 JSON으로 변환하는 메서드를 가지는 전역객체  
   
       @ JavaScript Object Notation(JSON)
          : Javascript 객체 문법을 따르는 문자열 기반의 데이터 포맷으로.. 베이스가 된 문법이 JS의 object일뿐 어디서나 쓸수 있는 범용적 데이터 포맷
             -> JSON의 특성
                1) JSON은 순수히 데이터 포맷 (= 멤버변수 O , 메서드 X)
                2) 프로퍼티와 값을 구분시, 큰 따옴표("") 만 사용해서 구분할 수 있음
                3) JSON은 '문자열'로서 JSON은 그 전체에 해당하며, 이를 파싱(paring)하여 JS Object로 쓸 수 있게 변환함
                   (= JSON 형식 데이터 그 자체로는 JS object 마냥 객체명.프로퍼티명 or 객체명['프로퍼티명']; 이런식으로 쓸 수 없음)      
   

       @ JSON 메서드
         1) JSON.stringify(array/object 변수)
            : paramter의 array/object -> JSON 변환하여 문자열로서 저장 가능하게 하는 JSON 객체의 내부 함수
               -> 선택 사항으로 특정 속성만 포함하거나, 사용자 정의 방식으로 속성을 대체 가능      
               
         2) JSON.parse(JSON 형식 구문)
            : paramter의 JSON 형식 문자열을 JSON으로서 구문 분석하여, JSON구문 -> array/object나 숫자 문자 반환
               -> 선택적으로 분석 결과의 값과 속성을 변환해 반환
                   -> BUT! object의 함수는 받아주지 못함
 - WEB API
    : 웹표준에서 모든 웹 브라우저에서 제공하기로 표준화 되어 있는 기능을 의미
      (= WEB API에 명시된 기능을 API로 제공할 수 없는 브라우저는 제대로 된 브라우저가 아니라는 말씀)

     # WEB API와 JavaScript(= EMCA Script)의 관계
         : (중요) 분명 양쪽은 별개의 개념이지만! 애초에 JS자체가 브라우저에서 사용하기 위해 개발된 프로그래밍 언어 = WEB API는 JavaScript로 접근하고 사용할 수 있는 기능
            -> 브라우저 엔진은 JavaScript 엔진으로 일부가 구성되고, Web API는 JavaScript 엔진으로 구현됨
               (= 새로운 JavaScript 기능이 추가될 시, 이를 연계하여 Web API에 사용하면 여러가지 측면의 개선점을 보일 수 있음)

               ex) fetch API의 발전
                    : 무자비한 비동기 구문의 콜백지옥을 벗어나기 위한 ES6의 Promise 기능을 기반으로 WEB API에 새롭게 등장함
                       -> 이후 ES8에서 등장한 async/await를 fetch API에 사용가능하게 적용하여, 개발자 편의성과 만족도를 개선

     # WEB API의 종류
        : 매우 많지만, 대표적인거 몇가지 추리면 다음과 같음

          1. DOM API
              : HTML 및 XML 문서의 구조를 표현하고 조작하게 해주는 API (DOM 트리 탐색 및 수정)
  
          2. CSSOM API
              : CSS 스타일시트를 조작할 수 있게 해주는 API (CSSOM 트리 탐색 및 수정)
  
          3. Fetch API
              : Promise 문법 기반으로 제작되어, 비동기적으로 네트워크 요청을 더 쉽게 수행할 수 있게 해주는 API
  
          4. Web Storage API
              : 클라이언트 측에서 데이터를 로컬 및 세션에 저장하게 해주는 브라우저 내부의 저장소 관리용 API
  
          5. Canvas API
              : 브라우저 화면에 2D 그래픽을 그릴 수 있게 하며(= 2D 렌더링 컨텍스트), 프레임 단위로 동적인 환경에 반응하고 움직일 수 있는 무대를 제공하는 API
                 -> 극단적으로는 이걸로 게임도 만들 수 있으며, 기능을 확장해주는 라이브러리들도 많으니... 브라우저로 그래픽을 그리고 싶으면 참고해보기
  
          6. WebSocket API
              : client - server간 실시간 양방향 통신을 가능하게 해주는 WebSocket을 사용하게 해주는 API
  
          7. Geolocation API
              : 사용자의 위치 정보를 가져올 수 있게 해주는 API
  
          8. File API
              : 사용자가 로컬 파일을 웹 애플리케이션에 업로드하고 처리할 수 있게 해주는 API
  
          9. Web Audio API
              : 브라우저에서 <audio> 태그 이상의 기능으로 오디오를 복합적으로 제어하는 다양한 기능을 구현할 수 있도록 도와주는 API
                 -> Video나 WebRTC(Web Real-Time Communication) API에서도 사용하는 범용성이 높은 API

                    ex) 오디오에 이펙트를 추가, 소리 파형을 시각화
          
          10. WebRTC(Web Real-Time Communication) API
              : client - client 간 웹브라우저를 통해서, 별도의 중간 소프트웨어 없이 음성이나 영상 데이터 및 임의의 데이터를 포착하고 마음대로 재생하고 P2P로 교환할 수 있도록 하는 기술인 WebRTC를 사용하게 해주는 API
          
          11. Notification API 
              : 웹브라우저에서 사용자에게 알림 기능 구현시 이를 쉽게 가능하게 해주는 API

    # DOM(document object model) VS CSSOM(CSS object model)

      @ 공통점
         : 브라우저는 DOM tree를 참고하여 HTML구조를 잡고, CSSOM tree를 참고하여 styling을 하여 웹페이지의 랜더링(rendering)을 수행함
             -> 어쨌든 DOM과 CSSOM은 상호작용하여 웹페이지의 랜더링과 동적인 조작이 가능하게 함

      @ 차이점 (DOM트리와 CSSOM트리는 다를 수 있음을 암시)
         : 각 모델이 제어하는 객체와 목적이 차이점
            -> DOM(document object model) : HTML 요소들을 객체화시켜 트리 구조로 표현하여, 이를 JS로 조작하고 변경이 목적
            -> CSSOM(CSS object model)    : style sheet의 각각의 규칙들중 '화면에 들어가야 할 녀석'들만 render 객체화하여 트리 구조로 표현, 이를 조작하고 변경이 목적


 - (참고) 브라우저의 랜더링 과정
    : 브라우저의 랜더링 엔진이 웹페이지의 구체적인 렌더링을 담당하게 되며 다음과 같은 과정을 거침
      (DOM트리, CSS트리 -> Render 트리 ->  Render & Graphic 레이어 -> Layout 설정 -> 레이어 paint -> composite 레이어 -> GPU텍스처 이미지화 -> 택스터 랜더링)
        -> 이 모든 건, 브라우저가 C++로 제작되어 있기 때문에, 랜더링 쓰레드를 따로 쓸 수 있기에 가능한 것이라고 볼 수 있음

           1. 작성된 HTML문을 파싱, 각각의 Node로 구성되어 연결된 DOM트리를 구축하여 웹페이지 구조를 잡음
           2. CSS도 마찬가지로 파싱, 적혀있는 스타일 규칙들이 연결된 CSSOM트리를 구축
           3. CSSOM과 스타일규칙과 DOM의 Node들의 정보를 결합하여, Render Object(랜더 객체)로 구축된 Render Tree(랜더 트리)를 생성
 
           4. Render Tree의 내용 중 화면에 없는 요소라 쳐낼거 쳐내고, 최적화할거 최적화해서 Render Layer(랜더 레이어)를 완성
               -> display:none이 포함된 노드는 지우고, 상속적인 스타일은 부모노드에만 위치하게 설계하는 과정이 여기 들어감
                   -> (중요) display:none인 Node가 지워지기에 렌더트리와 DOM트리는 1:1 대응이 아니다!
  
           5. 만약, Render Layer(랜더 레이어)가 완성될 때 'GPU에서 처리되는 부분'이 있다면, 이 부분들은 강제적으로 Graphic Layer(그래픽 레이어)로 분리
               -> Grapic 레이어 부분은 GPU가 작업처리를 하기에, 결과적으로 멀티쓰레드적인 비동기처리를 하게 됨
                  (= 이 모든 건, 브라우저가 C++로 제작되어 있기 때문에, 랜더링 쓰레드를 따로 쓸 수 있기에 가능한 것)
 
                   ex) CSS3D / video & canvas / filter / animation/ transform : translateZ(0) 등
 
           6. (4, 5의 과정을 거쳐 만들어진) Render Layer(랜더레이어)을 기반으로 LayOut 설정
                -> 좌표는 보통 부모를 기준으로 설정
                -> 이 과정에서 CSS의 width, height, margin, padding 등의 HTML 요소의 공간과 연관된 속성을 처리함
                -> Global Layout은 브라우저 화면 크기를 늘리거나 폰트 사이즈가 커지면 변경
 
           7. Render Layer(랜더레이어)을 대상으로 paint(칠하기) = 레스터화
               -> 이 과정에서 CSS의 color 관련 속성을 처리해줌
 
           8. 만들어진 레이어(Render & Graphic Layer)들을 합쳐서, 복합 레이어(composite layer)로 만들고 표기하기
               -> 이 과정에서 CSS의 transform, opacity 속성을 처리해줌
 
           9. (8의 결과로) 각각의 레이어로부터 비트맵이 생성되고, GPU에 텍스처로 업로드..
               -> GPU 텍스처들은 서로 합쳐져 하나의 이미지로 렌더링되어 화면으로 출력되어 마무리


 - DOM(Document Object Model) API
    : 브라우저에서 표준적으로 기본 제공하는 WEB API 중 하나로, 개별 HTML요소를 JS로 통제 가능한 하나의 {객체}로서 효과적으로 선택 및 조작까지 가능하게 해주는 기능
      (= 당장 HTML의 영역이라 볼 수 있는 document 또한 DOM조작을 통해 접근이 가능하며, 그렇기에 브라우저의 화면에 표현된 HTML이나 XML요소들을 조작이 가능)
          -> (중요) How?
               : HTML 문서(document)의 HTML요소(element)들을 읽고 파싱(parsing)하여서 분리하여 JS로 조작이 가능한 {Node객체}로 변환하고, document객체에 다른 {Node객체}와의 상하관계를 표현하여 배치된 DOM tree구조로 HTML 문서의 구조를 표현함 
                 (= {Node객체}는 곧 {JS객체}로서의 특징을 모두 가지고 있다고 생각하면 됨)

    # document 객체
       : window 객체의 프로퍼티로 'DOM(Document Object Model) tree 구조로 표현된 HTML 문서에 대한 전체 정보'를 담고 있는 {Node객체}로 웹 페이지 그 자체를 의미
         (= JS를 통해 현재 브라우저가 출력한 화면의 HTML요소를 접근하려면, 반드시 document 객체부터 호출해서 시작하고 메서드들을 호출해야 함)
             -> 특정 HTML요소를 DOM 객체 형식으로 호출하기 위한 메서드 = document 메소드들 중 DOM 셀렉터 메서드 

        @ (참고) document 객체 관련 참고사항
           1. document 객체 내부에는 DOM객체 형식으로 표현된 HTML요소를 지정하기 위한 DOM selector API에 해당하는 메서드(= DOM API)가 존재

           2. document 객체는 window객체의 프로퍼티로 document = window.document에 해당함 
               -> Window 객체가 브라우저의 창에 해당하는 부분을 의미한다면, document 객체는 window객체 내부에 로드된 HTML문서(= document)를 의미

           3. document 객체 자체는 해당 화면의 DOM tree의 root(= 뿌리)에 해당하는 부분으로 사실상 DOM객체로 변환된 화면 전체를 의미
               -> (중요) document객체의 root에 해당하는 부분은 <html> 태그

    # DOM객체를 이루는 {객체}들의 상속 관계
       : {Node 객체} -> {Element 객체} -> {HTMLElement 객체} -> {Specific HTML Elements 객체}
           -> DOM(Document Object Model)의 개별 HTML 단위를 구성하는 {객체} 단위들이며, {Node 객체}를 최고 선조로 한 상속 관계를 이룸
              (= DOM tree에 존재하는 {객체}에 가장 기본적인 단위는 {Node 객체}이며, HTML 요소 또한 {Node 객체}를 기반으로 이뤄져 있음)
    
         1. {Node 객체}
              : DOM tree를 구성하는 가장 최소의 단위에 해당하는 {객체}로 이후 이를 상속받은 HTML 요소(element)들이 구현해야 할 기능들을 명시한 interface에 해당하는 존재로서 기능
                (= DOM tree의 모든 {객체}들은 Node 단위의 인터페이스에서 시작하나.. JS에서는 interface도 {객체}를 다르게 표현한 것에 불과하다는거 잊지 마라)

                 ex) <HTML 태그> 또한 Node단위로 구분 가능한 '요소(element)노드'와 text단위에 해당하는 'text 노드'까지 둘 다 포함
                      -> (참고) text노드는 부모인 요소노드의 자식노드에 해당하지만, 그 자신은 자식 노드를 가질 수 없음

               @ {Node 객체}의 종류
                  1) 문서(document)노드
                      : DOM tree의 최상위 계층(root)이면서 전체 문서(Document)를 가리키는 {Document 객체}의 출발점에 해당하는 {Node 객체}

                  2) 요소(element)노드
                      : DOM tree에 존재하는 HTML의 태그 요소(element)에 해당하는 부분에 대한 정보를 가지는 {Node 객체}

                  3) text 노드
                      : DOM tree에 존재하는 HTML의 TEXT에 해당하는 부분에 대한 정보를 가지는 {Node 객체}
                          -> (참고) text노드는 부모인 요소노드의 자식노드에 해당하지만, 그 자신은 자식 노드를 가질 수 없음

                  4) 주석 노드
                      : DOM tree에 존재하는 HTML의 주석에 해당하는 부분에 대한 정보를 가지는 {Node 객체}

               @ {Node 객체}의 특징
                  1) ES6이후에 사용되는 DOM 탐색 메서드인 querySelector('CSS셀렉터') 메서드 종류의 반환값인 컨테이너 역할의 {NodeList 객체}의 최소 단위 요소를 이루게 됨
                      -> But! 컨테이너 역할의 {NodeList 객체}가 담는 {객체}는 모든 {Node 객체} 계열의 자료형을 포함함
                         (= {NodeList 객체}는 {Node 객체}만 담는 게 아니라, {Node 객체}를 상속하는 모든 {자손 객체}들도 담을 수 있다는 말)
                              -> 그래서 {NodeList 객체}의 요소로 {Element 객체} 메서드도 사용이 가능함
                         
                         ex) {Element 객체), {Text 노드 객체}, {Comment 노드 객체}
                               -> 후손인 {Element 객체}로 표현할 수 없는 HTML요소들은 가장 선조에 해당 {Node 객체}로 저장하여 담음

                  2) 일반적으로 HTML 정보를 정적(static)으로 저장하여 상태 변화를 실시간으로 반영 X하는 {non-live DOM 객체} 형태로 저장되어 있음
                      -> BUT! {Element 객체}처럼 실시간으로 HTML객체의 변화를 감지하고 반영하여 저장하는 {live DOM 객체}를 저장하는 예외성이 존재
                         (ES6 이전부터 사용되어 왔던, {Element 객체}의 일부 DOM 탐색 메서드나 프로퍼티들을 사용하던 개발자들도 포용할 수 있도록 함)
                           -> (중요) DOM탐색 메서드명도 같지만, 이들이 반환하는 HTML요소들을 품은 {객체}들 또한 실시간으로 변화를 반영하는 {live DOM 객체}에 해당하도록 예외성이 강한 대목

                               ex) {NodeList 객체}.childNodes ( {Element 객체}.childNodes도 마찬가지 ), {NodeList 객체}.getElementsByTagName(), {NodeList 객체}.getElementsByClassName()

               @ {Node 객체}의 프로퍼티
                  : 전체 DOM객체로 구성된 HTML요소들을 {Node 객체} 단위를 기준으로 이터러블하게 순회하여 탐색 및 선택할 수 있도록 도와주는 멤버변수에 해당 
                    (= {Node 객체}를 상속한 {element 객체} 같은 {객체}들도 당연히 가지고 있음)
  
                    - parentNode  
                       : 기준 노드의 {부모 Node 객체}를 저장
                         (= Document 객체일 경우 root에 해당함 = 부모 노드가 없음으로 null을 반환)
  
                    - childNode(특수성 존재)  
                       : 기준 노드의 {모든 자식 Node 객체}들의 참조가 저장된 {NodeList 객체} 형식의 유사 배열을 저장
                          -> (중요) BUT! {NodeList 객체} 형식은 해당 실시간으로 HTML객체의 변화를 감지하고 반영하여 저장하는 {live DOM 객체}를 저장하는 예외성이 존재
                                   (= {Element 객체}나 {Node 객체}나 프로퍼티로 두는 childNodes는 {live DOM 객체}형식의 {NodeList 객체}를 가짐)
  
                    - firstChild 
                       : 기준 노드의 {1번째 자식 Node 객체}를 저장
                         (= 자식이 없는 노드일 경우 null을 반환)
  
                    - lastChild  
                       : 기준 노드의 {마지막 자식 Node 객체}를 저장
                         (= 자식이 없는 노드일 경우 null을 반환)
  
                    - nextSibling
                       : 기준 노드의 '아우'에 해당하는 {형제 Node 객체}를 저장
  
                    - previousSibling
                       : 기준 노드의 '형님'에 해당하는 {형제 Node 객체}를 저장
  
                    - nodeType
                       : 해당 {Node 객체} 유형애 해당하는 뜻하는 숫자
                         (요소 노드 = 1, 텍스트 노드 = 3, Document = 9)
  
                    - nodeValue
                       : 해당 {Node 객체}가 text 노드일 경우 텍스트 콘텐츠(= 내용)를 저장
                         (= 요소 노드는 null를 반환)

                    - textContent
                       : 기준 {Node 객체}와 그 {후손 node 객체}들의 모든 Text에 해당하는 내용을 '문자열'로 저장하는 프로퍼티
                          -> 정확히는 해당 {Node 객체}를 기준으로 그 내부의 {text Node 객체}가 조작의 범위 =  순수한 텍스트만 조작 가능
                             (= 모든 내용을 내부의 {text Node 객체}의 TEXT로만 받아들이니, XSS 같은 공격을 써도 그저 '문자열'로만 인식)  

                              ex) textContent를 호출하면, 기준 <HTML태그>의 {text Node 객체}에 해당하는 text 내용만, 참조하고 갱신이 가능함
     
                                  const element = document.querySelector('#my-element');
                                  element.textContent = 'New text content'; 
                                  console.log(element.textContent); 
                                    -> New text content 출력

               @ {Node 객체}의 메서드
                 (= {Node 객체}를 상속한 {element 객체} 같은 {객체}들도 당연히 가지고 있음)

                    - appendChild( {Node 객체} )
                       : {parameter Node 객체}를 기준 노드의 마지막 자식노드로 추가

                    - removeChild( {Node 객체} )
                       : 기준 노드의 {parameter Node 객체}에 해당하는 HTML요소를 제거한 뒤, 제거 된 {parameter Node 객체}를 반환

                    - insertBefore( {대상 Node 객체}, {위치 Node 객체} )
                       : {위치 Node 객체}에 해당하는 HTML요소가 기준 노드에 위치한 자식 노드라면? 그 위치 바로 앞에 {대상 Node 객체}를 삽입하는 메서드

                    - replaceChild( {대상 Node 객체}, {위치 Node 객체} )
                       : {위치 Node 객체}에 해당하는 HTML요소가 기준 노드에 위치한 자식 노드라면? 그 위치에 {대상 Node 객체}로 대체하는 메서드

                    - hasChildNodes()
                       : 기준 노드가 자식 노드를 가지고 있는지를 확인한 뒤 boolean값으로 반환
                           - true  : 자식 노드가 존재 O
                           - false : 자식 노드가 존재 X

                    - contains( {Node 객체} )
                       : 기준 노드에서 {parameter Node 객체}에 해당하는 HTML요소를 자식 노드로 가지고 있는지를 확인한 뒤 boolean값으로 반환
                           - true  : {해당 Node 객체} : {parameter Node 객체} 는 부모 : 자식 관계
                           - false : {해당 Node 객체} : {parameter Node 객체} 는 부모 : 자식 관계 X

                    - cloneNode( boolean값 )
                       : 기준 노드의 {Node 객체}를 복사한 뒤 복사된 {Node 객체}를 반환하는 메서드
                           -> paramter에 해당하는 내용은 '깊은 복사' 여부를 의미
                               - true  : 기준 노드의 하위 노드의 내용까지 싸그리 복사
                               - false : 기준 노드의 자신의 내용만 복사

               @ (참고) {live DOM 객체} VS {non-live DOM 객체}
                  : 어떤 {객체}가 저장하는 HTML요소의 정보의 상태 변화가 실시간으로 반영되는가?
                      -> YES : {live DOM 객체} 
                      -> NO  : {non-live DOM 객체} = 해당 HTML요소의 정보가 저장될 시점의 값이 정적(static)으로 남아있음

         2. {Element 객체}
              : 표현되는 단위 기준이 모든 HTML 및 XML 요소들의 공통적인 기본 단위를 기반으로 하는 {Node 객체}를 상속 받는 {객체}
                 -> 모든 HTML 및 XML 요소들 = {element Node 객체}에 해당 = {Node 객체}를 상속 받는 {객체}
                    (= {element Node 객체} 이외의 {text Node 객체}, {주석 Node 객체}의 경우는 HTML 및 XML 요소로 인정 X)

               @ {Element 객체}의 특징

                  1) HTML 및 XML 요소 단위를 표현하는데 해당하는 내용의 프로퍼티와 메서드를 추가로 제공 
                     (= HTML 및 XML 요소 단위는 {text Node 객체}, {주석 Node 객체}는 포함하지 않음 -> {Element 객체}에는 {Node 객체}에서 공유하지 않는 프로퍼티나 메서드가 존재함)

                     ex) HTML의 기본 속성(id, class 등)들을 관리하는 메서드

                  2) 무조건 {live DOM 객체} 형태로 저장되어 있음
                      -> {Element 객체}에 저장된 모든 <HTML태그> 정보들은 각각 실시간으로 HTML객체의 변화를 감지하고 반영하여 저장함
                          (= {Element 객체} 내부의 HTML태그들의 정보는 시시각각 동적으로 변해 예측이 힘들 수 있음)

               @ {Element 객체}의 프로퍼티
                  : 전체 DOM객체로 구성된 HTML요소들을 {Element 객체} 단위를 기준으로 이터러블하게 순회하여 탐색 및 선택할 수 있도록 도와주는 멤버변수에 해당 

                    a. DOM객체에 element객체 탐색 및 조작 관련 메서드

                      - childNodes(특수성 존재)
                         : 기준 <HTML태그>(= elememt 노드)의 {모든 자식 Node 객체}들의 참조가 저장된 {NodeList 객체} 형식의 유사 배열을 저장
                            -> (중요) BUT! {NodeList 객체} 형식은 해당 실시간으로 HTML객체의 변화를 감지하고 반영하여 저장하는 {live DOM 객체}를 저장하는 예외성이 존재
                                     (= {Element 객체}나 {Node 객체}나 프로퍼티로 두는 childNodes는 {live DOM 객체}형식의 {NodeList 객체}를 가짐)
    
                      - childElementCount
                         : 기준 <HTML태그>의 {부모 Element 객체} 개수를 저장
                           (= children.length와 같은 의미)
                    
                      - children
                         : 기준 <HTML태그>의 자식 <HTML태그>들을 담은 {HTMLCollection 객체}로 반환

                      - parentElement
                         : 기준 <HTML태그>의 {부모 Element 객체}를 참조합니다.
                            -> (중요) {Element 객체}를 저장함 = test 노드는 저장 대상에서 제외
    
                      - firstElementChild
                         : 기준 <HTML태그>의 {1번째 자식 Element 객체}를 저장
                            -> (중요) {Element 객체}를 저장함 = test 노드는 저장 대상에서 제외
    
                      - lastElementChild
                         : 기준 <HTML태그>의 {마지막 자식 Element 객체}를 저장
                            -> (중요) {Element 객체}를 저장함 = test 노드는 저장 대상에서 제외
    
                      - nextElementSibling
                         : 기준 <HTML태그>와 '아우'에 해당하는 {형제 Element 객체}를 저장
    
                      - previousElementSibling
                         : 기준 <HTML태그>와 '형님'에 해당하는 {형제 Element 객체}를 저장

                    b. 대상 element객체의 속성 참조 및 조작 관련 메서드

                      - tagName
                         : 기준 <HTML태그>의 명칭을 '대문자'로 가져옴
                            
                           ex) 요소의 태그 이름을 가져옴 (예: 'DIV')
  
                               let tagName = element.tagName;

                      - id
                         : 기준 <HTML태그>의 id속성값을 가져옴
                            -> List 형식이 아닌 이유는 id는 고유한 값이기 때문

                      - className
                         : 기준 <HTML태그>의 class 속성값을 전부 '문자열'로 반환
                            -> class속성값이 모두가 문자열로 저장되는지라, 문자열 다루듯 한 번에 class속성값을 수정하고 갱신할 때 유용
                               (= 개별 클래스를 조작할 때는 불편)

                               ex) 해당 <HTML태그>의 class 속성값을 전부 '문자열'로 치환하는 장/단점 모두가 존재
                               
                                   const element = document.querySelector('#my-element');
                                   element.className = 'new-class another-class';    // 클래스 설정 (기존 클래스 덮어씀)
                                   element.className += ' additional-class';         // 클래스에 새로운 클래스 추가 (기존 클래스 유지)

                      - classList
                         : 기준 <HTML태그>의 class 속성값들을 개별로 조작할 수 있는 DOMTokenList 객체를 반환
                           (= DOMTokenList 객체는 대상 <HTML태그>의 class 속성을 조작 가능한 메서드들을 가짐)
                          
                           (DOMTokenList 객체의 메서드)
                             1. DOMTokenList.add('class명')
                                 : 대상 DOMTokenList 객체로 표현된 <HTML 태그>에 'class명'에 해당하는 class속성값을 추가

                                   ex) element.classList.add('my-class'); 
                              
                             2. DOMTokenList.remove('class명')
                                 : 대상 DOMTokenList 객체로 표현된 <HTML 태그>에 'class명'에 해당하는 class속성값을 삭제

                                   ex) element.classList.remove('my-class'); 

                             3. DOMTokenList.toggle('class명')
                                 : 대상 DOMTokenList 객체로 표현된 <HTML 태그>에 'class명'에 해당하는 class속성값을 toggle 처리
                                   (= 'class명'에 해당하는 class속성값이 있으면 삭제, 없으면 추가)

                                   ex) element.classList.toggle('my-class');   

                             4. DOMTokenList.contains('class명')
                                 : 대상 DOMTokenList 객체로 표현된 <HTML 태그>에 'class명'에 해당하는 class속성값이 있는지 확인 후 boolean값으로 반환

                                   ex) element.classList.contains('my-class');   

                             5. DOMTokenList.replace('구 class명', '신 class명')
                                 : 대상 DOMTokenList 객체로 표현된 <HTML 태그>에 '구 class명'에 해당하는 class속성값을 '신 class명'으로 변환

                                   ex) element.classList.contains('my-class'); 

                    c. 대상 element객체의 내부 node 구조 조작 관련 메서드

                      - innerHTML
                         : 기준 <HTML태그> '내부'의 HTML 또는 XML 마크업을 문자열로 저장하는 프로퍼티
                            -> {element 객체}.innerHTML의 내용을 변경해서, 해당 HTML 내부를 수정할 수 있는 이유는 innerHTML 프로퍼티가 {element 객체} 내부의 태그 내용을 '문자열'로 저장하고 있게 때문
                               (= innerHTML 프로퍼티 자체가 '문자열'을 저장하니, 반드시 '문자열' 형식으로 변경할 HTML태그 내용을 입력해야 함)

                                ex) innerHTML를 호출하면, 기준 <HTML태그> '내부'의 HTML 내용을 '문자열'로 가져옴
                                    innerHTML에 다른 HTML 태그값을 '문자열'로 대입하면, 해당 {element 객체} 내부의 HTML태그을 새롭게 변경 가능 (= 덮어씌우기)
       
                                    <div id="my-div" class="my-class">Hello, world!</div>

                                    element.innerHTML = '<p>Hello, world!</p>'; 

                                    let content = element.innerHTML; 
                                      -> <p>Hello, world!</p> 출력

                      - outerHTML 
                         : 기준 <HTML태그>를 '포함'한 HTML 또는 XML 마크업을 문자열로 저장하는 프로퍼티
                            -> {element 객체}.innerHTML의 내용을 변경해서, HTML을 수정할 수 있는 이유는 outerHTML 프로퍼티가 {element 객체} '자신을 포함'한 태그 내용을 '문자열'로 저장하고 있게 때문
                               (= outerHTML 프로퍼티 자체가 '문자열'을 저장하니, 반드시 '문자열' 형식으로 변경할 HTML태그 내용을 입력해야 함)

                                ex) outerHTML 호출하면, 기준 <HTML태그> '자신을 포함'한 HTML 내용을 '문자열'로 가져옴
                                    outerHTMLL에 다른 HTML 태그값을 '문자열'로 대입하면, 해당 {element 객체} '자신을 포함'한 HTML태그을 새롭게 변경 가능 (= 덮어씌우기)
       
                                    <div id="my-div" class="my-class">Hello, world!</div>

                                    let content = element.innerHTML; 
                                      -> <div id="my-div" class="my-class">Hello, world!</div> 출력

                                    element.outerHTML = '<p>Hello, world!</p>'; 

                                    let content = element.innerHTML; 
                                      -> <p>Hello, world!</p> 출력

                @ {Element 객체}의 메서드 
                   : (중요) querySelector(), querySelectorAll() 역시 {Element 객체}의 메서드 
                       -> DOM객체를 구성하는 가장 하위 단계인 {Node 객체} 단위는 자손에 해당하는 DOM요소가 없을 수도 있음

                   - getAttribute('HTML속성명')
                      : 기준 <HTML태그>에서 parameter로 입력한 'HTML속성명'에 해당하는 속성의 속성값을 반환하는 메서드
        
                        ex) img태그의 src속성 가져오기

                            document.querySelector('img').getAttribute("src");

                   - setAttribute('HTML속성명', 'HTML속성값')
                      : 기준 <HTML태그>에서 parameter로 입력한 'HTML속성명'에 해당하는 속성의 속성값을 'HTML속성값'로 설정해주는 메서드
        
                        ex) img태그의 src속성을 main 이미지로 변경하기

                            document.querySelector('img').setAttribute("src,"./imges/main.jpg");

                   - removeAttribute('HTML속성명')
                      : 기준 <HTML태그>에서 parameter로 입력한 'HTML속성명'에 해당하는 속성의 속성값을 삭제해주는 메서드
        
                        ex) input태그의 onclick 속성값을 삭제

                            document.querySelector('input').removeAttribute("onclick");

                   - hasAttribute('HTML속성명')
                      : 기준 <HTML태그>에서 parameter로 입력한 'HTML속성명'에 해당하는 속성의 속성값이 있는지 없는지를 boolean값으로 반환
        
                        ex) div태그의 id 속성의 속성값이 있는지 없는지를 확인 후, 결과값을 boolean값으로 반환

                            document.querySelector('div').hasAttribute("id");
  
                  - querySelector('CSS셀렉터명')
                     : 해당 {Element 객체} 내부에서 일치하는 1번째 자식 요소를 {Node 계열 객체}로 반환

                  - querySelectorAll('CSS셀렉터명')
                     : 해당 {Element 객체} 내부에서 일치하는 모든 자식 요소를 {NodeList 객체}로 반환

          3. {HTMLElement 객체} 
              : 표현되는 HTML요소 단위 기준이 엄격하게 '<HTML 태그> 단위 만'을 기반으로 하는 {Element 객체}를 상속 받는 {객체}
                (= {HTMLElement 객체}는 {elememt 객체}가 담당한 HTML 요소들에 해당하는 정보를 기반으로 <HTML 태그>에 해당하는 정보를 완성시키기 위해 추가적인 프로퍼티와 메서드를 가짐)
                    -> HTML 문서의 모든 <HTML 태그>들에만 공통적으로 적용되어야 할 프로퍼티들과 메서드를 추가로 가지게 됨 

               @ {HTMLElement 객체}의 특징

                  1) <HTML 태그> 단위에 해당하는 내용의 프로퍼티와 메서드를 추가로 제공 
                     (= <HTML 태그>는 {text Node 객체}, {주석 Node 객체}는 포함하지 않음 -> {HTMLElement 객체}에는 {Node 객체}, {Element 객체}에서 공유하지 않는 프로퍼티나 메서드가 존재함)

                     ex) HTML의 속성(style, data 등)들을 관리하는 메서드

                  2) ES6 이전에 사용되는 DOM 탐색 메서드인 getElement 메서드 종류의 반환값인 컨테이너 역할의 {HTMLCollection 객체}의 내부 요소를 이루고, HTML요소 내용를 저장해주는 {객체}
                     (= ES6 이전 DOM 탐색을 통해 요소를 찾는 기준이 되는 단위 {객체} )

                  3) 무조건 {live DOM 객체} 형태로 저장되어 있음
                      -> {Element 객체}에 저장된 모든 <HTML태그> 정보들은 각각 실시간으로 HTML객체의 변화를 감지하고 반영하여 저장함
                          (= {Element 객체} 내부의 HTML태그들의 정보는 시시각각 동적으로 변해 예측이 힘들 수 있음)

               @ {HTMLElement 객체}의 프로퍼티
                  : 전체 DOM객체로 구성된 HTML요소들을 {Element 객체} 단위를 기준으로 이터러블하게 순회하여 탐색 및 선택할 수 있도록 도와주는 멤버변수에 해당 

                    a. 대상 {HTMLElement 객체}의 <HTML태그> 전용 속성 참조 및 조작 관련 프로퍼티

                       - title
                          : 기준 <HTML태그>의 title 속성값을 가져옴
                             -> title속성값
                                 : 사용자가 마우스를 올렸을 때 보여주는 키워드에 해당 
 
                       - lang
                          : 기준 <HTML태그>의 lang 속성값을 가져옴
                             -> lang속성값
                                 : 현재 HTML 전체나 특정 HTML 요소의 언어를 지정할 때 사용
                                   (= 웹 페이지의 언어를 명시적으로 지정하여 접근성과 SEO를 향상)
 
                                   ex) <html lang="en">
                                       <p lang="fr">Bonjour!</p>
 
                       - dataset
                          : 기준 <HTML태그>의 사용자 정의 속성들의 정보를 가지는 {dataset 객체}를 호출함
                             -> {dataset 객체} 내부에는 사용자들이 'data-attribute-name'과 같은 'kebab-case' 방식으로 정의한 속성들이 프로퍼티로 존재하는데, 이를 data를 제외한 camelCase 형식으로 'attributeName'과 같은 방식으로 접근 가능
                              
                                ex) document.querySelector('div').dataset.attributeName 
                                      -> <div data-attribute-name = "예시"> 라는 사용자 정의 속성에 접근하는 방식
                                
                                     <div id="myDiv" data-user-id="12345" data-role="admin"></div>
                                     <script>
                                         const myDiv = document.getElementById('myDiv');
                                         console.log(myDiv.dataset.userId);               // data-user-id라는 사용자 정의 속성을 userId로 접근 "12345"
                                         console.log(myDiv.dataset.role);                 // data-role라는 사용자 정의 속성을 role로 접근 "admin"
                                     </script>
 
                       - dir
                          : 기준 <HTML태그>의 dir 속성값을 가져옴
                             -> dir속성값
                                 : 현재 HTML 전체나 특정 HTML 요소의 텍스트의 방향을 'rtl(오른쪽 -> 왼쪽)' or '왼쪽 -> 오른쪽' 지정할 때 사용
                                   (= 문서나 요소의 텍스트 방향을 제어하여 언어에 맞는 텍스트 레이아웃을 제공)
 
                                   ex) <p dir="rtl">هذا نص بالعربية</p>
 
                       - style
                          : 기준 <HTML태그>의 inline style 속성을 조작할 수 있는 CSSStyleDeclaration 객체를 반환
                            (= CSSStyleDeclaration 객체는 대상 <HTML태그>의 inline style 속성들에 해당하는 프로퍼티들을 가짐)
 
                            (CSSStyleDeclaration 객체의 프로퍼티들)
                              : 원하는 style 속성에 해당하는 'camelCase' 형식으로 적힌 style명칭 = 프로퍼티 라고 생각하면 OK 
                                  -> (주의) camelCase 형식으로 적는 예시
                                       : background-color >> backgroundColor
                                         font-size >> fontSize
 
                                         ex) camelCase형식을 지켜서 CSS속성을 적어야 인식함
                                         
                                             element.style.color = 'red';            // 텍스트 색상을 빨간색으로 설정
                                             element.style.backgroundColor = 'blue'; // 배경 색상을 파란색으로 설정
                                             element.style.fontSize = '20px';        // 폰트 크기를 20px로 설정
 
                            (CSSStyleDeclaration 객체의 메서드 setProperty)
                              1. CSSStyleDeclaration.setProperty('kebab-case CSS속성명','속성값');
                                  : CSS 속성을 설정하는 보다 공식적인 방법으로 'CSS속성명'을 parameter로 작성시 본래 방식인 kebab-case 형식으로 사용이 가능
 
                                     -> (참고) setProperty를 사용시 장점
                                          1) 'CSS속성명'을 적을 시 본래 방식인 kebab-case 형식으로 사용이 가능하여, 헷갈리지 않음
                                              (= background-color, font-size를 그냥 CSS속성명 그대로 사용해도 됨)
 
                                          2) 특정 'CSS속성명'이 JS의 예약어인 경우 setProperty 메서드를 사용하면 충돌을 예방 가능
 
                                             ex) float의 경우 부동소수점 자료형에 해당하여, 충돌할 염려가 존재함
                                                 
                                                 element.style.setProperty('float', 'left');
 
                                          3) 사용자가 정의한 'CSS 커스텀 속성'(= CSS 변수)를 지정하고 싶은 경우, setProperty 메서드를 사용하면 호환성 걱정 안해도 됨
 
                                             ex) element.style.setProperty('--my-custom-color', 'green');
 
                                          4) 메서드 특성상 parameter에 JS변수를 상용하여 동적으로 속성명을 변경시킬 수도 있음
 
                                             ex) propertyName이란 변수를 통해, 해당 <HTML 태그>의 setProperty 메서드를 통해 동적으로 원하는 'CSS 속성명'을 변경 가능
 
                                                 const propertyName = 'background-color';
                                                 element.style.setProperty(propertyName, 'blue');
 
                              2. CSSStyleDeclaration.setProperty('kebab-case CSS속성명','속성값', 'important');
                                  : 3번째 parameter로 'important'를 적으면, CSS의 important 플래그를 해당 <HTML 태그>에 설정이 가능함
 
                                    ex) element.style.setProperty('color', 'red', 'important');


                    b. 대상 {HTMLElement 객체}의 <HTML태그> 상태 관련 속성 정보 담은 프로퍼티
                        : boolean값으로 가져옴

                       - draggable
                          : 기준 <HTML태그>를 마우스로 drag 할수 있는지를 boolean값으로 가져옴
 
                       - hidden
                          : 기준 <HTML태그>가 화면에서 숨겨진 상태인지 여부를 boolean값으로 가져옴
                            (= rendering은 되어있지만, 화면에는 숨겨진 상태)
 
                       - contentEditable
                          : 기준 <HTML태그>의 contents 영역을 편집할 수 있는지 여부를 boolean값으로 가져옴

                    c. 대상 {HTMLElement 객체}의 내부 node 구조 조작 관련 메서드

                       - innerText
                          : 기준 <HTML태그>의 text contents 영역(= rendering 된 text)를 가져옴

                @ {HTMLElement 객체}의 메서드
                    : 해당 <HTML태그>를 대상으로 특정 이벤트 종류를 인위적으로 발생시키는 종류의 메서드가 많음
                      (= 해당 <HTML태그>에 정의된 이벤트를 발생시킬 목적으로 사용될 의도로 제작)

                   - click()
                      : 기준 <HTML태그>에 click를 수행한 것처럼 이벤트 트리거를 일으키는 메서드

                   - focus()
                      : 기준 <HTML태그>에 포커스 되도록 설정하는 메서드

                   - blur()
                      : 기준 <HTML태그>에 포커스를 해제하는 메서드

                   - scrollIntoView()
                      : 기준 <HTML태그>에 뷰포트에 나타나도록 스크롤하도록 동작하게 하는 메서드

          4. {Specific HTML Elements 객체}
               : {HTMLElement 객체}를 상속 받는 특정한 <HTML 태그>들에 해당하는 {객체}
                   -> 각 {Specific HTML Elements 객체}는 역시 자신만의 프로퍼티와 메서드가 존재

                      ex) HTMLDivElement, HTMLSpanElement, HTMLInputElement


    # {HTMLCollection 객체} VS {NodeList 객체}
       : DOM 형식으로 구축된 HTML요소 정보를 저장하는 {객체}들을 여러개 담을 수 있는 컨테이너 역할의 {유사 배열 객체}에 해당하지만, 각자만의 방식이 다른 부분이 존재함

         1. (공통점)
             : {HTMLCollection 객체}, {NodeList 객체} 둘 다 HTML요소 저장하는 {객체}들을 여러개 담을 수 있는 컨테이너 역할의 {유사 배열 객체}에 해당
                 -> {유사 배열 객체} != [배열] 
                     - map, forEach, reduce와 같은 JS [배열] 객체의 메서드 사용X
                     - length 프로퍼티를 가짐 = {객체}를 [배열]처럼 접근 가능 = 반복문을 돌 수 있음
                     -  깊은 복사를 통하던 얕은 복사를 통하던 둘 다 {유사 배열 객체} -> [배열] 변환이 권유
                        (= [배열] 관련 메서드를 사용하고 못하고의 차이를 극복하려고 하기 때문)
                            -> (중요) 특히 {live DOM 객체}의 경우 무조건 실시간으로 HTML요소의 변화를 반영하니, [배열]로 변환해서 정적(static)한 HTML요소를 저장하여 다루도록 하는 것이 좋음
                                
                                ex) class속성이 'purple'이란 HTML요소들을 getElementByClassName('purple')로 찾은뒤, 해당 {HTMLCollection 객체}.length를 통해 반복문을 수행하여, class속성 값을 바꾼다면?
                                     -> 1번쨰 {element 객체}의 class속성값이 바뀌는 순간 {HTMLCollection 객체}의 내부 구성에서 1번쨰 {element 객체}가 빠지면서 {HTMLCollection 객체}.length와 index 정보도 변경
                                        (= 초기와 다르게 원래 2번쨰 {element 객체} -> 1번째가 되고, 3번쨰 {element 객체} -> 2번째가 되면서, {HTMLCollection 객체}[1]이 나타내는 {element 객체}가 변하기에 본래 2번쨰 객체는 건들지 못함

              @ (참고) {유사 배열 객체}
                  : index를 가지고, length 프로퍼티를 가지고 있어 순환이 가능한 iterable한 특성을 가지고 있는 {객체}지만, [배열]은 아닌 {객체}
                    (= 일부 [배열]의 특성을 가지고 있는 {객체}를 의미)
              
              @ {유사 배열 객체} vs [배열]
      
                 - (공통점)
                     1. index를 가지고, length 프로퍼티를 가지고 있는 iterable한 특성을 가지고 있음
                     2. iterable한 특성이 있어 반복문(스프레드 연산자, for ...of , Array.from() 등) 사용 가능함
           
                 - (차이점)
                     : map, forEach, reduce과 같은 [배열]의 메서드를 사용이 불가능함

         2. (차이점)

             a. ES6를 기준으로 등장 및 사용 여부가 극명하게 갈림
                (= getElement() VS querySelector('CSS셀렉터')와 맥락이 연관)

                - {HTMLCollection 객체}
                   : 주로 ES6이전에 사용되는 DOM 탐색 메서드인 'getElement()' 메서드 종류의 반환값에 해당하는 {객체} 자료형

                - {NodeList 객체}
                   : 주로 ES6이후에 사용되는 DOM 탐색 메서드인 'querySelector('CSS셀렉터')' 메서드 종류의 반환값에 해당하는 {객체} 자료형

             b. 컨테이너 역할의 {객체}로서 내부에서 다루는 요소에 해당하는 {객체}가 다름

                - {HTMLCollection 객체}
                    : 엄격하게 {HTML element 객체} 단위의 <HTML태그>에 해당하는 내용들만 대상으로 컨테이너 역할을 수행하는 {객체}
                        -> DOM객체의 요소들을 <HTML태그> 단위로만 저장하기에, 계층 및 구조가 직관적이므로 이터러블 방식으로 순회하여 원하는 <HTML 태크>를 찾는 코드를 짜기는 수월함
  
                - {NodeList 객체}
                    : {Node 객체}를 시작으로 그 {자손 객체}에 포함되는 모든 자료형 단위의 내용들을 대상으로 컨테이너 역할을 해주는 {객체}
                      (= {NodeList 객체}는 특정 단위에 해당하는 {Node 객체}만 담는 게 아니라, {Node 객체}를 상속하는 모든 {자손 객체}들도 담을 수 있다는 말)
                           -> 그래서 {NodeList 객체}의 요소로 {Element 객체} 메서드도 사용이 가능함
                         
                              ex) {Element 객체), {Text 노드 객체}, {Comment 노드 객체}
                                    -> 후손인 {Element 객체}로 표현할 수 없는 HTML요소들은 가장 선조에 해당 {Node 객체}로 저장하여 담음

             c. 내부 프로퍼티 및 메서드 구성에 차이가 있음 
                 : 결국 내부요소 순환과 연관된 메서드와 프로퍼티이긴 하지만, {NodeList 객체}의 경우 반복문과 연계하기는 더 좋음
               
                - 공통 프로퍼티 length
                   : 현재 {HTMLCollection 객체} 나  {NodeList 객체}가 가지는 내부 요소의 수를 저장

                - {HTMLCollection 객체} 메서드 

                       1) item(숫자)
                           : parameter의 숫자를 통해 {HTMLCollection 객체}의 index에 해당하는 요소를 지정할 수 있음
   
                       2) nameditem('name속성값')
                          : parameter의 'name속성값'를 통해 {HTMLCollection 객체}에서 name속성 중 'name속성값'을 가진 요소를 지정할 수 있음
        
                - {NodeList 객체} 메서드
                   -> (중요) [배열]은 아니지만, 내부 요소 순환용 메서드 foreach메서드는 사용 가능함 

                       1) item(숫자)
                           : parameter의 숫자를 통해 {NodeList 객체}의 index에 해당하는 요소를 지정할 수 있음
   
                       2) keys()
                          : {NodeList 객체} 내의 index를 순회할 수 있는 Iterator를 반환하는 메서드
                              -> for...of 루프와 함께 사용

                                 ex) const nodeList = document.querySelectorAll('div');
                                     for (const index of nodeList.keys()) {
                                         console.log(index); 
                                           ->  0, 1, 2, ...
                                     }

                       3) values()
                          : {NodeList 객체} 내의 value값을 순회할 수 있는 Iterator를 반환하는 메서드
                              -> for...of 루프와 함께 사용

                                 ex) const nodeList = document.querySelectorAll('div');
                                     for (const node of nodeList.values()) {
                                         console.log(node); 
                                           ->  각 div 요소
                                     }
                                     
                       4) entries()
                          : {NodeList 객체} 내의 index와 value값을 순회할 수 있는 Iterator를 반환하는 메서드
                              -> for...of 루프와 함께 사용

                                 ex) const nodeList = document.querySelectorAll('div');
                                     for (const [index, node] of nodeList.entries()) {
                                         console.log(index, node);
                                           ->  각 index, div 요소
                                     }

                       5) foreach()
                          : {NodeList 객체} 내의 요소나 index를 콜백함수의 parameter로 넣으면 순차적으로 콜백함수에서 가공할 수 하는 용도로 해당 콜백함수를 parameter로 가지는 {NodeList 객체} 자체에서 제공하는 메서드
                            (= [배열]의 그것과 이름은 같지만, 근본은 다른 메서드) 
                          
                            ex) const nodeList = document.querySelectorAll('div');
                                nodeList.forEach( (node, index) => {
                                  console.log(node, index); 
                                    -> 각 div, index 요소 출력
                                });

             d. 내부 요소로서 저장된 {객체}가 실시간으로 HTML요소의 변화를 반영하는 {live DOM 객체}인지 여부

                - {HTMLCollection 객체}
                   : {live DOM 객체} 형식에 해당하는 개별 HTML요소인 {HTML element 객체}를 여러개 저장 가능한 {유사 배열 객체}
                      -> {HTMLCollection 객체} = 실시간으로 자신의 변화를 감지하고 반영하는 {HTML element 객체} 여러개를 {유사 배열} 형태로 담을 수 있는 {객체}
                           -> (중요) 특히 {live DOM 객체}의 경우 무조건 실시간으로 HTML요소의 변화를 반영하니, [배열]로 변환해서 정적(static)한 HTML요소를 저장하여 다루도록 하는 것이 좋음
  
                               ex) class속성이 'purple'이란 HTML요소들을 getElementByClassName('purple')로 찾은뒤, 해당 {HTMLCollection 객체}.length를 통해 반복문을 수행하여, class속성 값을 바꾼다면?
                                    -> 1번쨰 {HTML element 객체}의 class속성값이 바뀌는 순간 {HTMLCollection 객체}의 내부 구성에서 1번쨰 {HTML element 객체}가 빠지면서 {HTMLCollection 객체}.length와 index 정보도 변경
                                       (= 초기와 다르게 원래 2번쨰 {HTML element 객체} -> 1번째가 되고, 3번쨰 {HTML element 객체} -> 2번째가 되면서, {HTMLCollection 객체}[1]이 나타내는 {HTML element 객체}가 변하기에 본래 2번쨰 객체는 건들지 못함
                           
                - {NodeList 객체}
                   : {non-live DOM 객체} 형식에 해당하는 개별 HTML요소인 {Node 객체}를 여러개 저장 가능한 {유사 배열 객체} + 자체적으로 forEach 메서드는 사용 가능
                      -> {NodeList 객체} = 정적(static)인 HTML요소를 저장하는 {Node 객체} 여러개를 {유사 배열} 형태로 담을 수 있는 {객체} + 자체적으로 forEach 메서드는 사용
                           -> (중요) BUT! {NodeList 객체}에서도 ES6 이전 감각으로 사용가능하게 만든 {NodeList 객체}의 일부 메서드들은 최대한 유사하게 재현하였기에 예외적으로 {live DOM 객체}를 반환하기도 함
     
                               ex) {NodeList 객체}.childNodes, {NodeList 객체}.getElementsByTagName(), {NodeList 객체}.getElementsByClassName()


    # {document 객체}의 메소드들
       : {document 객체} 내부의 메서드들에 해당하며, API 호출은 'document.메서드명(파라미터)' 식으로 호출함

        1. DOM 객체 요소 검색 메서드
            : 브라우저에서 표준적으로 기본 제공하는 WEB API 중 하나로, JS문법을 사용하여 DOM(document object model) 형태로 표현된 document객체에 있는 화면의 요소들을 지정하여 접근하기 위한 document객체의 메서드
               -> 성능   : getElement 메서드 seris 승
                  편의성 : css선택자 사용 가능한 querySelector 메서드 seris
  
          @ (ES6 이전까지 사용) getElement 메서드 seris
             : ES6가 등장하기 이전까지 원하는 HTML요소에 해당하는 DOM객체에 접근하기 위해 사용했던 {document 객체}의 DOM 검색 메서드 종류
                -> (단점) CSS선택자의 종류에 대응하는 메서드들이 각각 존재하기에, 관련 메서드가 너무 많고 확장성이 구리다는 면에서 매우 불편함
                     -> document.querySelector('css속성명') 방식이 등장하게 된 이유
  
               a. 조건에 맞는 HTML 태그를 여러 개 탐색하여, 각각 {live DOM 객체} 형태로 변환 후 이를 유사배열인 {HTMLCollection 객체}에 담아서 반환하는 메서드 
                  (= {HTMLCollection 객체}는 검색된 HTML요소를 {live DOM 객체}로 변환한 데이터들을 담는 컨테이너 역할을 수행하는 {객체}라고 볼 수 있음 )
                      -> 여러개의 {live DOM 객체} 형태의 HTML요소들의 정보를 담을것을 상정하였음 = 개별 HTML요소 데이터에 접근하려면 [배열]과 같은 index접근 필요
  
                  1) document.getElementsByTagName('html태그명')[index번호]
                      : 현재 화면의 DOM객체에서 parameter로 입력한 <html태그명>에 해당하는 모든 HTML 태그들을 {HTMLCollection 객체} 형식으로 반환하는 메서드
                        (= 해당 화면의 HTML에서 <html태그명>에 해당하는 모든 태그들을 {HTMLCollection 객체} 형식으로 찾아서 담아 제공함)
        
                        ex) 모든 <h1> 태그를 찾아서 {HTMLCollection 객체} 형식으로 반환하고, 2번째 {HTML요소 객체}를 반환함
                             : document.getElementByTagName("h1")[1]
                                
                        ex) 존재하는 모든 html 태그를 찾아서 {HTMLCollection 객체} 형식으로 반환함
                             : document.getElementByTagName("*");
     
                  2) document.getElementsByClassName('class속성명')[index번호]
                      : 현재 화면의 DOM객체에서 parameter로 입력한 'class속성명'을 가지는 모든 HTML 태그들을 {HTMLCollection 객체} 형식으로 반환하는 메서드
                          -> (참고) 공백을 사용하면 여러 개의 class를 지정 가능
        
                        ex) 'product'와 'premium'라는 class속성명을 모두 가진 모든 html요소들을 찾아서 {HTMLCollection 객체} 형식으로 반환함
                              : document.getElementByClassName("product premium");
        
                  3) document.getElementsByName('name속성명')[index번호]
                      : 현재 화면의 DOM객체에서 parameter로 입력한 'name속성명'을 가지는 모든 HTML 태그들을 {HTMLCollection 객체} 형식으로 반환하는 메서드
                         -> BUT! WebKit 브라우저에서는 NodeList 를 반환한다고 함
        
                        ex) 'my-form'라는 name속성명을 가진 모든 html요소들을 찾아서 {HTMLCollection 객체} 형식으로 반환함
                              : document.getElementsByName("my-form");
  
               b. 조건에 맞는 HTML 태그를 1개만 탐색하여, HTML 태그를 {live DOM 객체}형식의 {HTML요소 객체} 형식으로 반환하는 메서드
                  (= {HTML요소 객체} : 사실상 HTML태그 그 자체를 의미하는 {객체})
  
                  1) document.getElementById('Id명')
                      : 현재 화면의 DOM객체에서 parameter로 입력한 'Id명'을 가지는 HTML 태그들 중 1번째로 찾은 요소만 {HTML element 객체} 형식으로 반환하는 메서드
                         -> 1개만 찾는 이유는 ID속성 자체가 document 내에서 유일하다는 특성을 가진다는 의미(symantic)를 가지고 있는 속성이기 때문  
        
                        ex) 'box'라는 Id속성명을 가진 1개의 html요소들을 찾아서 {HTML요소 객체} 형식으로 반환함
                              : document.getElementById("box");
  
          @ (ES6 이후 사용) querySelector 메서드 seris
             : ES6 이후 querySelector라는 1종류의 DOM요소 검색 메서드에 parameter로 넣을 속성값으로 'CSS 선택자' 문법을 적용할 수 있게 개선 + {NodeList 객체}만을 반환하는 DOM검색 메서드 계열
                -> (참고) 검색할 속성 종류에 따라 메서드를 외울 필요가 없고, parameter로 넣을 속성값으로 'CSS 선택자'를 다르게 하면 되는지라 편의성이 급상승함
                -> (중요) 일반적으로 반환하는 {NodeList 객체}는 {non-live DOM 객체} 형태로 저장되어 있음
                          (= {NodeList 객체}에서 저장하는 개별 HTML요소의 정보를 정적(static)으로 저장하여 상태 변화가 일어나도 반영 X)
                               ->  BUT! 몇몇 예외적으로 {live DOM 객체}를 반환하는 경우가 존재함
                   
                                   ex) ES6 이전부터 사용되어 왔던, {HTMLCollection 객체}의 일부 DOM 탐색 메서드나 프로퍼티들을 {NodeList 객체}에서도 사용할 수 있게 한 경우.. 기능 유사성을 위해 많은 부분의 예외성을 허용
                                        : {NodeList 객체}.childNodes, {NodeList 객체}.getElementsByTagName(), {NodeList 객체}.getElementsByClassName()
  
               a. document.querySelectorAll('CSS 선택자')
                   : 'CSS 선택자' 조건에 해당하는 HTML 태그를 여러 개 탐색하여, 각각 정적인 HTML형태의 {non-live DOM 객체} 형태로 변환 후 이를 유사배열인 {NodeList 객체}에 담아서 반환하는 메서드 
                       -> 여러개의 {non-live DOM 객체} 형태의 정적인 HTML요소들의 정보를 담을것을 상정하였음 = 개별 HTML요소 데이터에 접근하려면 [배열]과 같은 index접근 필요
  
                     ex) class속성의 값이 product와 premium이 동시에 적용되어 있는 HTML요소를 모두 찾은 뒤, 모든 HTML요소의 내용은 탐색이 이뤄진 실행 시점 기준으로 하여 {NodeList 객체}로 저장하고 거기서 3번째  {non-live DOM 객체}인 Node를 반환 
                          : document.querySelector(".product.premium")[2];
  
               b. document.querySelector('CSS 선택자')
                   : 'CSS 선택자' 조건에 해당하는 HTML 태그를 1개만 탐색하여, 정적인 HTML형태의 {non-live DOM 객체} 형태로 변환 후 이를 유사배열인 {NodeList 객체}에 담아서 반환하는 메서드 
               
                     ex) id속성의 값이 userForm고, 그 자식 HTML요소의 id속성의 값이 username에 해당하는 HTML요소를 1개만 찾은 뒤, 탐색이 이뤄진 시간 당시의 내용을 가지는 HTML요소 정보를 반환해라
                          : document.querySelector("#userForm #username");
  
  
        2. DOM Event 메서드 (= 이벤트리스너(EventListener) )
            : DOM(document object model) 형태로 표현된 document객체에 있는 화면의 HTML요소들이 사용자의 조작에 반응할 수 있도록, 이벤트(event)를 정의하고 연결해주는 메서드

             @ 이벤트리스너(EventListener) 메서드 문법
                : {Node 계열 객체}.addEventListener("이벤트명" , 콜백함수 , (생략가능) capturing 단계까지 적용 true/false) 
                    -> DOM 객체 요소 검색 메서드를 사용한 뒤, 메서드 체이닝(method chaining) 형식으로 사용
                       (= {Node 객체}부터가 addEventListener() 메서드가 정의되어 있기에, querySelector로 사용 가능)

                       ex) thmb아이디를 클릭했을 때 콘솔에 출력되는 이벤트 실행
                       
                           let container = document.getElementById("container");
                           container.addEventListener("click", function(){},false);
 
                           document.getElementById('thmb').addEventListener('click', fuction(){console.log("썸네일");})

             @ 이벤트리스너(EventListener) 메서드의 parameter 요소 설명

               a. 이벤트
                   : 사용자가 해당 HTML 요소에 취하는 조작에 해당하는 명칭에 해당하는 1번째 parameter... 
                   
                     ex) click, change, focus, keydown, keyup, load, mousedown, mouseout, mouseover, mousemove, mouseup, select, touchstart 등...
                          -> 종류는 ㅈㄴ게 많기에 필요할 때 찾아서 응용하기

               b. 콜백함수
                   : 해당 HTML 요소에 대한 사용자의 조작이 성립할 시, 이를 기다렸던 이벤트 리스너(EventListener)에 의해 수행해야 할 내용부를 담는 '모듈' 역할을 담당하는 2번째 parameter 
                      -> (참고) 무명함수를 콜백함수로 작성해도 상관없음 
                      -> (중요) 무명함수의 1번째 parameter인자를 붙이게 된다면, {event객체}에 해당함
                           : {event객체}를 통해 무명콜백함수의 내용부에서 event와 관련된 프로퍼티 및 메서드를 사용하여 더 이벤트 내용부에 디테일한 기능과 로직을 세울 수 있음

                              ex) event객체를 통해, 해당 event 흐름의 정보나 통제를 위한 메서드를 사용할 수 있음

                                  document.getElementById('child').addEventListener('click', function(event) {
                                    alert('Child clicked');
                                    event.stopPropagation();  // 부모 요소로 이벤트 전파를 막음
                                  }, false);

               c. (생략 가능) capturing 단계까지 적용 여부
                    : 이벤트 흐름(Event Flow)에 있어 capturing까지 모두 적용할 건지 true/false(기본값)로 사용 여부를 정하는 (생략 가능한) 3번째 parameter 
                       -> false (기본값)
                           : 이벤트 발생시 'capturing 단계를 제외'한 나머지 이벤트 흐름(Event Flow)을 전개함 
                             (= capturing 단계는 존재하지 않은 것이며, 이벤트 흐름은 target 단계(phase)에서 시작하는 걸로 간주)
                                 -> target 단계(phase) - Bubbling 단계(phase)
                       -> true 
                           : 이벤트 발생시 모든 이벤트 흐름(Event Flow)을 전개
                              -> capturing 단계(phase) - target 단계(phase) - Bubbling 단계(phase)

             @ {이벤트 객체}
                : 이벤트리스너(EventListener) 메서드를 작성시 2번째 parameter에 해당하는 무명콜백함수의 1번째 parameter인자를 붙일 경우, 접근 가능한 event와 관련된 프로퍼티 및 메서드를 담은 객체

                  1. {이벤트 객체}의 프로퍼티(properties)
                  2. {이벤트 객체}의 메서드

                      1) 이벤트 흐름(Event Flow)을 제어하는 메서드
                          a. event.stopPropagation()
                              : 해당 이벤트가 버블링(Bubbling) 또는 캡처링(capturing) 단계에서 더 이상 전파되지 않도록 함
                                 -> (중요) 이벤트리스너(EventListener) 메서드의 3번째 paramter인 capturing 단계까지 적용 여부가 false이거나 생략된 경우?
                                      : target에 도달하기도 전에 이벤트 흐름이 끊기는 일은 일어나지 않음
                                        (= capturing 단계는 존재하지 않은 것으로 이벤트 흐름은 target 단계(phase)에서 시작하는 걸로 간주)

                          b. event.stopImmediatePropagation()
                              : 현재 이벤트 대상(target)인 HTML 요소에 등록된 다른 이벤트 핸들러까지 모두 포함해서, 이벤트의 전파를 완전히 막음

                                ex) child 버튼을 클릭하면, Child clicked 알림만 뜨고 Parent clicked 알림은 뜨지 않음

                                    <div id="parent" style="padding:50px; background-color:lightblue;">
                                      Parent
                                      <button id="child" style="padding:20px;">Child</button>
                                    </div>
                                  
                                    <script>
                                      document.getElementById('parent').addEventListener('click', function() {
                                        alert('Parent clicked');
                                      });
                                  
                                      document.getElementById('child').addEventListener('click', function(event) {
                                        alert('Child clicked');
                                        event.stopPropagation();  // 부모 요소로 이벤트 전파를 막음
                                      });
                                    </script>

                          c. event.preventDefalut()
                              : 현재 이벤트 대상(target)인 HTML 요소에서 표준으로 제공하는 <HTML태그>의 기본 이벤트 발생을 막는 메서드

                                ex) <a> 태그에 해당하는 HTML 요소에 이벤트를 정의하는데, 콜백함수의 내용부에 event.preventDefalut()를 사용한다면?
                                      -> <a> 태그의 href 변경을 통한 링크 기능이 작동하지 않음

             @ 이벤트 흐름(Event Flow)
                : 사용자가 어떤 HTML요소를 조작하여 이벤트가 일어나면, 해당 HTML요소를 목표(target) 기점으로 하여 그 모든 선조 HTML요소들을 이벤트를 일으키는 대상으로 보는데...
                   -> 그렇게 '최선조 - ... - target - ... - 최선조'로 차례를 지켜 이벤트를 발생시키는 순서를 의미하며, 3가지 단계로 구분
                      ({이벤트 객체}의 메서드를 통해, 구체적인 단계에서 이벤트 전파를 막아 해당 이벤트 흐름을 제어하는게 가능)
                       
                      a. 캡처링 단계 (Capturing Phase)
                          : 이벤트의 발동 대상의 '최선조 HTML 요소 ~ 부모 HTML 요소'로 이벤트 작동이 전파되는 과정(Capturing)이 일어나는 단계

                      b. 타깃 단계 (Target Phase)
                          : 이벤트가 실제로 목표(Target) HTML 요소에서 발생하는 단계

                      c. 버블링 단계 (Bubbling Phase)
                          : 이벤트의 발동 대상이 다시 역순으로 '부모 HTML 요소 ~ 최선조 HTML 요소'로 이벤트 작동이 회수되는 과정(Bubbling)이 일어나는 단계



 - WEB component
    : 사용자가 스스로 정의해서 제작한 만들어진 '커스텀 HTML <태그>'라고 생각하면 됨
      (= 역으로 말하자면, 기본 HTML태그는 기본 제공되는 WEB component라고 볼 수 있음)
          -> (중요) React, Vue 등등 대부분의 프론트엔드 관련 라이브러리나 프레임워크에서 말하는 component도 해당 개념과 비슷

     # WEB component 제작법

        1. class 문법으로 HTMLElement라는 JS객체를 상속받는 class를 선언

        2. 그 내부의 메서드로 connectedCallback()을 정의하고, {}안에 넣을 HTML 내용들에 해당하는 명령어를 입력해주면 됨

          @ connectedCallback() 작성시 참고 사항

             1) connectedCallback() 함수는 해당 WEB compoent가 HTML에 장착될 시점에서 실행됨
                (= component 생성 시점을 잘못 계산하면, 없는 태그라니 하는 식으로 페이지 로드시 많은 것들이 꼬일 수 있음)

             2) connectedCallback() 함수에 HTML 내용 입력 방식
                 a. HTML 내용 입력시 this.innerHTML = 'compoent 내용'에 해당하는 부분을 문자열 형식으로 입력
                 b. HTML 내용 입력시 태그를 생성하고 배치하는 JS 함수를 사용

             3) this.getAttribute('속성명')을 사용하면, 추후 <component /> 선언 시 사용자가 넣는 '속성명'의 값을 가져올 수 있음
                 -> 이를 지역변수에 할당해서, 구체적인 component 내용에 써먹음으로서, HTML을 동적으로 구성 가능 

             4) style을 넣고 싶으면, 내용에 <style> 태그를 넣고 스타일을 부여하면 됨
                 -> BUT! 해당 WEB component 이외의 다른 component들에도 style 선택자 조건만 맞으면 영향을 미칠 수 있음
                    (= 의도하지 않은 오염이 발생할 수 있음)
                        -> (중요) WEB component의 style이 지역변수처럼 작동하게 하고 싶다면, shadow DOM까지 열어서 거기 집어넣으면 해결됨
      
        3. 작성한 component에서 특정 '속성명'의 변경이 감지되면, 이를 바로 HTML내용에 반영되도록 반응형 component를 원한다면?
            -> static get observedAttributes() 메서드와 attributeChangedCallback()를 작성함
               (이 부분을 응용하면, React, Vue에서 제공하는 새로고침 없는 자동 html 재렌더링 기능도 특정 attribute 변화를 감지하면 변경해주는 식으로 구현 가능함!)

               @ static get observedAttributes() 메서드
                  : 해당 WEB component에서 변경여부를 감시할 속성들을 제시하도록 도와주는 메서드로 [변경여부를 감시할 속성들] 형식으로 반환
     
               @ attributeChangedCallback()
                  : static get observedAttributes()에서 반환한 [변경여부를 감시할 속성들]이 변하는것이 감지되면, 해당 메서드의 내용을 수행하여 component의 변경을 수행하는 함수

        3. 다 작성했으면 customElements.define("원하는 compoent명",작성한 component 클래스명); 를 class 외부에 작성함
           (= 이를 통해, 사용자 정의 WEB component가 사용 가능)

           ex) name 속성에 따라 동적으로 내용이 달라지고 실시간 변경되는 Web component 작성
           
               class 클래스 extends HTMLElement {
    
                  connectedCallback() {
                     let name = this.getAttribute('name');
                     this.innerHTML = '<label>${name}을 입력하쇼</label><input>
                                       <style> label { color : red } </style>`
                  }
               
                  static get observedAttributes() {
                      return ['name']
                  }
                  attributeChangedCallback() {
                      (attribute 변경시 실행할 코드)
                  }
               }
 
                customElements.define("custom-input", 클래스);

        4. HTML 영역에 원하는 부분에 <compoent명 속성명="값"></compoent명> 이런 식으로 작성하면 완료..

           ex) HTML 영역에 해당 WEB component를 name속성과 함께 작성

                <custom-input name="이메일"></custom-input>
                <custom-input name="비번"></custom-input>
 
      # WEB component의 세부적 개념 및 특성 정리

         1. 해당 WEB component에만 귀속되고 적용되는 style을 적용하기 쉽지 않음
             -> shadow DOM을 쓰거나, ``과 style속성을 써보면 해결은 될 수 있음

         2. WEB component class를 export하고 어디서나 import하여 <component>를 재활용이 가능함
             -> BUT! 누누히 말하지만, style과 같이 다른 component에도 적용이 되는 암묵적 결합 요소가 있을 수 있음
                 -> 타 component를 오염시키지 않으면서, 내부에서 완전히 독립적으로 작동하고, 일부를 사용자에게 보여주지 않을 component를 제작하려면? 
                     -> shadowDOM을 알아야 함

         3. react나 vue의 component들도 기본적으로 WEB component가 제공하는 기술적 역할을 모두 수행가능하나... 
             -> BUT, 해당 라이브러리나 프론트엔드에서 추구하는 VDOM을 통한 state기반 재랜더링과 같은 기능들이 추가된 것으로 이해하면 됨


 - Shadow DOM(document of model)
    : 개별 WEB component(웹 컴포넌트)의 내부 구조가 DOM모델로 구성되어 있는 영역을 그림자와 같이 드러나지 않게 캡슐화하여, 사용자로부터 그 구조와 스타일이 변형되지 않도록 보호하고 독립적인 모듈로서 사용이 가능하게 만드는 기술
      (쉽게 설명하자면, 메인보드의 설정 화면이 평소에는 초보사용자가 알 필요없는 부분은 보이지 않지만, 숙련자용 설정을 키면 세세한 세팅까지 다 할 수 있게 기술적으로 보여줄 수 있게 하는 원리와 유사함)
        -> 기본 HTML 태그들이 생각보다 내용이 복잡함에도 <태그명> 방식으로 쉽게 사용이 가능한 이유에 지분을 많이 가지고 있음

            ex) <input type="range">의 경우 실제로는 꽤 복잡한 component와 같이 내부가 설계되어 있음

     # shadowDOM의 키워드
        1. 내부 HTML요소들의 캡슐화
        2. 캡슐화를 통한 편의성 증대
        3. shadowDOM 내부 요소들의 지역변수화 (= 암묵적 결합 원천 봉쇄)
        4. WEB component에 적용하여, HTML 모듈화 개발이 가능하게 하는 기술적 원천

     # Shadow DOM을 보지 못하게 하는 이유 요약
        : 보안과 연관된 설계의도로 인해, 개발된  web component(웹 컴포넌트)의 구조와 스타일이 기본적으로 외부로부터 보호되길 원했음
          (= 브라우저가 Shadow DOM의 내부 구조를 외부로 노출하지 않는 것은 캡슐화가 설계 의도에 들어있기 때문임)
              -> 캡슐화를 적용하여 논리적인 그룹을 형성하고, 재사용성을 높이고 유지 보수를 용이하게 함

     # Shadow DOM을 통한 캡슐화의 이점

        1. 개발자 편의성 제공 

           ex) 웹 개발시 기본적인 HTML태그의 세부 설계구조를 몰라도, 개발자는 input 같은 복잡한 기본태그를 WEB component(웹 컴포넌트) 사용하듯 쉽게 쓸 수 있음 
               (= Shadow DOM을 볼 수 있다는 의미는 HTML 개발시 코드가 너무 복잡해지지 않기 위해 숨겨놓은 HTML 요소들에 대한 구조를 원한다면 까볼 수 있다는 이야기)

        2. 진정한 의미의 html 태그들의 독립적인 모듈화 개발이 가능
           (= 각 web component들이 다른 모듈로 취급되어, 서로 영향을 끼치는걸 막을 수 있음)

           ex) WEB component(웹 컴포넌트)의 style의 경우 shadow DOM 열어서 거기 집어넣으면, 다른 DOM이나 WEB component(웹 컴포넌트)에 영향을 끼치지 않음
                -> 원하는 곳에서 class 만 export 해서 가져다 쓰면 컴포넌트로 모듈식 개발이 가능하게 만듦

                   ex) 일반 WEB component(웹 컴포넌트)에 style을 넣으면? 다른 component나 태그에 영향을 줌
                   
                       class 클래스 extends HTMLElement {
                         connectedCallback() {
                           this.innerHTML = `<label>이름을 입력하쇼</label><input>
                             <style> label { color : red } </style>`
                         }
                       }
                       customElements.define("custom-input", 클래스);
        
                       <custom-input></custom-input>
                       <label>왜 나까지 빨개짐?</label>
               
                   ex) shadow DOM에 style을 넣으면? 다른 component나 태그에 1도 영향을 주지 않고, 해당 WEB component(웹 컴포넌트)에서만 영향을 미침
                   
                       class 클래스 extends HTMLElement {
                         connectedCallback() {
                           this.attachShadow({mode : 'open'});
                           this.shadowRoot.innerHTML = `<label>이름을 입력하쇼</label><input>
                             <style> label { color : red } </style>`
                         }
                       }
        
                       customElements.define("custom-input", 클래스);
        
                       <custom-input></custom-input>
                       <label>왜 나까지 빨개짐?</label>

     # 그래서 Shadow DOM을 알아야 하는 이유?

        1. Shadow DOM 개념을 안다면, 평소에는 수정하거나 변경 못하게 한 component들의 내부구조에 해당하는 영역도 CSS의 가상 요소(pseudo element)와 결합하여 셀렉터로 접근할 수 있음
           (= 일반적으로는 막혀있어 커스터마이징 할 수 없었던 특정 태그나 component들의 내부 HTML요소(ex. input)도 커스터마이징이 가능!)
           
           ex) shadowDOM 요소에 style이나, 이벤트리스너 부착 가능!

               <custom-input></custom-input>
               
                 <template id="template1">
                   <label>이메일을 입력하쇼</label><input>
                   <style>label { color : red }</style>
                 </template>
               
                 <script>

                   class 클래스 extends HTMLElement {

                     connectedCallback() {

                       this.attachShadow({mode : 'open'});
                       this.shadowRoot.append(template1.content.cloneNode(true));

                       let el = this.shadowRoot.querySelector('label');

                       el.addEventListener('click', function(){
                         console.log('클릭함')
                       })

                     }
                   }

                   customElements.define("custom-input", 클래스);
                 </script>

        2. 어떤 WEB component의 style 속성이 완전히 독립적으로 해당 component에서만 지역변수처럼 작동하게 하고 싶다면, shadow DOM에 style을 적용해야 하기 때문
           (= react나 vue의 그 component들처럼 해당 component안에서만 style이 국한되게 할 수 있음)

        3. Shadow DOM 개념이 있어야 완벽하게 사이드이팩트 없이 독립적으로 기능하는 WEB component를 제작하여, html 모듈화 개발을 할 수 있음
           (= export한 WEB component class를 어디서나 import하여 <component>를 붙여넣어도 완벽히 독립적으로 작동할 수 있기에, html 모듈화가 가능하고 이를 웹 개발이 편의적으로 활용이 가능함)

     # Shadow DOM VS WEB component
        : WEB component와 Shadow DOM은 전혀 다른 개념이지만, 둘이 결합된 개념을 통해 사용자가 정의한 <태그>에 재사용성을 통한 편의와 더불어 높은 수준의 캡슐화를 더해서, 진정으로 독립적으로 기능하는 Web Component를 제작가능
           -> (중요) 이렇게 만들어진 완벽하게 독립적으로 기능하는 WEB component를 통해서, html을 조립하듯 html 모듈화 개발을 할 수 있기에.. Shadow DOM과 WEB component는 세트메뉴로 묶일 수 밖에 없음

              @ WEB component
                : 사용자가 제작한 <태그>가 모듈로서 기능할 수 있도록, 재사용성이라는 키워드에 포커스를 맞추고 구현된 기능
                   -> 그래서인지 캡슐화적 개념이 기능에서는 집중되지 않음
       
              @ Shadow DOM
                : 이미 존재하는 <태그>의 내용을 기본적으로 비공개하고, 내부 요소들을 완벽하게 독립적인 지역변수화시켜 component 외부로 영향성을 주지도, 내부에서 받지도 않게 만들기를 원할 때 사용하는 것이 Shadow DOM
                   -> (참고) 엄연히 실존하는 HTML문서에 해당하는 DOM요소이기에, DOM셀렉터로 지정할 수 있음
                             (= Shadow DOM의 DOM요소들도 DOM 조작이 가능하며, style 지정이나 이벤트리스너의 부착도 가능함)

     # Shadow DOM을 개발자 도구에서 확인하는 방법
        : 개발자도구를 켠 상태에서 F12 (혹은 Settings 메뉴)를 누르면 나오는 곳에서, Show user agent shadow DOM을 체크하면 됨

     # Shadow DOM(document object model) 생성을 위한 JS문법
        1. 어떤 HTML요소를 DOM셀렉터를 통해 지정
        2. DOM셀렉터.attachShadow({mode : 'open'})을 통해, 해당 DOM요소의 ShadowDOM 영역에 진입할 수 있게 해주기
        3. DOM셀렉터.shadowRoot 영역에 원하는 <태그> 내용을 기입할 수 있도록 코드를 입력하면 됨
            -> a. HTML 내용 입력시 DOM셀렉터.shadowRoot.innerHTML = 'Shadow DOM compoent 내용'에 해당하는 부분을 문자열 형식으로 입력
 
                  ex) mordor라는 class 속성값을 가진 <div> 속성의 shadowDOM 속성으로 <p>심연에서왔도다</p>라는 태그가 들어가서, 평소에는 가려져서 보이지 않게 함
                  
                      <div class="mordor"></div>
                      <script>
                        document.querySelector('mordor').attachShadow({mode : 'open'});
                        document.querySelector('mordor').shadowRoot.innerHTML = '<p>심연에서왔도다</p>'
                      </script>
 
               b. HTML 내용 입력시 태그를 생성하고, DOM셀렉터.shadowRoot 영역에 배치하는 JS 함수를 사용
               c. HTML 내용 입력시 DOM셀렉터.shadowRoot.append('shadowDOM component 내용' or 변수명 등)을 사용
 
                  ex) 랜더링이 되지 않는 <template>태그에 shadowDOM에 담을 태그 내용을 기록한 뒤, 이를 this.shadowRoot.append(템플릿 내용 복사코드)로 태그내용 복붙하여 구현
                  
                      <template id="template1">
                        <label>이메일을 입력하쇼</label><input>
                        <style>label { color : red }</style>
                      </template>
                    
                      <script>
                        class 클래스 extends HTMLElement {
                          connectedCallback() {
                            this.attachShadow({mode : 'open'});
                            this.shadowRoot.append(template1.content.cloneNode(true));
                          }
                        }
                        customElements.define("custom-input", 클래스);
                      </script>
 
      # Shadow DOM을 활용하여 CSS 셀렉터를 통해 스타일링 하는 요령
         1. #shadow-root 아래의 숨겨진 해당 HTML태그의 Shadow DOM 구조의 HTML요소에서 pesudo속성을 찾고 그 속성값을 복사하여 가상 요소(pesudo element)와 결합하여 셀렉터 생성
            -> 원하는 HTML태그를 디버그 모드에서 검사한 뒤, #shadow-root 아래의 숨겨진 해당 HTML태그의 Shadow DOM 구조를 확인  
            -> 거기서 스타일링을 주고 싶은 요소의 pesudo속성을 찾고 그 속성값을 복사함
            -> 복사한 pesudo속성값을 가상 요소(pesudo element) 셀렉터에 이용하기 or 개발자 도구에서 셀렉터를 찾아서 그대로 CSS에 적용해도 됨 
 
                 ex) input::-webkit-input-placeholder {
                       color : red; 
                     }
 
         2. pesudo속성값이 없어서, 1번과 같은 방법을 사용 못 하는 경우?
             : 개발자 도구를 통해 CSS 셀렉터와 거기에 적용된 스타일을 찾을 수 있는데, 거기서 가상 요소가 적용된 셀렉터를 잘 찾아보면 해당 셀렉터가 등장하기도 함
 
                 ex) <inpur type="range">
                      -> [shadow DOM구조]
                         <div>
                           <div pesudo="-webkit-slider">     <- 얘는 가상요소 셀렉터로 쉽게 가져올 수 있는데?
                           <div id="thumb">                  <- 얘는 그렇게는 못 가져옴
                         </div>
                 
                      -> 개발자도구 style 영역 잘 뒤져보면 해당 html태그에 대한 셀렉터 있는데 그거 가져와서 셀렉터도 써도 됨 
 
                         input[type="range" i]::-webkit-slider-thumb {
                           appearance : none;  <- 기존 브라우저의 HTML 스타일을 아예 꺼버리는 기능 (shadow DOM 커스텀 스타일링 적용할거면 잘 참고하자) 
                           display : block;
                         }


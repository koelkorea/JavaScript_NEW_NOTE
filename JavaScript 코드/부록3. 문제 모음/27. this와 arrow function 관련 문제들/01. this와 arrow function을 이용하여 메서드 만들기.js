// [this와 arrow function을 이용하여 {객체}의 메서드 작성하고 실행하기]
//   -> arrow function에서 this가 어떻게 작용하는지를 기억해야 함

// Q1. (중요!) {사람}이라는 객체에 sayHi라는 메서드를 arrow function에서 this를 사용하여 작성해라..
//  -> 사람.sayHi()라고 호출하면 다음과 같은 내용이 콘솔에 출력되어야 하며 {사람 } 객체 내부의 name이란 프로퍼티를 써라
//      -> (힌트) arrow function 자체는 일종의 무명함수와 비슷하지만? JS의 특성을 이용하면 메서드명을 붙일 수 있을거다
//      -> (힌트) 리터럴 형식으로 생성된 {객체}는 자신의 {}가 있는거처럼 보이겠지만, 실제로는 자신의 영역이 존재하지 않음

var 사람 = {
    name: '손흥민',

    // arrow function은 this의 의미를 자신의 상위{}으로 받아들이는데, 리터럴 형식으로 생성된 {객체}는 자신의 {}를 가지지 않기에.. 무명함수 형식을 사용하지 않는다면, {window 전역 객체}를 this로 받게 됨
    //  -> 하지만 사람.sayHi()로 this가 name을 받게 해야하니, function을 통해 무명함수를 만들어 함수 {}를 만들고 this의 의미를 함수를 호출한 {객체}로 정해지게 한뒤, return 되는 arrow function을 즉시 실행이 가능하게 하면 됨 
    sayHi : function (){
        
        return (() => {
            console.log(`안녕 나는 ${this.name}`);
        })();
    }
}

사람.sayHi(); //안녕 나는 손흥민

// Q2. {자료 }이라는 객체의 내부 프로퍼티인 data가 가진 [배열]의 값을 전부 더해줘서 출력하는 메서드를 작성해라 
//  -> 단! {자료} 내부에 추가적인 코드의 작성은 금지함
//      -> (힌트) 함수를 값으로 받을 수 있는 JS의 특성을 이용한다면? {객체} 외분에서도 메서드를 설정 가능함

var 자료 = { 
    data : [1,2,3,4,5] 
}

자료.전부더하기 = () => {

    let 결과 = 자료.data.reduce((이전까지요소처리, 현재배열요소) => {
        return 이전까지요소처리 + 현재배열요소;
    });

    console.log(결과);
}


자료.전부더하기();
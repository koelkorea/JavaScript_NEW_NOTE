<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        // Q2. https://codingapple1.github.io/hello.txt 라는 URL에 GET 요청을 해서 성공하면, Promise의 then 함수를 이용해서 Ajax로 받아온 인삿말을 콘솔창에 출력해라
        //  -> (중요) fetch의 결과는 promise 객체를 반환하고, 이후 메서드 체이닝을 통해 서버로부터 받은 값을 변환하는 것 또한 promise 객체를 반환
        //     (= 다음 then, catch 체이닝 하기 전에 반드시 return을 붙여서 그 결과값을 반환해야 함)

        // Q3. Q2에서 구현한 기능 직후 https://codingapple1.github.io/hello2.txt 라는 URL에 GET 요청을 해서 성공하면 또 출력하도록 then, catch, finally로 완성해라
        //  -> 1. Q1의 hello.txt GET 요청
        //     2. 그게 완료되면 hello2.txt GET 요청
        //     3. 그게 완료되면 hello2.txt 결과를 콘솔창에 출력

        //  -> (힌트) 프로미스.then(()=>{둘째실행할거}).then(()=>{셋째실행할거}) 이렇게 then을 여러개 이어붙여 체이닝함
        //  -> (힌트) .then()은 당연히 new Promise()로 생성한 프로미스 오브젝트들에 붙일 수 있음
        //  -> (힌트) promise 메서드는 결국 promise 객체를 대상으로 함 = 다음을 이어갈 promise객체를 잘 반환해주면, 연결고리 흐름에 도움이 됨

        // (개선1) return문을 통해 원하는 방식의 promise객체를 반환하고, 이렇게 다시 메서드 체이닝으로 중첩 then 지옥없이 해결
        fetch('https://codingapple1.github.io/hello.txt').then(function(성공내용){

            return 성공내용.text();

        }).then(function(성공내용){

            console.log('성공함 : ' + 성공내용);
            
            return fetch('https://codingapple1.github.io/hello2.txt');

        }).then(function(성공내용){

            return 성공내용.text();

        }).then(function(성공내용){

            console.log('성공함 : ' + 성공내용);

        }).catch(function(실패){

            console.log('실패의 원인 : ' + 실패);
        });

    </script>
</body>
</html>